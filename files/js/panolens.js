!function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports) : "function" == typeof define && define.amd ? define(["exports"], e) : e((t = t || self).THREE = {}) }(this, (function (t) { function e() { } function i(t, e) { this.x = t || 0, this.y = e || 0 } function n(t, e, i, n) { this._x = t || 0, this._y = e || 0, this._z = i || 0, this._w = void 0 !== n ? n : 1 } function r(t, e, i) { this.x = t || 0, this.y = e || 0, this.z = i || 0 } function o() { this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.") } function a(t, e, n, r, s, c, h, l, u, d) { Object.defineProperty(this, "id", { value: vo++ }), this.uuid = fo.generateUUID(), this.name = "", this.image = void 0 !== t ? t : a.DEFAULT_IMAGE, this.mipmaps = [], this.mapping = void 0 !== e ? e : a.DEFAULT_MAPPING, this.wrapS = void 0 !== n ? n : 1001, this.wrapT = void 0 !== r ? r : 1001, this.magFilter = void 0 !== s ? s : 1006, this.minFilter = void 0 !== c ? c : 1008, this.anisotropy = void 0 !== u ? u : 1, this.format = void 0 !== h ? h : 1023, this.type = void 0 !== l ? l : 1009, this.offset = new i(0, 0), this.repeat = new i(1, 1), this.center = new i(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new o, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.encoding = void 0 !== d ? d : 3e3, this.version = 0, this.onUpdate = null } function s(t, e, i, n) { this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = void 0 !== n ? n : 1 } function c(t, e, i) { this.width = t, this.height = e, this.scissor = new s(0, 0, t, e), this.scissorTest = !1, this.viewport = new s(0, 0, t, e), i = i || {}, this.texture = new a(void 0, void 0, i.wrapS, i.wrapT, i.magFilter, i.minFilter, i.format, i.type, i.anisotropy, i.encoding), this.texture.generateMipmaps = void 0 !== i.generateMipmaps && i.generateMipmaps, this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : 1006, this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer, this.stencilBuffer = void 0 === i.stencilBuffer || i.stencilBuffer, this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null } function h(t, e, i) { c.call(this, t, e, i), this.samples = 4 } function l(t, e, i) { c.call(this, t, e, i) } function u(t, e, i, n, r, o, s, c, h, l, u, d) { a.call(this, null, o, s, c, h, l, n, r, u, d), this.image = { data: t, width: e, height: i }, this.magFilter = void 0 !== h ? h : 1003, this.minFilter = void 0 !== l ? l : 1003, this.flipY = this.generateMipmaps = !1, this.unpackAlignment = 1 } function d(t, e) { this.min = void 0 !== t ? t : new r(1 / 0, 1 / 0, 1 / 0), this.max = void 0 !== e ? e : new r(-1 / 0, -1 / 0, -1 / 0) } function p(t, e) { this.center = void 0 !== t ? t : new r, this.radius = void 0 !== e ? e : 0 } function f(t, e) { this.normal = void 0 !== t ? t : new r(1, 0, 0), this.constant = void 0 !== e ? e : 0 } function m(t, e, i, n, r, o) { this.planes = [void 0 !== t ? t : new f, void 0 !== e ? e : new f, void 0 !== i ? i : new f, void 0 !== n ? n : new f, void 0 !== r ? r : new f, void 0 !== o ? o : new f] } function g() { this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], 0 < arguments.length && console.error("THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.") } function v(t) { var e, i = {}; for (e in t) for (var n in i[e] = {}, t[e]) { var r = t[e][n]; r && (r.isColor || r.isMatrix3 || r.isMatrix4 || r.isVector2 || r.isVector3 || r.isVector4 || r.isTexture) ? i[e][n] = r.clone() : Array.isArray(r) ? i[e][n] = r.slice() : i[e][n] = r } return i } function y(t) { for (var e = {}, i = 0; i < t.length; i++) { var n, r = v(t[i]); for (n in r) e[n] = r[n] } return e } function x(t, e, i) { return void 0 === e && void 0 === i ? this.set(t) : this.setRGB(t, e, i) } function b() { function t(r, o) { !1 !== i && (n(r, o), e.requestAnimationFrame(t)) } var e = null, i = !1, n = null; return { start: function () { !0 !== i && null !== n && (e.requestAnimationFrame(t), i = !0) }, stop: function () { i = !1 }, setAnimationLoop: function (t) { n = t }, setContext: function (t) { e = t } } } function w(t) { var e = new WeakMap; return { get: function (t) { return t.isInterleavedBufferAttribute && (t = t.data), e.get(t) }, remove: function (i) { i.isInterleavedBufferAttribute && (i = i.data); var n = e.get(i); n && (t.deleteBuffer(n.buffer), e.delete(i)) }, update: function (i, n) { i.isInterleavedBufferAttribute && (i = i.data); var r = e.get(i); if (void 0 === r) e.set(i, function (e, i) { var n = e.array, r = e.dynamic ? 35048 : 35044, o = t.createBuffer(); return t.bindBuffer(i, o), t.bufferData(i, n, r), e.onUploadCallback(), i = 5126, n instanceof Float32Array ? i = 5126 : n instanceof Float64Array ? console.warn("THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.") : n instanceof Uint16Array ? i = 5123 : n instanceof Int16Array ? i = 5122 : n instanceof Uint32Array ? i = 5125 : n instanceof Int32Array ? i = 5124 : n instanceof Int8Array ? i = 5120 : n instanceof Uint8Array && (i = 5121), { buffer: o, type: i, bytesPerElement: n.BYTES_PER_ELEMENT, version: e.version } }(i, n)); else if (r.version < i.version) { var o = i, a = o.array, s = o.updateRange; t.bindBuffer(n, r.buffer), !1 === o.dynamic ? t.bufferData(n, a, 35044) : -1 === s.count ? t.bufferSubData(n, 0, a) : 0 === s.count ? console.error("THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.") : (t.bufferSubData(n, s.offset * a.BYTES_PER_ELEMENT, a.subarray(s.offset, s.offset + s.count)), s.count = -1), r.version = i.version } } } } function M(t, e, i, n, o, a) { this.a = t, this.b = e, this.c = i, this.normal = n && n.isVector3 ? n : new r, this.vertexNormals = Array.isArray(n) ? n : [], this.color = o && o.isColor ? o : new x, this.vertexColors = Array.isArray(o) ? o : [], this.materialIndex = void 0 !== a ? a : 0 } function _(t, e, i, n) { this._x = t || 0, this._y = e || 0, this._z = i || 0, this._order = n || _.DefaultOrder } function E() { this.mask = 1 } function A() { Object.defineProperty(this, "id", { value: _o++ }), this.uuid = fo.generateUUID(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = A.DefaultUp.clone(); var t = new r, e = new _, i = new n, a = new r(1, 1, 1); e.onChange((function () { i.setFromEuler(e, !1) })), i.onChange((function () { e.setFromQuaternion(i, void 0, !1) })), Object.defineProperties(this, { position: { configurable: !0, enumerable: !0, value: t }, rotation: { configurable: !0, enumerable: !0, value: e }, quaternion: { configurable: !0, enumerable: !0, value: i }, scale: { configurable: !0, enumerable: !0, value: a }, modelViewMatrix: { value: new g }, normalMatrix: { value: new o } }), this.matrix = new g, this.matrixWorld = new g, this.matrixAutoUpdate = A.DefaultMatrixAutoUpdate, this.matrixWorldNeedsUpdate = !1, this.layers = new E, this.visible = !0, this.receiveShadow = this.castShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.userData = {} } function T() { Object.defineProperty(this, "id", { value: Eo += 2 }), this.uuid = fo.generateUUID(), this.name = "", this.type = "Geometry", this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.lineDistancesNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.uvsNeedUpdate = this.verticesNeedUpdate = this.elementsNeedUpdate = !1 } function S(t, e, i) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); this.name = "", this.array = t, this.itemSize = e, this.count = void 0 !== t ? t.length / e : 0, this.normalized = !0 === i, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function L(t, e, i) { S.call(this, new Int8Array(t), e, i) } function C(t, e, i) { S.call(this, new Uint8Array(t), e, i) } function R(t, e, i) { S.call(this, new Uint8ClampedArray(t), e, i) } function P(t, e, i) { S.call(this, new Int16Array(t), e, i) } function I(t, e, i) { S.call(this, new Uint16Array(t), e, i) } function O(t, e, i) { S.call(this, new Int32Array(t), e, i) } function D(t, e, i) { S.call(this, new Uint32Array(t), e, i) } function N(t, e, i) { S.call(this, new Float32Array(t), e, i) } function B(t, e, i) { S.call(this, new Float64Array(t), e, i) } function z() { this.vertices = [], this.normals = [], this.colors = [], this.uvs = [], this.uvs2 = [], this.groups = [], this.morphTargets = {}, this.skinWeights = [], this.skinIndices = [], this.boundingSphere = this.boundingBox = null, this.groupsNeedUpdate = this.uvsNeedUpdate = this.colorsNeedUpdate = this.normalsNeedUpdate = this.verticesNeedUpdate = !1 } function U(t) { if (0 === t.length) return -1 / 0; for (var e = t[0], i = 1, n = t.length; i < n; ++i)t[i] > e && (e = t[i]); return e } function F() { Object.defineProperty(this, "id", { value: Ao += 2 }), this.uuid = fo.generateUUID(), this.name = "", this.type = "BufferGeometry", this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.drawRange = { start: 0, count: 1 / 0 }, this.userData = {} } function G(t, e, i, n, r, o) { T.call(this), this.type = "BoxGeometry", this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: r, depthSegments: o }, this.fromBufferGeometry(new H(t, e, i, n, r, o)), this.mergeVertices() } function H(t, e, i, n, o, a) { function s(t, e, i, n, o, a, s, m, g, v, y) { var x = a / g, b = s / v, w = a / 2, M = s / 2, _ = m / 2; s = g + 1; var E, A, T = v + 1, S = a = 0, L = new r; for (A = 0; A < T; A++) { var C = A * b - M; for (E = 0; E < s; E++)L[t] = (E * x - w) * n, L[e] = C * o, L[i] = _, l.push(L.x, L.y, L.z), L[t] = 0, L[e] = 0, L[i] = 0 < m ? 1 : -1, u.push(L.x, L.y, L.z), d.push(E / g), d.push(1 - A / v), a += 1 } for (A = 0; A < v; A++)for (E = 0; E < g; E++)t = p + E + s * (A + 1), e = p + (E + 1) + s * (A + 1), i = p + (E + 1) + s * A, h.push(p + E + s * A, t, i), h.push(t, e, i), S += 6; c.addGroup(f, S, y), f += S, p += a } F.call(this), this.type = "BoxBufferGeometry", this.parameters = { width: t, height: e, depth: i, widthSegments: n, heightSegments: o, depthSegments: a }; var c = this; t = t || 1, e = e || 1, i = i || 1, n = Math.floor(n) || 1, o = Math.floor(o) || 1, a = Math.floor(a) || 1; var h = [], l = [], u = [], d = [], p = 0, f = 0; s("z", "y", "x", -1, -1, i, e, t, a, o, 0), s("z", "y", "x", 1, -1, i, e, -t, a, o, 1), s("x", "z", "y", 1, 1, t, i, e, n, a, 2), s("x", "z", "y", 1, -1, t, i, -e, n, a, 3), s("x", "y", "z", 1, -1, t, e, i, n, o, 4), s("x", "y", "z", -1, -1, t, e, -i, n, o, 5), this.setIndex(h), this.addAttribute("position", new N(l, 3)), this.addAttribute("normal", new N(u, 3)), this.addAttribute("uv", new N(d, 2)) } function k(t, e, i, n) { T.call(this), this.type = "PlaneGeometry", this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n }, this.fromBufferGeometry(new V(t, e, i, n)), this.mergeVertices() } function V(t, e, i, n) { F.call(this), this.type = "PlaneBufferGeometry", this.parameters = { width: t, height: e, widthSegments: i, heightSegments: n }; var r = (t = t || 1) / 2, o = (e = e || 1) / 2, a = (i = Math.floor(i) || 1) + 1, s = (n = Math.floor(n) || 1) + 1, c = t / i, h = e / n, l = [], u = [], d = [], p = []; for (t = 0; t < s; t++) { var f = t * h - o; for (e = 0; e < a; e++)u.push(e * c - r, -f, 0), d.push(0, 0, 1), p.push(e / i), p.push(1 - t / n) } for (t = 0; t < n; t++)for (e = 0; e < i; e++)r = e + a * (t + 1), o = e + 1 + a * (t + 1), s = e + 1 + a * t, l.push(e + a * t, r, s), l.push(r, o, s); this.setIndex(l), this.addAttribute("position", new N(u, 3)), this.addAttribute("normal", new N(d, 3)), this.addAttribute("uv", new N(p, 2)) } function j() { Object.defineProperty(this, "id", { value: To++ }), this.uuid = fo.generateUUID(), this.name = "", this.type = "Material", this.lights = this.fog = !0, this.blending = 1, this.side = 0, this.vertexTangents = this.flatShading = !1, this.vertexColors = 0, this.opacity = 1, this.transparent = !1, this.blendSrc = 204, this.blendDst = 205, this.blendEquation = 100, this.blendEquationAlpha = this.blendDstAlpha = this.blendSrcAlpha = null, this.depthFunc = 3, this.depthWrite = this.depthTest = !0, this.clippingPlanes = null, this.clipShadows = this.clipIntersection = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetUnits = this.polygonOffsetFactor = 0, this.dithering = !1, this.alphaTest = 0, this.premultipliedAlpha = !1, this.visible = !0, this.userData = {}, this.needsUpdate = !0 } function W(t) { j.call(this), this.type = "ShaderMaterial", this.defines = {}, this.uniforms = {}, this.vertexShader = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", this.fragmentShader = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}", this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.clipping = this.lights = this.fog = !1, this.extensions = { derivatives: !1, fragDepth: !1, drawBuffers: !1, shaderTextureLOD: !1 }, this.defaultAttributeValues = { color: [1, 1, 1], uv: [0, 0], uv2: [0, 0] }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, void 0 !== t && (void 0 !== t.attributes && console.error("THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead."), this.setValues(t)) } function q(t, e) { this.origin = void 0 !== t ? t : new r, this.direction = void 0 !== e ? e : new r } function X(t, e, i) { this.a = void 0 !== t ? t : new r, this.b = void 0 !== e ? e : new r, this.c = void 0 !== i ? i : new r } function Y(t) { j.call(this), this.type = "MeshBasicMaterial", this.color = new x(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.lights = this.morphTargets = this.skinning = !1, this.setValues(t) } function Z(t, e) { A.call(this), this.type = "Mesh", this.geometry = void 0 !== t ? t : new F, this.material = void 0 !== e ? e : new Y({ color: 16777215 * Math.random() }), this.drawMode = 0, this.updateMorphTargets() } function J(t, e, i, n) { function r(t, i) { e.buffers.color.setClear(t.r, t.g, t.b, i, n) } var o, a, s = new x(0), c = 0, h = null, l = 0; return { getClearColor: function () { return s }, setClearColor: function (t, e) { s.set(t), r(s, c = void 0 !== e ? e : 1) }, getClearAlpha: function () { return c }, setClearAlpha: function (t) { r(s, c = t) }, render: function (e, n, u, d) { n = n.background, (u = (u = t.vr).getSession && u.getSession()) && "additive" === u.environmentBlendMode && (n = null), null === n ? (r(s, c), h = null, l = 0) : n && n.isColor && (r(n, 1), d = !0, h = null, l = 0), (t.autoClear || d) && t.clear(t.autoClearColor, t.autoClearDepth, t.autoClearStencil), n && (n.isCubeTexture || n.isWebGLRenderTargetCube) ? (void 0 === a && ((a = new Z(new H(1, 1, 1), new W({ type: "BackgroundCubeMaterial", uniforms: v(Mo.cube.uniforms), vertexShader: Mo.cube.vertexShader, fragmentShader: Mo.cube.fragmentShader, side: 1, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), a.geometry.removeAttribute("uv"), a.onBeforeRender = function (t, e, i) { this.matrixWorld.copyPosition(i.matrixWorld) }, Object.defineProperty(a.material, "map", { get: function () { return this.uniforms.tCube.value } }), i.update(a)), d = n.isWebGLRenderTargetCube ? n.texture : n, a.material.uniforms.tCube.value = d, a.material.uniforms.tFlip.value = n.isWebGLRenderTargetCube ? 1 : -1, h === n && l === d.version || (a.material.needsUpdate = !0, h = n, l = d.version), e.unshift(a, a.geometry, a.material, 0, 0, null)) : n && n.isTexture && (void 0 === o && ((o = new Z(new V(2, 2), new W({ type: "BackgroundMaterial", uniforms: v(Mo.background.uniforms), vertexShader: Mo.background.vertexShader, fragmentShader: Mo.background.fragmentShader, side: 0, depthTest: !1, depthWrite: !1, fog: !1 }))).geometry.removeAttribute("normal"), Object.defineProperty(o.material, "map", { get: function () { return this.uniforms.t2D.value } }), i.update(o)), o.material.uniforms.t2D.value = n, !0 === n.matrixAutoUpdate && n.updateMatrix(), o.material.uniforms.uvTransform.value.copy(n.matrix), h === n && l === n.version || (o.material.needsUpdate = !0, h = n, l = n.version), e.unshift(o, o.geometry, o.material, 0, 0, null)) } } } function Q(t, e, i, n) { var r; this.setMode = function (t) { r = t }, this.render = function (e, n) { t.drawArrays(r, e, n), i.update(n, r) }, this.renderInstances = function (o, a, s) { if (n.isWebGL2) var c = t; else if (null === (c = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); c[n.isWebGL2 ? "drawArraysInstanced" : "drawArraysInstancedANGLE"](r, a, s, o.maxInstancedCount), i.update(s, r, o.maxInstancedCount) } } function K(t, e, i) { function n(e) { if ("highp" === e) { if (0 < t.getShaderPrecisionFormat(35633, 36338).precision && 0 < t.getShaderPrecisionFormat(35632, 36338).precision) return "highp"; e = "mediump" } return "mediump" === e && 0 < t.getShaderPrecisionFormat(35633, 36337).precision && 0 < t.getShaderPrecisionFormat(35632, 36337).precision ? "mediump" : "lowp" } var r, o = "undefined" != typeof WebGL2RenderingContext && t instanceof WebGL2RenderingContext, a = void 0 !== i.precision ? i.precision : "highp", s = n(a); s !== a && (console.warn("THREE.WebGLRenderer:", a, "not supported, using", s, "instead."), a = s), i = !0 === i.logarithmicDepthBuffer, s = t.getParameter(34930); var c = t.getParameter(35660), h = t.getParameter(3379), l = t.getParameter(34076), u = t.getParameter(34921), d = t.getParameter(36347), p = t.getParameter(36348), f = t.getParameter(36349), m = 0 < c, g = o || !!e.get("OES_texture_float"); return { isWebGL2: o, getMaxAnisotropy: function () { if (void 0 !== r) return r; var i = e.get("EXT_texture_filter_anisotropic"); return r = null !== i ? t.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0 }, getMaxPrecision: n, precision: a, logarithmicDepthBuffer: i, maxTextures: s, maxVertexTextures: c, maxTextureSize: h, maxCubemapSize: l, maxAttributes: u, maxVertexUniforms: d, maxVaryings: p, maxFragmentUniforms: f, vertexTextures: m, floatFragmentTextures: g, floatVertexTextures: m && g, maxSamples: o ? t.getParameter(36183) : 0 } } function $() { function t() { l.value !== n && (l.value = n, l.needsUpdate = 0 < r), i.numPlanes = r, i.numIntersection = 0 } function e(t, e, n, r) { var o = null !== t ? t.length : 0, a = null; if (0 !== o) { if (a = l.value, !0 !== r || null === a) for (r = n + 4 * o, e = e.matrixWorldInverse, h.getNormalMatrix(e), (null === a || a.length < r) && (a = new Float32Array(r)), r = 0; r !== o; ++r, n += 4)c.copy(t[r]).applyMatrix4(e, h), c.normal.toArray(a, n), a[n + 3] = c.constant; l.value = a, l.needsUpdate = !0 } return i.numPlanes = o, a } var i = this, n = null, r = 0, a = !1, s = !1, c = new f, h = new o, l = { value: null, needsUpdate: !1 }; this.uniform = l, this.numIntersection = this.numPlanes = 0, this.init = function (t, i, o) { var s = 0 !== t.length || i || 0 !== r || a; return a = i, n = e(t, o, 0), r = t.length, s }, this.beginShadows = function () { s = !0, e(null) }, this.endShadows = function () { s = !1, t() }, this.setState = function (i, o, c, h, u, d) { if (!a || null === i || 0 === i.length || s && !c) s ? e(null) : t(); else { var p = 4 * (c = s ? 0 : r), f = u.clippingState || null; for (l.value = f, f = e(i, h, p, d), i = 0; i !== p; ++i)f[i] = n[i]; u.clippingState = f, this.numIntersection = o ? this.numPlanes : 0, this.numPlanes += c } } } function tt(t) { var e = {}; return { get: function (i) { if (void 0 !== e[i]) return e[i]; switch (i) { case "WEBGL_depth_texture": var n = t.getExtension("WEBGL_depth_texture") || t.getExtension("MOZ_WEBGL_depth_texture") || t.getExtension("WEBKIT_WEBGL_depth_texture"); break; case "EXT_texture_filter_anisotropic": n = t.getExtension("EXT_texture_filter_anisotropic") || t.getExtension("MOZ_EXT_texture_filter_anisotropic") || t.getExtension("WEBKIT_EXT_texture_filter_anisotropic"); break; case "WEBGL_compressed_texture_s3tc": n = t.getExtension("WEBGL_compressed_texture_s3tc") || t.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"); break; case "WEBGL_compressed_texture_pvrtc": n = t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"); break; default: n = t.getExtension(i) }return null === n && console.warn("THREE.WebGLRenderer: " + i + " extension not supported."), e[i] = n } } } function et(t, e, i) { function n(t) { var a = t.target; for (var s in null !== (t = r[a.id]).index && e.remove(t.index), t.attributes) e.remove(t.attributes[s]); a.removeEventListener("dispose", n), delete r[a.id], (s = o[t.id]) && (e.remove(s), delete o[t.id]), i.memory.geometries-- } var r = {}, o = {}; return { get: function (t, e) { var o = r[e.id]; return o || (e.addEventListener("dispose", n), e.isBufferGeometry ? o = e : e.isGeometry && (void 0 === e._bufferGeometry && (e._bufferGeometry = (new F).setFromObject(t)), o = e._bufferGeometry), r[e.id] = o, i.memory.geometries++, o) }, update: function (t) { var i = t.index, n = t.attributes; for (var r in null !== i && e.update(i, 34963), n) e.update(n[r], 34962); for (r in t = t.morphAttributes) { n = 0; for (var o = (i = t[r]).length; n < o; n++)e.update(i[n], 34962) } }, getWireframeAttribute: function (t) { var i = o[t.id]; if (i) return i; i = []; var n = t.index, r = t.attributes; if (null !== n) { r = 0; for (var a = (n = n.array).length; r < a; r += 3) { var s = n[r + 0], c = n[r + 1], h = n[r + 2]; i.push(s, c, c, h, h, s) } } else for (n = r.position.array, r = 0, a = n.length / 3 - 1; r < a; r += 3)s = r + 0, c = r + 1, h = r + 2, i.push(s, c, c, h, h, s); return i = new (65535 < U(i) ? D : I)(i, 1), e.update(i, 34963), o[t.id] = i } } } function it(t, e, i, n) { var r, o, a; this.setMode = function (t) { r = t }, this.setIndex = function (t) { o = t.type, a = t.bytesPerElement }, this.render = function (e, n) { t.drawElements(r, n, o, e * a), i.update(n, r) }, this.renderInstances = function (s, c, h) { if (n.isWebGL2) var l = t; else if (null === (l = e.get("ANGLE_instanced_arrays"))) return void console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); l[n.isWebGL2 ? "drawElementsInstanced" : "drawElementsInstancedANGLE"](r, h, o, c * a, s.maxInstancedCount), i.update(h, r, s.maxInstancedCount) } } function nt(t) { var e = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 }; return { memory: { geometries: 0, textures: 0 }, render: e, programs: null, autoReset: !0, reset: function () { e.frame++, e.calls = 0, e.triangles = 0, e.points = 0, e.lines = 0 }, update: function (t, i, n) { switch (n = n || 1, e.calls++, i) { case 4: e.triangles += t / 3 * n; break; case 5: case 6: e.triangles += n * (t - 2); break; case 1: e.lines += t / 2 * n; break; case 3: e.lines += n * (t - 1); break; case 2: e.lines += n * t; break; case 0: e.points += n * t; break; default: console.error("THREE.WebGLInfo: Unknown draw mode:", i) } } } } function rt(t, e) { return Math.abs(e[1]) - Math.abs(t[1]) } function ot(t) { var e = {}, i = new Float32Array(8); return { update: function (n, r, o, a) { var s = n.morphTargetInfluences, c = s.length; if (void 0 === (n = e[r.id])) { n = []; for (var h = 0; h < c; h++)n[h] = [h, 0]; e[r.id] = n } var l = o.morphTargets && r.morphAttributes.position; for (o = o.morphNormals && r.morphAttributes.normal, h = 0; h < c; h++) { var u = n[h]; 0 !== u[1] && (l && r.removeAttribute("morphTarget" + h), o && r.removeAttribute("morphNormal" + h)) } for (h = 0; h < c; h++)(u = n[h])[0] = h, u[1] = s[h]; for (n.sort(rt), h = 0; 8 > h; h++)(u = n[h]) && (s = u[0], c = u[1]) ? (l && r.addAttribute("morphTarget" + h, l[s]), o && r.addAttribute("morphNormal" + h, o[s]), i[h] = c) : i[h] = 0; a.getUniforms().setValue(t, "morphTargetInfluences", i) } } } function at(t, e) { var i = {}; return { update: function (n) { var r = e.render.frame, o = n.geometry, a = t.get(n, o); return i[a.id] !== r && (o.isGeometry && a.updateFromObject(n), t.update(a), i[a.id] = r), a }, dispose: function () { i = {} } } } function st(t, e, i, n, r, o, s, c, h, l) { t = void 0 !== t ? t : [], a.call(this, t, void 0 !== e ? e : 301, i, n, r, o, void 0 !== s ? s : 1022, c, h, l), this.flipY = !1 } function ct(t, e, i, n) { a.call(this, null), this.image = { data: t, width: e, height: i, depth: n }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1 } function ht(t, e, i, n) { a.call(this, null), this.image = { data: t, width: e, height: i, depth: n }, this.minFilter = this.magFilter = 1003, this.wrapR = 1001, this.flipY = this.generateMipmaps = !1 } function lt(t, e, i) { var n = t[0]; if (0 >= n || 0 < n) return t; var r = e * i, o = Po[r]; if (void 0 === o && (o = new Float32Array(r), Po[r] = o), 0 !== e) for (n.toArray(o, 0), n = 1, r = 0; n !== e; ++n)r += i, t[n].toArray(o, r); return o } function ut(t, e) { if (t.length !== e.length) return !1; for (var i = 0, n = t.length; i < n; i++)if (t[i] !== e[i]) return !1; return !0 } function dt(t, e) { for (var i = 0, n = e.length; i < n; i++)t[i] = e[i] } function pt(t, e) { var i = Io[e]; void 0 === i && (i = new Int32Array(e), Io[e] = i); for (var n = 0; n !== e; ++n)i[n] = t.allocateTextureUnit(); return i } function ft(t, e) { var i = this.cache; i[0] !== e && (t.uniform1f(this.addr, e), i[0] = e) } function mt(t, e) { var i = this.cache; void 0 !== e.x ? i[0] === e.x && i[1] === e.y || (t.uniform2f(this.addr, e.x, e.y), i[0] = e.x, i[1] = e.y) : ut(i, e) || (t.uniform2fv(this.addr, e), dt(i, e)) } function gt(t, e) { var i = this.cache; void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z || (t.uniform3f(this.addr, e.x, e.y, e.z), i[0] = e.x, i[1] = e.y, i[2] = e.z) : void 0 !== e.r ? i[0] === e.r && i[1] === e.g && i[2] === e.b || (t.uniform3f(this.addr, e.r, e.g, e.b), i[0] = e.r, i[1] = e.g, i[2] = e.b) : ut(i, e) || (t.uniform3fv(this.addr, e), dt(i, e)) } function vt(t, e) { var i = this.cache; void 0 !== e.x ? i[0] === e.x && i[1] === e.y && i[2] === e.z && i[3] === e.w || (t.uniform4f(this.addr, e.x, e.y, e.z, e.w), i[0] = e.x, i[1] = e.y, i[2] = e.z, i[3] = e.w) : ut(i, e) || (t.uniform4fv(this.addr, e), dt(i, e)) } function yt(t, e) { var i = this.cache, n = e.elements; void 0 === n ? ut(i, e) || (t.uniformMatrix2fv(this.addr, !1, e), dt(i, e)) : ut(i, n) || (No.set(n), t.uniformMatrix2fv(this.addr, !1, No), dt(i, n)) } function xt(t, e) { var i = this.cache, n = e.elements; void 0 === n ? ut(i, e) || (t.uniformMatrix3fv(this.addr, !1, e), dt(i, e)) : ut(i, n) || (Do.set(n), t.uniformMatrix3fv(this.addr, !1, Do), dt(i, n)) } function bt(t, e) { var i = this.cache, n = e.elements; void 0 === n ? ut(i, e) || (t.uniformMatrix4fv(this.addr, !1, e), dt(i, e)) : ut(i, n) || (Oo.set(n), t.uniformMatrix4fv(this.addr, !1, Oo), dt(i, n)) } function wt(t, e, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTexture2D(e || So, r) } function Mt(t, e, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture2DArray(e || Lo, r) } function _t(t, e, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.setTexture3D(e || Co, r) } function Et(t, e, i) { var n = this.cache, r = i.allocateTextureUnit(); n[0] !== r && (t.uniform1i(this.addr, r), n[0] = r), i.safeSetTextureCube(e || Ro, r) } function At(t, e) { var i = this.cache; i[0] !== e && (t.uniform1i(this.addr, e), i[0] = e) } function Tt(t, e) { var i = this.cache; ut(i, e) || (t.uniform2iv(this.addr, e), dt(i, e)) } function St(t, e) { var i = this.cache; ut(i, e) || (t.uniform3iv(this.addr, e), dt(i, e)) } function Lt(t, e) { var i = this.cache; ut(i, e) || (t.uniform4iv(this.addr, e), dt(i, e)) } function Ct(t, e) { t.uniform1fv(this.addr, e) } function Rt(t, e) { t.uniform1iv(this.addr, e) } function Pt(t, e) { t.uniform2iv(this.addr, e) } function It(t, e) { t.uniform3iv(this.addr, e) } function Ot(t, e) { t.uniform4iv(this.addr, e) } function Dt(t, e) { e = lt(e, this.size, 2), t.uniform2fv(this.addr, e) } function Nt(t, e) { e = lt(e, this.size, 3), t.uniform3fv(this.addr, e) } function Bt(t, e) { e = lt(e, this.size, 4), t.uniform4fv(this.addr, e) } function zt(t, e) { e = lt(e, this.size, 4), t.uniformMatrix2fv(this.addr, !1, e) } function Ut(t, e) { e = lt(e, this.size, 9), t.uniformMatrix3fv(this.addr, !1, e) } function Ft(t, e) { e = lt(e, this.size, 16), t.uniformMatrix4fv(this.addr, !1, e) } function Gt(t, e, i) { var n = e.length, r = pt(i, n); for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t)i.safeSetTexture2D(e[t] || So, r[t]) } function Ht(t, e, i) { var n = e.length, r = pt(i, n); for (t.uniform1iv(this.addr, r), t = 0; t !== n; ++t)i.safeSetTextureCube(e[t] || Ro, r[t]) } function kt(t, e, i) { this.id = t, this.addr = i, this.cache = [], this.setValue = function (t) { switch (t) { case 5126: return ft; case 35664: return mt; case 35665: return gt; case 35666: return vt; case 35674: return yt; case 35675: return xt; case 35676: return bt; case 35678: case 36198: return wt; case 35679: return _t; case 35680: return Et; case 36289: return Mt; case 5124: case 35670: return At; case 35667: case 35671: return Tt; case 35668: case 35672: return St; case 35669: case 35673: return Lt } }(e.type) } function Vt(t, e, i) { this.id = t, this.addr = i, this.cache = [], this.size = e.size, this.setValue = function (t) { switch (t) { case 5126: return Ct; case 35664: return Dt; case 35665: return Nt; case 35666: return Bt; case 35674: return zt; case 35675: return Ut; case 35676: return Ft; case 35678: return Gt; case 35680: return Ht; case 5124: case 35670: return Rt; case 35667: case 35671: return Pt; case 35668: case 35672: return It; case 35669: case 35673: return Ot } }(e.type) } function jt(t) { this.id = t, this.seq = [], this.map = {} } function Wt(t, e) { this.seq = [], this.map = {}; for (var i = t.getProgramParameter(e, 35718), n = 0; n < i; ++n) { var r = t.getActiveUniform(e, n), o = t.getUniformLocation(e, r.name), a = this, s = r.name, c = s.length; for (Bo.lastIndex = 0; ;) { var h = Bo.exec(s), l = Bo.lastIndex, u = h[1], d = h[3]; if ("]" === h[2] && (u |= 0), void 0 === d || "[" === d && l + 2 === c) { s = a, r = void 0 === d ? new kt(u, r, o) : new Vt(u, r, o), s.seq.push(r), s.map[r.id] = r; break } void 0 === (d = a.map[u]) && (d = new jt(u), u = a, a = d, u.seq.push(a), u.map[a.id] = a), a = d } } } function qt(t, e, i, n) { var r = t.createShader(e); return t.shaderSource(r, i), t.compileShader(r), !0 === n && (!1 === t.getShaderParameter(r, 35713) && console.error("THREE.WebGLShader: Shader couldn't compile."), "" !== t.getShaderInfoLog(r) && console.warn("THREE.WebGLShader: gl.getShaderInfoLog()", 35633 === e ? "vertex" : "fragment", t.getShaderInfoLog(r), function (t) { t = t.split("\n"); for (var e = 0; e < t.length; e++)t[e] = e + 1 + ": " + t[e]; return t.join("\n") }(i))), r } function Xt(t) { switch (t) { case 3e3: return ["Linear", "( value )"]; case 3001: return ["sRGB", "( value )"]; case 3002: return ["RGBE", "( value )"]; case 3004: return ["RGBM", "( value, 7.0 )"]; case 3005: return ["RGBM", "( value, 16.0 )"]; case 3006: return ["RGBD", "( value, 256.0 )"]; case 3007: return ["Gamma", "( value, float( GAMMA_FACTOR ) )"]; default: throw Error("unsupported encoding: " + t) } } function Yt(t, e) { return "vec4 " + t + "( vec4 value ) { return " + (e = Xt(e))[0] + "ToLinear" + e[1] + "; }" } function Zt(t, e) { return "vec4 " + t + "( vec4 value ) { return LinearTo" + (e = Xt(e))[0] + e[1] + "; }" } function Jt(t, e) { switch (e) { case 1: e = "Linear"; break; case 2: e = "Reinhard"; break; case 3: e = "Uncharted2"; break; case 4: e = "OptimizedCineon"; break; case 5: e = "ACESFilmic"; break; default: throw Error("unsupported toneMapping: " + e) }return "vec3 " + t + "( vec3 color ) { return " + e + "ToneMapping( color ); }" } function Qt(t) { return "" !== t } function Kt(t, e) { return t.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights) } function $t(t, e) { return t.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection) } function te(t) { return t.replace(/^[ \t]*#include +<([\w\d./]+)>/gm, (function (t, e) { if (void 0 === (t = yo[e])) throw Error("Can not resolve #include <" + e + ">"); return te(t) })) } function ee(t) { return t.replace(/#pragma unroll_loop[\s]+?for \( int i = (\d+); i < (\d+); i \+\+ \) \{([\s\S]+?)(?=\})\}/g, (function (t, e, i, n) { for (t = "", e = parseInt(e); e < parseInt(i); e++)t += n.replace(/\[ i \]/g, "[ " + e + " ]"); return t })) } function ie(t, e, i, n, r, o, a, s) { var c = t.context, h = n.defines, l = r.vertexShader, u = r.fragmentShader, d = "SHADOWMAP_TYPE_BASIC"; 1 === o.shadowMapType ? d = "SHADOWMAP_TYPE_PCF" : 2 === o.shadowMapType && (d = "SHADOWMAP_TYPE_PCF_SOFT"); var p = "ENVMAP_TYPE_CUBE", f = "ENVMAP_MODE_REFLECTION", m = "ENVMAP_BLENDING_MULTIPLY"; if (o.envMap) { switch (n.envMap.mapping) { case 301: case 302: p = "ENVMAP_TYPE_CUBE"; break; case 306: case 307: p = "ENVMAP_TYPE_CUBE_UV"; break; case 303: case 304: p = "ENVMAP_TYPE_EQUIREC"; break; case 305: p = "ENVMAP_TYPE_SPHERE" }switch (n.envMap.mapping) { case 302: case 304: f = "ENVMAP_MODE_REFRACTION" }switch (n.combine) { case 0: m = "ENVMAP_BLENDING_MULTIPLY"; break; case 1: m = "ENVMAP_BLENDING_MIX"; break; case 2: m = "ENVMAP_BLENDING_ADD" } } var g, v, y = 0 < t.gammaFactor ? t.gammaFactor : 1, x = a.isWebGL2 ? "" : function (t, e, i) { return [(t = t || {}).derivatives || e.envMapCubeUV || e.bumpMap || e.normalMap && !e.objectSpaceNormalMap || e.flatShading ? "#extension GL_OES_standard_derivatives : enable" : "", (t.fragDepth || e.logarithmicDepthBuffer) && i.get("EXT_frag_depth") ? "#extension GL_EXT_frag_depth : enable" : "", t.drawBuffers && i.get("WEBGL_draw_buffers") ? "#extension GL_EXT_draw_buffers : require" : "", (t.shaderTextureLOD || e.envMap) && i.get("EXT_shader_texture_lod") ? "#extension GL_EXT_shader_texture_lod : enable" : ""].filter(Qt).join("\n") }(n.extensions, o, e), b = function (t) { var e, i = []; for (e in t) { var n = t[e]; !1 !== n && i.push("#define " + e + " " + n) } return i.join("\n") }(h), w = c.createProgram(); return n.isRawShaderMaterial ? (0 < (h = [b].filter(Qt).join("\n")).length && (h += "\n"), 0 < (e = [x, b].filter(Qt).join("\n")).length && (e += "\n")) : (h = ["precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.supportsVertexTextures ? "#define VERTEX_TEXTURES" : "", "#define GAMMA_FACTOR " + y, "#define MAX_BONES " + o.maxBones, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + f : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.displacementMap && o.supportsVertexTextures ? "#define USE_DISPLACEMENTMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.skinning ? "#define USE_SKINNING" : "", o.useVertexTexture ? "#define BONE_TEXTURE" : "", o.morphTargets ? "#define USE_MORPHTARGETS" : "", o.morphNormals && !1 === o.flatShading ? "#define USE_MORPHNORMALS" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_TANGENT", "\tattribute vec4 tangent;", "#endif", "#ifdef USE_COLOR", "\tattribute vec3 color;", "#endif", "#ifdef USE_MORPHTARGETS", "\tattribute vec3 morphTarget0;", "\tattribute vec3 morphTarget1;", "\tattribute vec3 morphTarget2;", "\tattribute vec3 morphTarget3;", "\t#ifdef USE_MORPHNORMALS", "\t\tattribute vec3 morphNormal0;", "\t\tattribute vec3 morphNormal1;", "\t\tattribute vec3 morphNormal2;", "\t\tattribute vec3 morphNormal3;", "\t#else", "\t\tattribute vec3 morphTarget4;", "\t\tattribute vec3 morphTarget5;", "\t\tattribute vec3 morphTarget6;", "\t\tattribute vec3 morphTarget7;", "\t#endif", "#endif", "#ifdef USE_SKINNING", "\tattribute vec4 skinIndex;", "\tattribute vec4 skinWeight;", "#endif", "\n"].filter(Qt).join("\n"), e = [x, "precision " + o.precision + " float;", "precision " + o.precision + " int;", "#define SHADER_NAME " + r.name, b, o.alphaTest ? "#define ALPHATEST " + o.alphaTest + (o.alphaTest % 1 ? "" : ".0") : "", "#define GAMMA_FACTOR " + y, o.useFog && o.fog ? "#define USE_FOG" : "", o.useFog && o.fogExp ? "#define FOG_EXP2" : "", o.map ? "#define USE_MAP" : "", o.matcap ? "#define USE_MATCAP" : "", o.envMap ? "#define USE_ENVMAP" : "", o.envMap ? "#define " + p : "", o.envMap ? "#define " + f : "", o.envMap ? "#define " + m : "", o.lightMap ? "#define USE_LIGHTMAP" : "", o.aoMap ? "#define USE_AOMAP" : "", o.emissiveMap ? "#define USE_EMISSIVEMAP" : "", o.bumpMap ? "#define USE_BUMPMAP" : "", o.normalMap ? "#define USE_NORMALMAP" : "", o.normalMap && o.objectSpaceNormalMap ? "#define OBJECTSPACE_NORMALMAP" : "", o.specularMap ? "#define USE_SPECULARMAP" : "", o.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", o.metalnessMap ? "#define USE_METALNESSMAP" : "", o.alphaMap ? "#define USE_ALPHAMAP" : "", o.vertexTangents ? "#define USE_TANGENT" : "", o.vertexColors ? "#define USE_COLOR" : "", o.gradientMap ? "#define USE_GRADIENTMAP" : "", o.flatShading ? "#define FLAT_SHADED" : "", o.doubleSided ? "#define DOUBLE_SIDED" : "", o.flipSided ? "#define FLIP_SIDED" : "", o.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", o.shadowMapEnabled ? "#define " + d : "", o.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", o.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : "", o.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", o.logarithmicDepthBuffer && (a.isWebGL2 || e.get("EXT_frag_depth")) ? "#define USE_LOGDEPTHBUF_EXT" : "", o.envMap && (a.isWebGL2 || e.get("EXT_shader_texture_lod")) ? "#define TEXTURE_LOD_EXT" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", 0 !== o.toneMapping ? "#define TONE_MAPPING" : "", 0 !== o.toneMapping ? yo.tonemapping_pars_fragment : "", 0 !== o.toneMapping ? Jt("toneMapping", o.toneMapping) : "", o.dithering ? "#define DITHERING" : "", o.outputEncoding || o.mapEncoding || o.matcapEncoding || o.envMapEncoding || o.emissiveMapEncoding ? yo.encodings_pars_fragment : "", o.mapEncoding ? Yt("mapTexelToLinear", o.mapEncoding) : "", o.matcapEncoding ? Yt("matcapTexelToLinear", o.matcapEncoding) : "", o.envMapEncoding ? Yt("envMapTexelToLinear", o.envMapEncoding) : "", o.emissiveMapEncoding ? Yt("emissiveMapTexelToLinear", o.emissiveMapEncoding) : "", o.outputEncoding ? Zt("linearToOutputTexel", o.outputEncoding) : "", o.depthPacking ? "#define DEPTH_PACKING " + n.depthPacking : "", "\n"].filter(Qt).join("\n")), l = $t(l = Kt(l = te(l), o), o), u = $t(u = Kt(u = te(u), o), o), l = ee(l), u = ee(u), a.isWebGL2 && !n.isRawShaderMaterial && (a = !1, d = /^\s*#version\s+300\s+es\s*\n/, n.isShaderMaterial && null !== l.match(d) && null !== u.match(d) && (a = !0, l = l.replace(d, ""), u = u.replace(d, "")), h = "#version 300 es\n\n#define attribute in\n#define varying out\n#define texture2D texture\n" + h, e = ["#version 300 es\n\n#define varying in", a ? "" : "out highp vec4 pc_fragColor;", a ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n") + "\n" + e), u = e + u, l = qt(c, 35633, h + l, t.debug.checkShaderErrors), u = qt(c, 35632, u, t.debug.checkShaderErrors), c.attachShader(w, l), c.attachShader(w, u), void 0 !== n.index0AttributeName ? c.bindAttribLocation(w, 0, n.index0AttributeName) : !0 === o.morphTargets && c.bindAttribLocation(w, 0, "position"), c.linkProgram(w), t.debug.checkShaderErrors && (t = c.getProgramInfoLog(w).trim(), o = c.getShaderInfoLog(l).trim(), a = c.getShaderInfoLog(u).trim(), p = d = !0, !1 === c.getProgramParameter(w, 35714) ? (d = !1, console.error("THREE.WebGLProgram: shader error: ", c.getError(), "35715", c.getProgramParameter(w, 35715), "gl.getProgramInfoLog", t, o, a)) : "" !== t ? console.warn("THREE.WebGLProgram: gl.getProgramInfoLog()", t) : "" !== o && "" !== a || (p = !1), p && (this.diagnostics = { runnable: d, material: n, programLog: t, vertexShader: { log: o, prefix: h }, fragmentShader: { log: a, prefix: e } })), c.deleteShader(l), c.deleteShader(u), this.getUniforms = function () { return void 0 === g && (g = new Wt(c, w, s)), g }, this.getAttributes = function () { if (void 0 === v) { for (var t = {}, e = c.getProgramParameter(w, 35721), i = 0; i < e; i++) { var n = c.getActiveAttrib(w, i).name; t[n] = c.getAttribLocation(w, n) } v = t } return v }, this.destroy = function () { c.deleteProgram(w), this.program = void 0 }, Object.defineProperties(this, { uniforms: { get: function () { return console.warn("THREE.WebGLProgram: .uniforms is now .getUniforms()."), this.getUniforms() } }, attributes: { get: function () { return console.warn("THREE.WebGLProgram: .attributes is now .getAttributes()."), this.getAttributes() } } }), this.name = r.name, this.id = zo++, this.code = i, this.usedTimes = 1, this.program = w, this.vertexShader = l, this.fragmentShader = u, this } function ne(t, e, i, n) { function r(t, e) { if (t) t.isTexture ? i = t.encoding : t.isWebGLRenderTarget && (console.warn("THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead."), i = t.texture.encoding); else var i = 3e3; return 3e3 === i && e && (i = 3007), i } var o = [], a = { MeshDepthMaterial: "depth", MeshDistanceMaterial: "distanceRGBA", MeshNormalMaterial: "normal", MeshBasicMaterial: "basic", MeshLambertMaterial: "lambert", MeshPhongMaterial: "phong", MeshToonMaterial: "phong", MeshStandardMaterial: "physical", MeshPhysicalMaterial: "physical", MeshMatcapMaterial: "matcap", LineBasicMaterial: "basic", LineDashedMaterial: "dashed", PointsMaterial: "points", ShadowMaterial: "shadow", SpriteMaterial: "sprite" }, s = "precision supportsVertexTextures map mapEncoding matcap matcapEncoding envMap envMapMode envMapEncoding lightMap aoMap emissiveMap emissiveMapEncoding bumpMap normalMap objectSpaceNormalMap displacementMap specularMap roughnessMap metalnessMap gradientMap alphaMap combine vertexColors vertexTangents fog useFog fogExp flatShading sizeAttenuation logarithmicDepthBuffer skinning maxBones useVertexTexture morphTargets morphNormals maxMorphTargets maxMorphNormals premultipliedAlpha numDirLights numPointLights numSpotLights numHemiLights numRectAreaLights shadowMapEnabled shadowMapType toneMapping physicallyCorrectLights alphaTest doubleSided flipSided numClippingPlanes numClipIntersection depthPacking dithering".split(" "); this.getParameters = function (e, n, o, s, c, h, l) { var u = a[e.type]; if (l.isSkinnedMesh) { var d = l.skeleton.bones; if (i.floatVertexTextures) d = 1024; else { var p = Math.min(Math.floor((i.maxVertexUniforms - 20) / 4), d.length); p < d.length ? (console.warn("THREE.WebGLRenderer: Skeleton has " + d.length + " bones. This GPU supports " + p + "."), d = 0) : d = p } } else d = 0; p = i.precision, null !== e.precision && ((p = i.getMaxPrecision(e.precision)) !== e.precision && console.warn("THREE.WebGLProgram.getParameters:", e.precision, "not supported, using", p, "instead.")); var f = t.getRenderTarget(); return { shaderID: u, precision: p, supportsVertexTextures: i.vertexTextures, outputEncoding: r(f ? f.texture : null, t.gammaOutput), map: !!e.map, mapEncoding: r(e.map, t.gammaInput), matcap: !!e.matcap, matcapEncoding: r(e.matcap, t.gammaInput), envMap: !!e.envMap, envMapMode: e.envMap && e.envMap.mapping, envMapEncoding: r(e.envMap, t.gammaInput), envMapCubeUV: !!e.envMap && (306 === e.envMap.mapping || 307 === e.envMap.mapping), lightMap: !!e.lightMap, aoMap: !!e.aoMap, emissiveMap: !!e.emissiveMap, emissiveMapEncoding: r(e.emissiveMap, t.gammaInput), bumpMap: !!e.bumpMap, normalMap: !!e.normalMap, objectSpaceNormalMap: 1 === e.normalMapType, displacementMap: !!e.displacementMap, roughnessMap: !!e.roughnessMap, metalnessMap: !!e.metalnessMap, specularMap: !!e.specularMap, alphaMap: !!e.alphaMap, gradientMap: !!e.gradientMap, combine: e.combine, vertexTangents: e.normalMap && e.vertexTangents, vertexColors: e.vertexColors, fog: !!s, useFog: e.fog, fogExp: s && s.isFogExp2, flatShading: e.flatShading, sizeAttenuation: e.sizeAttenuation, logarithmicDepthBuffer: i.logarithmicDepthBuffer, skinning: e.skinning && 0 < d, maxBones: d, useVertexTexture: i.floatVertexTextures, morphTargets: e.morphTargets, morphNormals: e.morphNormals, maxMorphTargets: t.maxMorphTargets, maxMorphNormals: t.maxMorphNormals, numDirLights: n.directional.length, numPointLights: n.point.length, numSpotLights: n.spot.length, numRectAreaLights: n.rectArea.length, numHemiLights: n.hemi.length, numClippingPlanes: c, numClipIntersection: h, dithering: e.dithering, shadowMapEnabled: t.shadowMap.enabled && l.receiveShadow && 0 < o.length, shadowMapType: t.shadowMap.type, toneMapping: t.toneMapping, physicallyCorrectLights: t.physicallyCorrectLights, premultipliedAlpha: e.premultipliedAlpha, alphaTest: e.alphaTest, doubleSided: 2 === e.side, flipSided: 1 === e.side, depthPacking: void 0 !== e.depthPacking && e.depthPacking } }, this.getProgramCode = function (e, i) { var n = []; if (i.shaderID ? n.push(i.shaderID) : (n.push(e.fragmentShader), n.push(e.vertexShader)), void 0 !== e.defines) for (var r in e.defines) n.push(r), n.push(e.defines[r]); for (r = 0; r < s.length; r++)n.push(i[s[r]]); return n.push(e.onBeforeCompile.toString()), n.push(t.gammaOutput), n.push(t.gammaFactor), n.join() }, this.acquireProgram = function (r, a, s, c) { for (var h, l = 0, u = o.length; l < u; l++) { var d = o[l]; if (d.code === c) { ++(h = d).usedTimes; break } } return void 0 === h && (h = new ie(t, e, c, r, a, s, i, n), o.push(h)), h }, this.releaseProgram = function (t) { if (0 == --t.usedTimes) { var e = o.indexOf(t); o[e] = o[o.length - 1], o.pop(), t.destroy() } }, this.programs = o } function re() { var t = new WeakMap; return { get: function (e) { var i = t.get(e); return void 0 === i && (i = {}, t.set(e, i)), i }, remove: function (e) { t.delete(e) }, update: function (e, i, n) { t.get(e)[i] = n }, dispose: function () { t = new WeakMap } } } function oe(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.program !== e.program ? t.program.id - e.program.id : t.material.id !== e.material.id ? t.material.id - e.material.id : t.z !== e.z ? t.z - e.z : t.id - e.id } function ae(t, e) { return t.groupOrder !== e.groupOrder ? t.groupOrder - e.groupOrder : t.renderOrder !== e.renderOrder ? t.renderOrder - e.renderOrder : t.z !== e.z ? e.z - t.z : t.id - e.id } function se() { function t(t, n, r, a, s, c) { var h = e[i]; return void 0 === h ? (h = { id: t.id, object: t, geometry: n, material: r, program: r.program || o, groupOrder: a, renderOrder: t.renderOrder, z: s, group: c }, e[i] = h) : (h.id = t.id, h.object = t, h.geometry = n, h.material = r, h.program = r.program || o, h.groupOrder = a, h.renderOrder = t.renderOrder, h.z = s, h.group = c), i++, h } var e = [], i = 0, n = [], r = [], o = { id: -1 }; return { opaque: n, transparent: r, init: function () { i = 0, n.length = 0, r.length = 0 }, push: function (e, i, o, a, s, c) { e = t(e, i, o, a, s, c), (!0 === o.transparent ? r : n).push(e) }, unshift: function (e, i, o, a, s, c) { e = t(e, i, o, a, s, c), (!0 === o.transparent ? r : n).unshift(e) }, sort: function () { 1 < n.length && n.sort(oe), 1 < r.length && r.sort(ae) } } } function ce() { function t(i) { (i = i.target).removeEventListener("dispose", t), delete e[i.id] } var e = {}; return { get: function (i, n) { var r = e[i.id]; if (void 0 === r) { var o = new se; e[i.id] = {}, e[i.id][n.id] = o, i.addEventListener("dispose", t) } else void 0 === (o = r[n.id]) && (o = new se, r[n.id] = o); return o }, dispose: function () { e = {} } } } function he() { var t = {}; return { get: function (e) { if (void 0 !== t[e.id]) return t[e.id]; switch (e.type) { case "DirectionalLight": var n = { direction: new r, color: new x, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new i }; break; case "SpotLight": n = { position: new r, direction: new r, color: new x, distance: 0, coneCos: 0, penumbraCos: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new i }; break; case "PointLight": n = { position: new r, color: new x, distance: 0, decay: 0, shadow: !1, shadowBias: 0, shadowRadius: 1, shadowMapSize: new i, shadowCameraNear: 1, shadowCameraFar: 1e3 }; break; case "HemisphereLight": n = { direction: new r, skyColor: new x, groundColor: new x }; break; case "RectAreaLight": n = { color: new x, position: new r, halfWidth: new r, halfHeight: new r } }return t[e.id] = n } } } function le() { for (var t = new he, e = { id: Uo++, hash: { stateID: -1, directionalLength: -1, pointLength: -1, spotLength: -1, rectAreaLength: -1, hemiLength: -1, shadowsLength: -1 }, ambient: [0, 0, 0], probe: [], directional: [], directionalShadowMap: [], directionalShadowMatrix: [], spot: [], spotShadowMap: [], spotShadowMatrix: [], rectArea: [], point: [], pointShadowMap: [], pointShadowMatrix: [], hemi: [] }, i = 0; 9 > i; i++)e.probe.push(new r); var n = new r, o = new g, a = new g; return { setup: function (i, r, s) { for (var c = 0, h = 0, l = 0, u = 0; 9 > u; u++)e.probe[u].set(0, 0, 0); var d = 0, p = 0, f = 0, m = 0, g = 0; s = s.matrixWorldInverse, u = 0; for (var v = i.length; u < v; u++) { var y = i[u], x = y.color, b = y.intensity, w = y.distance, M = y.shadow && y.shadow.map ? y.shadow.map.texture : null; if (y.isAmbientLight) c += x.r * b, h += x.g * b, l += x.b * b; else if (y.isLightProbe) for (M = 0; 9 > M; M++)e.probe[M].addScaledVector(y.sh.coefficients[M], b); else if (y.isDirectionalLight) { var _ = t.get(y); _.color.copy(y.color).multiplyScalar(y.intensity), _.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), _.direction.sub(n), _.direction.transformDirection(s), (_.shadow = y.castShadow) && (b = y.shadow, _.shadowBias = b.bias, _.shadowRadius = b.radius, _.shadowMapSize = b.mapSize), e.directionalShadowMap[d] = M, e.directionalShadowMatrix[d] = y.shadow.matrix, e.directional[d] = _, d++ } else y.isSpotLight ? ((_ = t.get(y)).position.setFromMatrixPosition(y.matrixWorld), _.position.applyMatrix4(s), _.color.copy(x).multiplyScalar(b), _.distance = w, _.direction.setFromMatrixPosition(y.matrixWorld), n.setFromMatrixPosition(y.target.matrixWorld), _.direction.sub(n), _.direction.transformDirection(s), _.coneCos = Math.cos(y.angle), _.penumbraCos = Math.cos(y.angle * (1 - y.penumbra)), _.decay = y.decay, (_.shadow = y.castShadow) && (b = y.shadow, _.shadowBias = b.bias, _.shadowRadius = b.radius, _.shadowMapSize = b.mapSize), e.spotShadowMap[f] = M, e.spotShadowMatrix[f] = y.shadow.matrix, e.spot[f] = _, f++) : y.isRectAreaLight ? ((_ = t.get(y)).color.copy(x).multiplyScalar(b), _.position.setFromMatrixPosition(y.matrixWorld), _.position.applyMatrix4(s), a.identity(), o.copy(y.matrixWorld), o.premultiply(s), a.extractRotation(o), _.halfWidth.set(.5 * y.width, 0, 0), _.halfHeight.set(0, .5 * y.height, 0), _.halfWidth.applyMatrix4(a), _.halfHeight.applyMatrix4(a), e.rectArea[m] = _, m++) : y.isPointLight ? ((_ = t.get(y)).position.setFromMatrixPosition(y.matrixWorld), _.position.applyMatrix4(s), _.color.copy(y.color).multiplyScalar(y.intensity), _.distance = y.distance, _.decay = y.decay, (_.shadow = y.castShadow) && (b = y.shadow, _.shadowBias = b.bias, _.shadowRadius = b.radius, _.shadowMapSize = b.mapSize, _.shadowCameraNear = b.camera.near, _.shadowCameraFar = b.camera.far), e.pointShadowMap[p] = M, e.pointShadowMatrix[p] = y.shadow.matrix, e.point[p] = _, p++) : y.isHemisphereLight && ((_ = t.get(y)).direction.setFromMatrixPosition(y.matrixWorld), _.direction.transformDirection(s), _.direction.normalize(), _.skyColor.copy(y.color).multiplyScalar(b), _.groundColor.copy(y.groundColor).multiplyScalar(b), e.hemi[g] = _, g++) } e.ambient[0] = c, e.ambient[1] = h, e.ambient[2] = l, e.directional.length = d, e.spot.length = f, e.rectArea.length = m, e.point.length = p, e.hemi.length = g, e.hash.stateID = e.id, e.hash.directionalLength = d, e.hash.pointLength = p, e.hash.spotLength = f, e.hash.rectAreaLength = m, e.hash.hemiLength = g, e.hash.shadowsLength = r.length }, state: e } } function ue() { var t = new le, e = [], i = []; return { init: function () { e.length = 0, i.length = 0 }, state: { lightsArray: e, shadowsArray: i, lights: t }, setupLights: function (n) { t.setup(e, i, n) }, pushLight: function (t) { e.push(t) }, pushShadow: function (t) { i.push(t) } } } function de() { function t(i) { (i = i.target).removeEventListener("dispose", t), delete e[i.id] } var e = {}; return { get: function (i, n) { if (void 0 === e[i.id]) { var r = new ue; e[i.id] = {}, e[i.id][n.id] = r, i.addEventListener("dispose", t) } else void 0 === e[i.id][n.id] ? (r = new ue, e[i.id][n.id] = r) : r = e[i.id][n.id]; return r }, dispose: function () { e = {} } } } function pe(t) { j.call(this), this.type = "MeshDepthMaterial", this.depthPacking = 3200, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.lights = this.fog = !1, this.setValues(t) } function fe(t) { j.call(this), this.type = "MeshDistanceMaterial", this.referencePosition = new r, this.nearDistance = 1, this.farDistance = 1e3, this.morphTargets = this.skinning = !1, this.displacementMap = this.alphaMap = this.map = null, this.displacementScale = 1, this.displacementBias = 0, this.lights = this.fog = !1, this.setValues(t) } function me(t, e, n) { function o(e, i, n, r, o, a) { var s = e.geometry, c = v, h = e.customDepthMaterial; return n && (c = y, h = e.customDistanceMaterial), h ? c = h : (h = !1, i.morphTargets && (s && s.isBufferGeometry ? h = s.morphAttributes && s.morphAttributes.position && 0 < s.morphAttributes.position.length : s && s.isGeometry && (h = s.morphTargets && 0 < s.morphTargets.length)), e.isSkinnedMesh && !1 === i.skinning && console.warn("THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:", e), s = 0, h && (s |= 1), (e = e.isSkinnedMesh && i.skinning) && (s |= 2), c = c[s]), t.localClippingEnabled && !0 === i.clipShadows && 0 !== i.clippingPlanes.length && (s = c.uuid, h = i.uuid, void 0 === (e = x[s]) && (e = {}, x[s] = e), void 0 === (s = e[h]) && (s = c.clone(), e[h] = s), c = s), c.visible = i.visible, c.wireframe = i.wireframe, c.side = null != i.shadowSide ? i.shadowSide : b[i.side], c.clipShadows = i.clipShadows, c.clippingPlanes = i.clippingPlanes, c.clipIntersection = i.clipIntersection, c.wireframeLinewidth = i.wireframeLinewidth, c.linewidth = i.linewidth, n && c.isMeshDistanceMaterial && (c.referencePosition.copy(r), c.nearDistance = o, c.farDistance = a), c } function a(i, n, r, s) { if (!1 !== i.visible) { if (i.layers.test(n.layers) && (i.isMesh || i.isLine || i.isPoints) && i.castShadow && (!i.frustumCulled || h.intersectsObject(i))) { i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld); var c = e.update(i), l = i.material; if (Array.isArray(l)) for (var u = c.groups, d = 0, p = u.length; d < p; d++) { var m = u[d], g = l[m.materialIndex]; g && g.visible && (g = o(i, g, s, f, r.near, r.far), t.renderBufferDirect(r, null, c, g, i, m)) } else l.visible && (g = o(i, l, s, f, r.near, r.far), t.renderBufferDirect(r, null, c, g, i, null)) } for (c = 0, l = (i = i.children).length; c < l; c++)a(i[c], n, r, s) } } var h = new m, l = new g, u = new i, d = new i(n, n), p = new r, f = new r, v = Array(4), y = Array(4), x = {}, b = { 0: 1, 1: 0, 2: 2 }, w = [new r(1, 0, 0), new r(-1, 0, 0), new r(0, 0, 1), new r(0, 0, -1), new r(0, 1, 0), new r(0, -1, 0)], M = [new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 1, 0), new r(0, 0, 1), new r(0, 0, -1)], _ = [new s, new s, new s, new s, new s, new s]; for (n = 0; 4 !== n; ++n) { var E = 0 != (1 & n), A = 0 != (2 & n), T = new pe({ depthPacking: 3201, morphTargets: E, skinning: A }); v[n] = T, E = new fe({ morphTargets: E, skinning: A }), y[n] = E } var S = this; this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = 1, this.render = function (e, i, n) { if (!1 !== S.enabled && (!1 !== S.autoUpdate || !1 !== S.needsUpdate) && 0 !== e.length) { var r = t.getRenderTarget(), o = t.getActiveCubeFace(), s = t.getActiveMipMapLevel(), m = t.state; m.setBlending(0), m.buffers.color.setClear(1, 1, 1, 1), m.buffers.depth.setTest(!0), m.setScissorTest(!1); for (var g, v = 0, y = e.length; v < y; v++) { var x = e[v]; g = x.shadow; var b = x && x.isPointLight; if (void 0 === g) console.warn("THREE.WebGLShadowMap:", x, "has no shadow."); else { var E = g.camera; if (u.copy(g.mapSize), u.min(d), b) { var A = u.x, T = u.y; _[0].set(2 * A, T, A, T), _[1].set(0, T, A, T), _[2].set(3 * A, T, A, T), _[3].set(A, T, A, T), _[4].set(3 * A, 0, A, T), _[5].set(A, 0, A, T), u.x *= 4, u.y *= 2 } for (null === g.map && (g.map = new c(u.x, u.y, { minFilter: 1003, magFilter: 1003, format: 1023 }), g.map.texture.name = x.name + ".shadowMap", E.updateProjectionMatrix()), g.isSpotLightShadow && g.update(x), A = g.map, T = g.matrix, f.setFromMatrixPosition(x.matrixWorld), E.position.copy(f), b ? (g = 6, T.makeTranslation(-f.x, -f.y, -f.z)) : (g = 1, p.setFromMatrixPosition(x.target.matrixWorld), E.lookAt(p), E.updateMatrixWorld(), T.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), T.multiply(E.projectionMatrix), T.multiply(E.matrixWorldInverse)), t.setRenderTarget(A), t.clear(), x = 0; x < g; x++)b && (p.copy(E.position), p.add(w[x]), E.up.copy(M[x]), E.lookAt(p), E.updateMatrixWorld(), m.viewport(_[x])), l.multiplyMatrices(E.projectionMatrix, E.matrixWorldInverse), h.setFromMatrix(l), a(i, n, E, b) } } S.needsUpdate = !1, t.setRenderTarget(r, o, s) } } } function ge(t, e, i, n) { function r(e, i, n) { var r = new Uint8Array(4), o = t.createTexture(); for (t.bindTexture(e, o), t.texParameteri(e, 10241, 9728), t.texParameteri(e, 10240, 9728), e = 0; e < n; e++)t.texImage2D(i + e, 0, 6408, 1, 1, 0, 6408, 5121, r); return o } function o(i, r) { y[i] = 1, 0 === x[i] && (t.enableVertexAttribArray(i), x[i] = 1), b[i] !== r && ((n.isWebGL2 ? t : e.get("ANGLE_instanced_arrays"))[n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"](i, r), b[i] = r) } function a(e) { !0 !== w[e] && (t.enable(e), w[e] = !0) } function c(e) { !1 !== w[e] && (t.disable(e), w[e] = !1) } function h(e, n, r, o, s, h, l, u) { if (0 === e) E && (c(3042), E = !1); else if (E || (a(3042), E = !0), 5 !== e) { if (e !== A || u !== I) { if (100 === T && 100 === C || (t.blendEquation(32774), C = T = 100), u) switch (e) { case 1: t.blendFuncSeparate(1, 771, 1, 771); break; case 2: t.blendFunc(1, 1); break; case 3: t.blendFuncSeparate(0, 0, 769, 771); break; case 4: t.blendFuncSeparate(0, 768, 0, 770); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) } else switch (e) { case 1: t.blendFuncSeparate(770, 771, 1, 771); break; case 2: t.blendFunc(770, 1); break; case 3: t.blendFunc(0, 769); break; case 4: t.blendFunc(0, 768); break; default: console.error("THREE.WebGLState: Invalid blending: ", e) }P = R = L = S = null, A = e, I = u } } else s = s || n, h = h || r, l = l || o, n === T && s === C || (t.blendEquationSeparate(i.convert(n), i.convert(s)), T = n, C = s), r === S && o === L && h === R && l === P || (t.blendFuncSeparate(i.convert(r), i.convert(o), i.convert(h), i.convert(l)), S = r, L = o, R = h, P = l), A = e, I = null } function l(e) { O !== e && (e ? t.frontFace(2304) : t.frontFace(2305), O = e) } function u(e) { 0 !== e ? (a(2884), e !== D && (1 === e ? t.cullFace(1029) : 2 === e ? t.cullFace(1028) : t.cullFace(1032))) : c(2884), D = e } function d(e, i, n) { e ? (a(32823), (B !== i || z !== n) && (t.polygonOffset(i, n), B = i, z = n)) : c(32823) } function p(e) { void 0 === e && (e = 33984 + U - 1), G !== e && (t.activeTexture(e), G = e) } var f = new function () { var e = !1, i = new s, n = null, r = new s(0, 0, 0, 0); return { setMask: function (i) { n === i || e || (t.colorMask(i, i, i, i), n = i) }, setLocked: function (t) { e = t }, setClear: function (e, n, o, a, s) { !0 === s && (e *= a, n *= a, o *= a), i.set(e, n, o, a), !1 === r.equals(i) && (t.clearColor(e, n, o, a), r.copy(i)) }, reset: function () { e = !1, n = null, r.set(-1, 0, 0, 0) } } }, m = new function () { var e = !1, i = null, n = null, r = null; return { setTest: function (t) { t ? a(2929) : c(2929) }, setMask: function (n) { i === n || e || (t.depthMask(n), i = n) }, setFunc: function (e) { if (n !== e) { if (e) switch (e) { case 0: t.depthFunc(512); break; case 1: t.depthFunc(519); break; case 2: t.depthFunc(513); break; case 3: default: t.depthFunc(515); break; case 4: t.depthFunc(514); break; case 5: t.depthFunc(518); break; case 6: t.depthFunc(516); break; case 7: t.depthFunc(517) } else t.depthFunc(515); n = e } }, setLocked: function (t) { e = t }, setClear: function (e) { r !== e && (t.clearDepth(e), r = e) }, reset: function () { e = !1, r = n = i = null } } }, g = new function () { var e = !1, i = null, n = null, r = null, o = null, s = null, h = null, l = null, u = null; return { setTest: function (t) { t ? a(2960) : c(2960) }, setMask: function (n) { i === n || e || (t.stencilMask(n), i = n) }, setFunc: function (e, i, a) { n === e && r === i && o === a || (t.stencilFunc(e, i, a), n = e, r = i, o = a) }, setOp: function (e, i, n) { s === e && h === i && l === n || (t.stencilOp(e, i, n), s = e, h = i, l = n) }, setLocked: function (t) { e = t }, setClear: function (e) { u !== e && (t.clearStencil(e), u = e) }, reset: function () { e = !1, u = l = h = s = o = r = n = i = null } } }, v = t.getParameter(34921), y = new Uint8Array(v), x = new Uint8Array(v), b = new Uint8Array(v), w = {}, M = null, _ = null, E = null, A = null, T = null, S = null, L = null, C = null, R = null, P = null, I = !1, O = null, D = null, N = null, B = null, z = null, U = t.getParameter(35661), F = !1; v = 0, -1 !== (v = t.getParameter(7938)).indexOf("WebGL") ? (v = parseFloat(/^WebGL ([0-9])/.exec(v)[1]), F = 1 <= v) : -1 !== v.indexOf("OpenGL ES") && (v = parseFloat(/^OpenGL ES ([0-9])/.exec(v)[1]), F = 2 <= v); var G = null, H = {}, k = new s, V = new s, j = {}; return j[3553] = r(3553, 3553, 1), j[34067] = r(34067, 34069, 6), f.setClear(0, 0, 0, 1), m.setClear(1), g.setClear(0), a(2929), m.setFunc(3), l(!1), u(1), a(2884), h(0), { buffers: { color: f, depth: m, stencil: g }, initAttributes: function () { for (var t = 0, e = y.length; t < e; t++)y[t] = 0 }, enableAttribute: function (t) { o(t, 0) }, enableAttributeAndDivisor: o, disableUnusedAttributes: function () { for (var e = 0, i = x.length; e !== i; ++e)x[e] !== y[e] && (t.disableVertexAttribArray(e), x[e] = 0) }, enable: a, disable: c, getCompressedTextureFormats: function () { if (null === M && (M = [], e.get("WEBGL_compressed_texture_pvrtc") || e.get("WEBGL_compressed_texture_s3tc") || e.get("WEBGL_compressed_texture_etc1") || e.get("WEBGL_compressed_texture_astc"))) for (var i = t.getParameter(34467), n = 0; n < i.length; n++)M.push(i[n]); return M }, useProgram: function (e) { return _ !== e && (t.useProgram(e), _ = e, !0) }, setBlending: h, setMaterial: function (t, e) { 2 === t.side ? c(2884) : a(2884); var i = 1 === t.side; e && (i = !i), l(i), 1 === t.blending && !1 === t.transparent ? h(0) : h(t.blending, t.blendEquation, t.blendSrc, t.blendDst, t.blendEquationAlpha, t.blendSrcAlpha, t.blendDstAlpha, t.premultipliedAlpha), m.setFunc(t.depthFunc), m.setTest(t.depthTest), m.setMask(t.depthWrite), f.setMask(t.colorWrite), d(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits) }, setFlipSided: l, setCullFace: u, setLineWidth: function (e) { e !== N && (F && t.lineWidth(e), N = e) }, setPolygonOffset: d, setScissorTest: function (t) { t ? a(3089) : c(3089) }, activeTexture: p, bindTexture: function (e, i) { null === G && p(); var n = H[G]; void 0 === n && (n = { type: void 0, texture: void 0 }, H[G] = n), n.type === e && n.texture === i || (t.bindTexture(e, i || j[e]), n.type = e, n.texture = i) }, compressedTexImage2D: function () { try { t.compressedTexImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage2D: function () { try { t.texImage2D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, texImage3D: function () { try { t.texImage3D.apply(t, arguments) } catch (t) { console.error("THREE.WebGLState:", t) } }, scissor: function (e) { !1 === k.equals(e) && (t.scissor(e.x, e.y, e.z, e.w), k.copy(e)) }, viewport: function (e) { !1 === V.equals(e) && (t.viewport(e.x, e.y, e.z, e.w), V.copy(e)) }, reset: function () { for (var e = 0; e < x.length; e++)1 === x[e] && (t.disableVertexAttribArray(e), x[e] = 0); w = {}, G = M = null, H = {}, D = O = A = _ = null, f.reset(), m.reset(), g.reset() } } } function ve(t, e, i, n, r, o, a) { function s(t, e) { return S ? new OffscreenCanvas(t, e) : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas") } function c(t, e, i, n) { var r = 1; if ((t.width > n || t.height > n) && (r = n / Math.max(t.width, t.height)), 1 > r || !0 === e) { if ("undefined" != typeof HTMLImageElement && t instanceof HTMLImageElement || "undefined" != typeof HTMLCanvasElement && t instanceof HTMLCanvasElement || "undefined" != typeof ImageBitmap && t instanceof ImageBitmap) return e = (n = e ? fo.floorPowerOfTwo : Math.floor)(r * t.width), r = n(r * t.height), void 0 === A && (A = s(e, r)), (i = i ? s(e, r) : A).width = e, i.height = r, i.getContext("2d").drawImage(t, 0, 0, e, r), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + t.width + "x" + t.height + ") to (" + e + "x" + r + ")."), i; "data" in t && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + t.width + "x" + t.height + ").") } return t } function h(t) { return fo.isPowerOfTwo(t.width) && fo.isPowerOfTwo(t.height) } function l(t, e) { return t.generateMipmaps && e && 1003 !== t.minFilter && 1006 !== t.minFilter } function u(e, i, r, o) { t.generateMipmap(e), n.get(i).__maxMipLevel = Math.log(Math.max(r, o)) * Math.LOG2E } function d(t, i) { if (!r.isWebGL2) return t; var n = t; return 6403 === t && (5126 === i && (n = 33326), 5131 === i && (n = 33325), 5121 === i && (n = 33321)), 6407 === t && (5126 === i && (n = 34837), 5131 === i && (n = 34843), 5121 === i && (n = 32849)), 6408 === t && (5126 === i && (n = 34836), 5131 === i && (n = 34842), 5121 === i && (n = 32856)), 33325 === n || 33326 === n || 34842 === n || 34836 === n ? e.get("EXT_color_buffer_float") : (34843 === n || 34837 === n) && console.warn("THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead."), n } function p(t) { return 1003 === t || 1004 === t || 1005 === t ? 9728 : 9729 } function f(e) { (e = e.target).removeEventListener("dispose", f); var i = n.get(e); void 0 !== i.__webglInit && (t.deleteTexture(i.__webglTexture), n.remove(e)), e.isVideoTexture && delete T[e.id], a.memory.textures-- } function m(e) { (e = e.target).removeEventListener("dispose", m); var i = n.get(e), r = n.get(e.texture); if (e) { if (void 0 !== r.__webglTexture && t.deleteTexture(r.__webglTexture), e.depthTexture && e.depthTexture.dispose(), e.isWebGLRenderTargetCube) for (r = 0; 6 > r; r++)t.deleteFramebuffer(i.__webglFramebuffer[r]), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer[r]); else t.deleteFramebuffer(i.__webglFramebuffer), i.__webglDepthbuffer && t.deleteRenderbuffer(i.__webglDepthbuffer); n.remove(e.texture), n.remove(e) } a.memory.textures-- } function g(t, e) { var r = n.get(t); if (t.isVideoTexture) { var o = t.id, s = a.render.frame; T[o] !== s && (T[o] = s, t.update()) } if (0 < t.version && r.__version !== t.version) if (void 0 === (o = t.image)) console.warn("THREE.WebGLRenderer: Texture marked for update but image is undefined"); else { if (!1 !== o.complete) return void w(r, t, e); console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete") } i.activeTexture(33984 + e), i.bindTexture(3553, r.__webglTexture) } function v(e, a) { var s = n.get(e); if (6 === e.image.length) if (0 < e.version && s.__version !== e.version) { b(s, e), i.activeTexture(33984 + a), i.bindTexture(34067, s.__webglTexture), t.pixelStorei(37440, e.flipY), a = e && e.isCompressedTexture; for (var p = e.image[0] && e.image[0].isDataTexture, f = [], m = 0; 6 > m; m++)f[m] = a || p ? p ? e.image[m].image : e.image[m] : c(e.image[m], !1, !0, r.maxCubemapSize); var g = f[0], v = h(g) || r.isWebGL2, y = o.convert(e.format), w = o.convert(e.type), M = d(y, w); for (x(34067, e, v), m = 0; 6 > m; m++)if (a) for (var _, E = f[m].mipmaps, A = 0, T = E.length; A < T; A++)_ = E[A], 1023 !== e.format && 1022 !== e.format ? -1 < i.getCompressedTextureFormats().indexOf(y) ? i.compressedTexImage2D(34069 + m, A, M, _.width, _.height, 0, _.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : i.texImage2D(34069 + m, A, M, _.width, _.height, 0, y, w, _.data); else p ? i.texImage2D(34069 + m, 0, M, f[m].width, f[m].height, 0, y, w, f[m].data) : i.texImage2D(34069 + m, 0, M, y, w, f[m]); s.__maxMipLevel = a ? E.length - 1 : 0, l(e, v) && u(34067, e, g.width, g.height), s.__version = e.version, e.onUpdate && e.onUpdate(e) } else i.activeTexture(33984 + a), i.bindTexture(34067, s.__webglTexture) } function y(t, e) { i.activeTexture(33984 + e), i.bindTexture(34067, n.get(t).__webglTexture) } function x(i, a, s) { s ? (t.texParameteri(i, 10242, o.convert(a.wrapS)), t.texParameteri(i, 10243, o.convert(a.wrapT)), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, o.convert(a.wrapR)), t.texParameteri(i, 10240, o.convert(a.magFilter)), t.texParameteri(i, 10241, o.convert(a.minFilter))) : (t.texParameteri(i, 10242, 33071), t.texParameteri(i, 10243, 33071), 32879 !== i && 35866 !== i || t.texParameteri(i, 32882, 33071), 1001 === a.wrapS && 1001 === a.wrapT || console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."), t.texParameteri(i, 10240, p(a.magFilter)), t.texParameteri(i, 10241, p(a.minFilter)), 1003 !== a.minFilter && 1006 !== a.minFilter && console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.")), !(s = e.get("EXT_texture_filter_anisotropic")) || 1015 === a.type && null === e.get("OES_texture_float_linear") || 1016 === a.type && null === (r.isWebGL2 || e.get("OES_texture_half_float_linear")) || !(1 < a.anisotropy || n.get(a).__currentAnisotropy) || (t.texParameterf(i, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(a.anisotropy, r.getMaxAnisotropy())), n.get(a).__currentAnisotropy = a.anisotropy) } function b(e, i) { void 0 === e.__webglInit && (e.__webglInit = !0, i.addEventListener("dispose", f), e.__webglTexture = t.createTexture(), a.memory.textures++) } function w(e, n, a) { var s = 3553; n.isDataTexture2DArray && (s = 35866), n.isDataTexture3D && (s = 32879), b(e, n), i.activeTexture(33984 + a), i.bindTexture(s, e.__webglTexture), t.pixelStorei(37440, n.flipY), t.pixelStorei(37441, n.premultiplyAlpha), t.pixelStorei(3317, n.unpackAlignment), a = (a = !r.isWebGL2 && (1001 !== n.wrapS || 1001 !== n.wrapT || 1003 !== n.minFilter && 1006 !== n.minFilter)) && !1 === h(n.image); var p = h(a = c(n.image, a, !1, r.maxTextureSize)) || r.isWebGL2, f = o.convert(n.format), m = o.convert(n.type), g = d(f, m); x(s, n, p); var v = n.mipmaps; if (n.isDepthTexture) { if (g = 6402, 1015 === n.type) { if (!r.isWebGL2) throw Error("Float Depth Texture only supported in WebGL2.0"); g = 36012 } else r.isWebGL2 && (g = 33189); 1026 === n.format && 6402 === g && 1012 !== n.type && 1014 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."), n.type = 1012, m = o.convert(n.type)), 1027 === n.format && (g = 34041, 1020 !== n.type && (console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."), n.type = 1020, m = o.convert(n.type))), i.texImage2D(3553, 0, g, a.width, a.height, 0, f, m, null) } else if (n.isDataTexture) if (0 < v.length && p) { for (var y = 0, w = v.length; y < w; y++)s = v[y], i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data); n.generateMipmaps = !1, e.__maxMipLevel = v.length - 1 } else i.texImage2D(3553, 0, g, a.width, a.height, 0, f, m, a.data), e.__maxMipLevel = 0; else if (n.isCompressedTexture) { for (y = 0, w = v.length; y < w; y++)s = v[y], 1023 !== n.format && 1022 !== n.format ? -1 < i.getCompressedTextureFormats().indexOf(f) ? i.compressedTexImage2D(3553, y, g, s.width, s.height, 0, s.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : i.texImage2D(3553, y, g, s.width, s.height, 0, f, m, s.data); e.__maxMipLevel = v.length - 1 } else if (n.isDataTexture2DArray) i.texImage3D(35866, 0, g, a.width, a.height, a.depth, 0, f, m, a.data), e.__maxMipLevel = 0; else if (n.isDataTexture3D) i.texImage3D(32879, 0, g, a.width, a.height, a.depth, 0, f, m, a.data), e.__maxMipLevel = 0; else if (0 < v.length && p) { for (y = 0, w = v.length; y < w; y++)s = v[y], i.texImage2D(3553, y, g, f, m, s); n.generateMipmaps = !1, e.__maxMipLevel = v.length - 1 } else i.texImage2D(3553, 0, g, f, m, a), e.__maxMipLevel = 0; l(n, p) && u(3553, n, a.width, a.height), e.__version = n.version, n.onUpdate && n.onUpdate(n) } function M(e, r, a, s) { var c = o.convert(r.texture.format), h = o.convert(r.texture.type), l = d(c, h); i.texImage2D(s, 0, l, r.width, r.height, 0, c, h, null), t.bindFramebuffer(36160, e), t.framebufferTexture2D(36160, a, s, n.get(r.texture).__webglTexture, 0), t.bindFramebuffer(36160, null) } function _(e, i, n) { if (t.bindRenderbuffer(36161, e), i.depthBuffer && !i.stencilBuffer) n ? (n = E(i), t.renderbufferStorageMultisample(36161, n, 33189, i.width, i.height)) : t.renderbufferStorage(36161, 33189, i.width, i.height), t.framebufferRenderbuffer(36160, 36096, 36161, e); else if (i.depthBuffer && i.stencilBuffer) n ? (n = E(i), t.renderbufferStorageMultisample(36161, n, 34041, i.width, i.height)) : t.renderbufferStorage(36161, 34041, i.width, i.height), t.framebufferRenderbuffer(36160, 33306, 36161, e); else { e = d(e = o.convert(i.texture.format), o.convert(i.texture.type)), n ? (n = E(i), t.renderbufferStorageMultisample(36161, n, e, i.width, i.height)) : t.renderbufferStorage(36161, e, i.width, i.height) } t.bindRenderbuffer(36161, null) } function E(t) { return r.isWebGL2 && t.isWebGLMultisampleRenderTarget ? Math.min(r.maxSamples, t.samples) : 0 } var A, T = {}, S = "undefined" != typeof OffscreenCanvas, L = 0, C = !1, R = !1; this.allocateTextureUnit = function () { var t = L; return t >= r.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + t + " texture units while this GPU supports only " + r.maxTextures), L += 1, t }, this.resetTextureUnits = function () { L = 0 }, this.setTexture2D = g, this.setTexture2DArray = function (t, e) { var r = n.get(t); 0 < t.version && r.__version !== t.version ? w(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(35866, r.__webglTexture)) }, this.setTexture3D = function (t, e) { var r = n.get(t); 0 < t.version && r.__version !== t.version ? w(r, t, e) : (i.activeTexture(33984 + e), i.bindTexture(32879, r.__webglTexture)) }, this.setTextureCube = v, this.setTextureCubeDynamic = y, this.setupRenderTarget = function (e) { var s = n.get(e), c = n.get(e.texture); e.addEventListener("dispose", m), c.__webglTexture = t.createTexture(), a.memory.textures++; var p = !0 === e.isWebGLRenderTargetCube, f = !0 === e.isWebGLMultisampleRenderTarget, v = h(e) || r.isWebGL2; if (p) for (s.__webglFramebuffer = [], f = 0; 6 > f; f++)s.__webglFramebuffer[f] = t.createFramebuffer(); else if (s.__webglFramebuffer = t.createFramebuffer(), f) if (r.isWebGL2) { s.__webglMultisampledFramebuffer = t.createFramebuffer(), s.__webglColorRenderbuffer = t.createRenderbuffer(), t.bindRenderbuffer(36161, s.__webglColorRenderbuffer), f = o.convert(e.texture.format); var y = o.convert(e.texture.type); f = d(f, y), y = E(e), t.renderbufferStorageMultisample(36161, y, f, e.width, e.height), t.bindFramebuffer(36160, s.__webglMultisampledFramebuffer), t.framebufferRenderbuffer(36160, 36064, 36161, s.__webglColorRenderbuffer), t.bindRenderbuffer(36161, null), e.depthBuffer && (s.__webglDepthRenderbuffer = t.createRenderbuffer(), _(s.__webglDepthRenderbuffer, e, !0)), t.bindFramebuffer(36160, null) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2."); if (p) { for (i.bindTexture(34067, c.__webglTexture), x(34067, e.texture, v), f = 0; 6 > f; f++)M(s.__webglFramebuffer[f], e, 36064, 34069 + f); l(e.texture, v) && u(34067, e.texture, e.width, e.height), i.bindTexture(34067, null) } else i.bindTexture(3553, c.__webglTexture), x(3553, e.texture, v), M(s.__webglFramebuffer, e, 36064, 3553), l(e.texture, v) && u(3553, e.texture, e.width, e.height), i.bindTexture(3553, null); if (e.depthBuffer) { if (s = n.get(e), c = !0 === e.isWebGLRenderTargetCube, e.depthTexture) { if (c) throw Error("target.depthTexture not supported in Cube render targets"); if (e && e.isWebGLRenderTargetCube) throw Error("Depth Texture with cube render targets is not supported"); if (t.bindFramebuffer(36160, s.__webglFramebuffer), !e.depthTexture || !e.depthTexture.isDepthTexture) throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture"); if (n.get(e.depthTexture).__webglTexture && e.depthTexture.image.width === e.width && e.depthTexture.image.height === e.height || (e.depthTexture.image.width = e.width, e.depthTexture.image.height = e.height, e.depthTexture.needsUpdate = !0), g(e.depthTexture, 0), s = n.get(e.depthTexture).__webglTexture, 1026 === e.depthTexture.format) t.framebufferTexture2D(36160, 36096, 3553, s, 0); else { if (1027 !== e.depthTexture.format) throw Error("Unknown depthTexture format"); t.framebufferTexture2D(36160, 33306, 3553, s, 0) } } else if (c) for (s.__webglDepthbuffer = [], c = 0; 6 > c; c++)t.bindFramebuffer(36160, s.__webglFramebuffer[c]), s.__webglDepthbuffer[c] = t.createRenderbuffer(), _(s.__webglDepthbuffer[c], e); else t.bindFramebuffer(36160, s.__webglFramebuffer), s.__webglDepthbuffer = t.createRenderbuffer(), _(s.__webglDepthbuffer, e); t.bindFramebuffer(36160, null) } }, this.updateRenderTargetMipmap = function (t) { var e = t.texture, o = h(t) || r.isWebGL2; if (l(e, o)) { o = t.isWebGLRenderTargetCube ? 34067 : 3553; var a = n.get(e).__webglTexture; i.bindTexture(o, a), u(o, e, t.width, t.height), i.bindTexture(o, null) } }, this.updateMultisampleRenderTarget = function (e) { if (e.isWebGLMultisampleRenderTarget) if (r.isWebGL2) { var i = n.get(e); t.bindFramebuffer(36008, i.__webglMultisampledFramebuffer), t.bindFramebuffer(36009, i.__webglFramebuffer), i = e.width; var o = e.height, a = 16384; e.depthBuffer && (a |= 256), e.stencilBuffer && (a |= 1024), t.blitFramebuffer(0, 0, i, o, 0, 0, i, o, a, 9728) } else console.warn("THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.") }, this.safeSetTexture2D = function (t, e) { t && t.isWebGLRenderTarget && (!1 === C && (console.warn("THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead."), C = !0), t = t.texture), g(t, e) }, this.safeSetTextureCube = function (t, e) { t && t.isWebGLRenderTargetCube && (!1 === R && (console.warn("THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead."), R = !0), t = t.texture), t && t.isCubeTexture || Array.isArray(t.image) && 6 === t.image.length ? v(t, e) : y(t, e) } } function ye(t, e, i) { return { convert: function (t) { if (1e3 === t) return 10497; if (1001 === t) return 33071; if (1002 === t) return 33648; if (1003 === t) return 9728; if (1004 === t) return 9984; if (1005 === t) return 9986; if (1006 === t) return 9729; if (1007 === t) return 9985; if (1008 === t) return 9987; if (1009 === t) return 5121; if (1017 === t) return 32819; if (1018 === t) return 32820; if (1019 === t) return 33635; if (1010 === t) return 5120; if (1011 === t) return 5122; if (1012 === t) return 5123; if (1013 === t) return 5124; if (1014 === t) return 5125; if (1015 === t) return 5126; if (1016 === t) { if (i.isWebGL2) return 5131; var n = e.get("OES_texture_half_float"); if (null !== n) return n.HALF_FLOAT_OES } if (1021 === t) return 6406; if (1022 === t) return 6407; if (1023 === t) return 6408; if (1024 === t) return 6409; if (1025 === t) return 6410; if (1026 === t) return 6402; if (1027 === t) return 34041; if (1028 === t) return 6403; if (100 === t) return 32774; if (101 === t) return 32778; if (102 === t) return 32779; if (200 === t) return 0; if (201 === t) return 1; if (202 === t) return 768; if (203 === t) return 769; if (204 === t) return 770; if (205 === t) return 771; if (206 === t) return 772; if (207 === t) return 773; if (208 === t) return 774; if (209 === t) return 775; if (210 === t) return 776; if ((33776 === t || 33777 === t || 33778 === t || 33779 === t) && null !== (n = e.get("WEBGL_compressed_texture_s3tc"))) { if (33776 === t) return n.COMPRESSED_RGB_S3TC_DXT1_EXT; if (33777 === t) return n.COMPRESSED_RGBA_S3TC_DXT1_EXT; if (33778 === t) return n.COMPRESSED_RGBA_S3TC_DXT3_EXT; if (33779 === t) return n.COMPRESSED_RGBA_S3TC_DXT5_EXT } if ((35840 === t || 35841 === t || 35842 === t || 35843 === t) && null !== (n = e.get("WEBGL_compressed_texture_pvrtc"))) { if (35840 === t) return n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG; if (35841 === t) return n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG; if (35842 === t) return n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG; if (35843 === t) return n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG } if (36196 === t && null !== (n = e.get("WEBGL_compressed_texture_etc1"))) return n.COMPRESSED_RGB_ETC1_WEBGL; if ((37808 === t || 37809 === t || 37810 === t || 37811 === t || 37812 === t || 37813 === t || 37814 === t || 37815 === t || 37816 === t || 37817 === t || 37818 === t || 37819 === t || 37820 === t || 37821 === t) && null !== (n = e.get("WEBGL_compressed_texture_astc"))) return t; if (103 === t || 104 === t) { if (i.isWebGL2) { if (103 === t) return 32775; if (104 === t) return 32776 } if (null !== (n = e.get("EXT_blend_minmax"))) { if (103 === t) return n.MIN_EXT; if (104 === t) return n.MAX_EXT } } if (1020 === t) { if (i.isWebGL2) return 34042; if (null !== (n = e.get("WEBGL_depth_texture"))) return n.UNSIGNED_INT_24_8_WEBGL } return 0 } } } function xe() { A.call(this), this.type = "Group" } function be() { A.call(this), this.type = "Camera", this.matrixWorldInverse = new g, this.projectionMatrix = new g, this.projectionMatrixInverse = new g } function we(t, e, i, n) { be.call(this), this.type = "PerspectiveCamera", this.fov = void 0 !== t ? t : 50, this.zoom = 1, this.near = void 0 !== i ? i : .1, this.far = void 0 !== n ? n : 2e3, this.focus = 10, this.aspect = void 0 !== e ? e : 1, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix() } function Me(t) { we.call(this), this.cameras = t || [] } function _e(t, e, i) { Go.setFromMatrixPosition(e.matrixWorld), Ho.setFromMatrixPosition(i.matrixWorld); var n = Go.distanceTo(Ho), r = e.projectionMatrix.elements, o = i.projectionMatrix.elements, a = r[14] / (r[10] - 1); i = r[14] / (r[10] + 1); var s = (r[9] + 1) / r[5], c = (r[9] - 1) / r[5], h = (r[8] - 1) / r[0], l = (o[8] + 1) / o[0]; r = a * h, o = a * l, h = (l = n / (-h + l)) * -h, e.matrixWorld.decompose(t.position, t.quaternion, t.scale), t.translateX(h), t.translateZ(l), t.matrixWorld.compose(t.position, t.quaternion, t.scale), t.matrixWorldInverse.getInverse(t.matrixWorld), e = a + l, a = i + l, t.projectionMatrix.makePerspective(r - h, o + (n - h), s * i / a * e, c * i / a * e, e, a) } function Ee(t) { function e() { return null !== u && !0 === u.isPresenting } function o() { if (e()) { var i = u.getEyeParameters("left"); c = 2 * i.renderWidth * y, h = i.renderHeight * y, S = t.getPixelRatio(), t.getSize(L), t.setDrawingBufferSize(c, h, 1), E.viewport.set(0, 0, c / 2, h), A.viewport.set(c / 2, 0, c / 2, h), R.start() } else l.enabled && t.setDrawingBufferSize(L.width, L.height, S), R.stop() } function a(t, e) { null !== e && 4 === e.length && t.set(e[0] * c, e[1] * h, e[2] * c, e[3] * h) } var c, h, l = this, u = null, d = null, p = null, f = [], m = new g, v = new g, y = 1, x = "local-floor"; "undefined" != typeof window && "VRFrameData" in window && (d = new window.VRFrameData, window.addEventListener("vrdisplaypresentchange", o, !1)); var w = new g, M = new n, _ = new r, E = new we; E.viewport = new s, E.layers.enable(1); var A = new we; A.viewport = new s, A.layers.enable(2); var T = new Me([E, A]); T.layers.enable(1), T.layers.enable(2); var S, L = new i, C = []; this.enabled = !1, this.getController = function (t) { var e = f[t]; return void 0 === e && ((e = new xe).matrixAutoUpdate = !1, e.visible = !1, f[t] = e), e }, this.getDevice = function () { return u }, this.setDevice = function (t) { void 0 !== t && (u = t), R.setContext(t) }, this.setFramebufferScaleFactor = function (t) { y = t }, this.setReferenceSpaceType = function (t) { x = t }, this.setPoseTarget = function (t) { void 0 !== t && (p = t) }, this.getCamera = function (t) { var i = "local-floor" === x ? 1.6 : 0; if (!1 === e()) return t.position.set(0, i, 0), t.rotation.set(0, 0, 0), t; if (u.depthNear = t.near, u.depthFar = t.far, u.getFrameData(d), "local-floor" === x) { var n = u.stageParameters; n ? m.fromArray(n.sittingToStandingTransform) : m.makeTranslation(0, i, 0) } i = d.pose, (n = null !== p ? p : t).matrix.copy(m), n.matrix.decompose(n.position, n.quaternion, n.scale), null !== i.orientation && (M.fromArray(i.orientation), n.quaternion.multiply(M)), null !== i.position && (M.setFromRotationMatrix(m), _.fromArray(i.position), _.applyQuaternion(M), n.position.add(_)), n.updateMatrixWorld(), E.near = t.near, A.near = t.near, E.far = t.far, A.far = t.far, E.matrixWorldInverse.fromArray(d.leftViewMatrix), A.matrixWorldInverse.fromArray(d.rightViewMatrix), v.getInverse(m), "local-floor" === x && (E.matrixWorldInverse.multiply(v), A.matrixWorldInverse.multiply(v)), null !== (t = n.parent) && (w.getInverse(t.matrixWorld), E.matrixWorldInverse.multiply(w), A.matrixWorldInverse.multiply(w)), E.matrixWorld.getInverse(E.matrixWorldInverse), A.matrixWorld.getInverse(A.matrixWorldInverse), E.projectionMatrix.fromArray(d.leftProjectionMatrix), A.projectionMatrix.fromArray(d.rightProjectionMatrix), _e(T, E, A), (t = u.getLayers()).length && (t = t[0], a(E.viewport, t.leftBounds), a(A.viewport, t.rightBounds)); t: for (t = 0; t < f.length; t++) { i = f[t]; e: { n = t; for (var r = navigator.getGamepads && navigator.getGamepads(), o = 0, s = 0, c = r.length; o < c; o++) { var h = r[o]; if (h && ("Daydream Controller" === h.id || "Gear VR Controller" === h.id || "Oculus Go Controller" === h.id || "OpenVR Gamepad" === h.id || h.id.startsWith("Oculus Touch") || h.id.startsWith("Spatial Controller"))) { if (s === n) { n = h; break e } s++ } } n = void 0 } if (void 0 !== n && void 0 !== n.pose) { if (null === n.pose) break t; !1 === (r = n.pose).hasPosition && i.position.set(.2, -.6, -.05), null !== r.position && i.position.fromArray(r.position), null !== r.orientation && i.quaternion.fromArray(r.orientation), i.matrix.compose(i.position, i.quaternion, i.scale), i.matrix.premultiply(m), i.matrix.decompose(i.position, i.quaternion, i.scale), i.matrixWorldNeedsUpdate = !0, i.visible = !0, r = "Daydream Controller" === n.id ? 0 : 1, void 0 === C[t] && (C[t] = !1), C[t] !== n.buttons[r].pressed && (C[t] = n.buttons[r].pressed, !0 === C[t] ? i.dispatchEvent({ type: "selectstart" }) : (i.dispatchEvent({ type: "selectend" }), i.dispatchEvent({ type: "select" }))) } else i.visible = !1 } return T }, this.getStandingMatrix = function () { return m }, this.isPresenting = e; var R = new b; this.setAnimationLoop = function (t) { R.setAnimationLoop(t), e() && R.start() }, this.submitFrame = function () { e() && u.submitFrame() }, this.dispose = function () { "undefined" != typeof window && window.removeEventListener("vrdisplaypresentchange", o) }, this.setFrameOfReferenceType = function () { console.warn("THREE.WebVRManager: setFrameOfReferenceType() has been deprecated.") } } function Ae(t) { function e() { return null !== c && null !== h } function i(t) { for (var e = 0; e < d.length; e++)p[e] === t.inputSource && d[e].dispatchEvent({ type: t.type }) } function n() { t.setFramebuffer(null), t.setRenderTarget(t.getRenderTarget()), x.stop() } function r(t) { h = t, x.setContext(c), x.start() } function o(t, e) { null === e ? t.matrixWorld.copy(t.matrix) : t.matrixWorld.multiplyMatrices(e.matrixWorld, t.matrix), t.matrixWorldInverse.getInverse(t.matrixWorld) } var a = t.context, c = null, h = null, l = "local-floor", u = null, d = [], p = [], f = new we; f.layers.enable(1), f.viewport = new s; var m = new we; m.layers.enable(2), m.viewport = new s; var v = new Me([f, m]); v.layers.enable(1), v.layers.enable(2), this.enabled = !1, this.getController = function (t) { var e = d[t]; return void 0 === e && ((e = new xe).matrixAutoUpdate = !1, e.visible = !1, d[t] = e), e }, this.setFramebufferScaleFactor = function (t) { }, this.setReferenceSpaceType = function (t) { l = t }, this.getSession = function () { return c }, this.setSession = function (t) { null !== (c = t) && (c.addEventListener("select", i), c.addEventListener("selectstart", i), c.addEventListener("selectend", i), c.addEventListener("end", n), c.updateRenderState({ baseLayer: new XRWebGLLayer(c, a) }), c.requestReferenceSpace(l).then(r), p = c.inputSources, c.addEventListener("inputsourceschange", (function () { p = c.inputSources, console.log(p); for (var t = 0; t < d.length; t++)d[t].userData.inputSource = p[t] }))) }, this.getCamera = function (t) { if (e()) { var i = t.parent, n = v.cameras; o(v, i); for (var r = 0; r < n.length; r++)o(n[r], i); for (t.matrixWorld.copy(v.matrixWorld), r = 0, i = (t = t.children).length; r < i; r++)t[r].updateMatrixWorld(!0); return _e(v, f, m), v } return t }, this.isPresenting = e; var y = null, x = new b; x.setAnimationLoop((function (e, i) { if (null !== (u = i.getViewerPose(h))) { var n = u.views, r = c.renderState.baseLayer; t.setFramebuffer(r.framebuffer); for (var o = 0; o < n.length; o++) { var a = n[o], s = r.getViewport(a), l = v.cameras[o]; l.matrix.fromArray(a.transform.inverse.matrix).getInverse(l.matrix), l.projectionMatrix.fromArray(a.projectionMatrix), l.viewport.set(s.x, s.y, s.width, s.height), 0 === o && v.matrix.copy(l.matrix) } } for (o = 0; o < d.length; o++)n = d[o], (r = p[o]) && null !== (r = i.getPose(r.targetRaySpace, h)) ? (n.matrix.fromArray(r.transform.matrix), n.matrix.decompose(n.position, n.rotation, n.scale), n.visible = !0) : n.visible = !1; y && y(e) })), this.setAnimationLoop = function (t) { y = t }, this.dispose = function () { }, this.getStandingMatrix = function () { return console.warn("THREE.WebXRManager: getStandingMatrix() is no longer needed."), new g }, this.getDevice = function () { console.warn("THREE.WebXRManager: getDevice() has been deprecated.") }, this.setDevice = function () { console.warn("THREE.WebXRManager: setDevice() has been deprecated.") }, this.setFrameOfReferenceType = function () { console.warn("THREE.WebXRManager: setFrameOfReferenceType() has been deprecated.") }, this.submitFrame = function () { } } function Te(t) { var e; function n() { B = new tt(Bt), (z = new K(Bt, B, t)).isWebGL2 || (B.get("WEBGL_depth_texture"), B.get("OES_texture_float"), B.get("OES_texture_half_float"), B.get("OES_texture_half_float_linear"), B.get("OES_standard_derivatives"), B.get("OES_element_index_uint"), B.get("ANGLE_instanced_arrays")), B.get("OES_texture_float_linear"), ct = new ye(Bt, B, z), (U = new ge(Bt, B, ct, z)).scissor(Mt.copy(Lt).multiplyScalar(Tt)), U.viewport(wt.copy(St).multiplyScalar(Tt)), F = new nt(Bt), G = new re, H = new ve(Bt, B, U, G, z, ct, F), k = new w(Bt), V = new et(Bt, k, F), j = new at(V, F), Z = new ot(Bt), W = new ne(ht, B, z, H), q = new ce, X = new de, Y = new J(ht, U, j, R), rt = new Q(Bt, B, F, z), st = new it(Bt, B, F, z), F.programs = W.programs, ht.context = Bt, ht.capabilities = z, ht.extensions = B, ht.properties = G, ht.renderLists = q, ht.state = U, ht.info = F } function o(t) { t.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), lt = !0 } function a() { console.log("THREE.WebGLRenderer: Context Restored."), lt = !1, n() } function c(t) { (t = t.target).removeEventListener("dispose", c), h(t), G.remove(t) } function h(t) { var e = G.get(t).program; t.program = void 0, void 0 !== e && W.releaseProgram(e) } function l(t, e, i, n) { if (!1 !== t.visible) { if (t.layers.test(e.layers)) if (t.isGroup) i = t.renderOrder; else if (t.isLight) N.pushLight(t), t.castShadow && N.pushShadow(t); else if (t.isSprite) { if (!t.frustumCulled || Rt.intersectsSprite(t)) { n && Nt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Dt); var r = j.update(t), o = t.material; o.visible && D.push(t, r, o, i, Nt.z, null) } } else if (t.isImmediateRenderObject) n && Nt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Dt), D.push(t, null, t.material, i, Nt.z, null); else if ((t.isMesh || t.isLine || t.isPoints) && (t.isSkinnedMesh && t.skeleton.update(), !t.frustumCulled || Rt.intersectsObject(t))) if (n && Nt.setFromMatrixPosition(t.matrixWorld).applyMatrix4(Dt), r = j.update(t), o = t.material, Array.isArray(o)) for (var a = r.groups, s = 0, c = a.length; s < c; s++) { var h = a[s], u = o[h.materialIndex]; u && u.visible && D.push(t, r, u, i, Nt.z, h) } else o.visible && D.push(t, r, o, i, Nt.z, null); for (s = 0, c = (t = t.children).length; s < c; s++)l(t[s], e, i, n) } } function d(t, e, i, n) { for (var r = 0, o = t.length; r < o; r++) { var a = t[r], s = a.object, c = a.geometry, h = void 0 === n ? a.material : n; if (a = a.group, i.isArrayCamera) { bt = i; for (var l = i.cameras, u = 0, d = l.length; u < d; u++) { var f = l[u]; s.layers.test(f.layers) && (U.viewport(wt.copy(f.viewport)), N.setupLights(f), p(s, e, f, c, h, a)) } } else bt = null, p(s, e, i, c, h, a) } } function p(t, i, n, r, o, a) { if (t.onBeforeRender(ht, i, n, r, o, a), N = X.get(i, bt || n), t.modelViewMatrix.multiplyMatrices(n.matrixWorldInverse, t.matrixWorld), t.normalMatrix.getNormalMatrix(t.modelViewMatrix), t.isImmediateRenderObject) { U.setMaterial(o); var s = y(n, i.fog, o, t); vt = e = null, yt = !1, function (t, e) { t.render((function (t) { ht.renderBufferImmediate(t, e) })) }(t, s) } else ht.renderBufferDirect(n, i.fog, r, o, t, a); t.onAfterRender(ht, i, n, r, o, a), N = X.get(i, bt || n) } function f(t, e, i) { var n = G.get(t), r = N.state.lights, o = n.lightsHash, a = r.state.hash; i = W.getParameters(t, r.state, N.state.shadowsArray, e, Pt.numPlanes, Pt.numIntersection, i); var s = W.getProgramCode(t, i), l = n.program, u = !0; if (void 0 === l) t.addEventListener("dispose", c); else if (l.code !== s) h(t); else { if (o.stateID !== a.stateID || o.directionalLength !== a.directionalLength || o.pointLength !== a.pointLength || o.spotLength !== a.spotLength || o.rectAreaLength !== a.rectAreaLength || o.hemiLength !== a.hemiLength || o.shadowsLength !== a.shadowsLength) o.stateID = a.stateID, o.directionalLength = a.directionalLength, o.pointLength = a.pointLength, o.spotLength = a.spotLength, o.rectAreaLength = a.rectAreaLength, o.hemiLength = a.hemiLength, o.shadowsLength = a.shadowsLength; else if (void 0 !== i.shaderID) return; u = !1 } if (u && (i.shaderID ? (s = Mo[i.shaderID], n.shader = { name: t.type, uniforms: v(s.uniforms), vertexShader: s.vertexShader, fragmentShader: s.fragmentShader }) : n.shader = { name: t.type, uniforms: t.uniforms, vertexShader: t.vertexShader, fragmentShader: t.fragmentShader }, t.onBeforeCompile(n.shader, ht), s = W.getProgramCode(t, i), l = W.acquireProgram(t, n.shader, i, s), n.program = l, t.program = l), i = l.getAttributes(), t.morphTargets) for (s = t.numSupportedMorphTargets = 0; s < ht.maxMorphTargets; s++)0 <= i["morphTarget" + s] && t.numSupportedMorphTargets++; if (t.morphNormals) for (s = t.numSupportedMorphNormals = 0; s < ht.maxMorphNormals; s++)0 <= i["morphNormal" + s] && t.numSupportedMorphNormals++; i = n.shader.uniforms, (t.isShaderMaterial || t.isRawShaderMaterial) && !0 !== t.clipping || (n.numClippingPlanes = Pt.numPlanes, n.numIntersection = Pt.numIntersection, i.clippingPlanes = Pt.uniform), n.fog = e, void 0 === o && (n.lightsHash = o = {}), o.stateID = a.stateID, o.directionalLength = a.directionalLength, o.pointLength = a.pointLength, o.spotLength = a.spotLength, o.rectAreaLength = a.rectAreaLength, o.hemiLength = a.hemiLength, o.shadowsLength = a.shadowsLength, t.lights && (i.ambientLightColor.value = r.state.ambient, i.lightProbe.value = r.state.probe, i.directionalLights.value = r.state.directional, i.spotLights.value = r.state.spot, i.rectAreaLights.value = r.state.rectArea, i.pointLights.value = r.state.point, i.hemisphereLights.value = r.state.hemi, i.directionalShadowMap.value = r.state.directionalShadowMap, i.directionalShadowMatrix.value = r.state.directionalShadowMatrix, i.spotShadowMap.value = r.state.spotShadowMap, i.spotShadowMatrix.value = r.state.spotShadowMatrix, i.pointShadowMap.value = r.state.pointShadowMap, i.pointShadowMatrix.value = r.state.pointShadowMatrix), t = n.program.getUniforms(), t = Wt.seqWithValue(t.seq, i), n.uniformsList = t } function y(t, e, i, n) { H.resetTextureUnits(); var r = G.get(i), o = r.lightsHash, a = N.state.lights.state.hash; It && (Ot || t !== xt) && Pt.setState(i.clippingPlanes, i.clipIntersection, i.clipShadows, t, r, t === xt && i.id === gt), !1 === i.needsUpdate && (void 0 === r.program || i.fog && r.fog !== e ? i.needsUpdate = !0 : (!i.lights || o.stateID === a.stateID && o.directionalLength === a.directionalLength && o.pointLength === a.pointLength && o.spotLength === a.spotLength && o.rectAreaLength === a.rectAreaLength && o.hemiLength === a.hemiLength && o.shadowsLength === a.shadowsLength) && (void 0 === r.numClippingPlanes || r.numClippingPlanes === Pt.numPlanes && r.numIntersection === Pt.numIntersection) || (i.needsUpdate = !0)), i.needsUpdate && (f(i, e, n), i.needsUpdate = !1); var s = !1, c = !1, h = !1; a = (o = r.program).getUniforms(); var l = r.shader.uniforms; if (U.useProgram(o.program) && (h = c = s = !0), i.id !== gt && (gt = i.id, c = !0), (s || xt !== t) && (a.setValue(Bt, "projectionMatrix", t.projectionMatrix), z.logarithmicDepthBuffer && a.setValue(Bt, "logDepthBufFC", 2 / (Math.log(t.far + 1) / Math.LN2)), xt !== t && (xt = t, h = c = !0), (i.isShaderMaterial || i.isMeshPhongMaterial || i.isMeshStandardMaterial || i.envMap) && (void 0 !== (s = a.map.cameraPosition) && s.setValue(Bt, Nt.setFromMatrixPosition(t.matrixWorld))), (i.isMeshPhongMaterial || i.isMeshLambertMaterial || i.isMeshBasicMaterial || i.isMeshStandardMaterial || i.isShaderMaterial || i.skinning) && a.setValue(Bt, "viewMatrix", t.matrixWorldInverse)), i.skinning && (a.setOptional(Bt, n, "bindMatrix"), a.setOptional(Bt, n, "bindMatrixInverse"), t = n.skeleton)) if (s = t.bones, z.floatVertexTextures) { if (void 0 === t.boneTexture) { s = Math.sqrt(4 * s.length), s = fo.ceilPowerOfTwo(s), s = Math.max(s, 4); var d = new Float32Array(s * s * 4); d.set(t.boneMatrices); var p = new u(d, s, s, 1023, 1015); p.needsUpdate = !0, t.boneMatrices = d, t.boneTexture = p, t.boneTextureSize = s } a.setValue(Bt, "boneTexture", t.boneTexture, H), a.setValue(Bt, "boneTextureSize", t.boneTextureSize) } else a.setOptional(Bt, t, "boneMatrices"); return c && (a.setValue(Bt, "toneMappingExposure", ht.toneMappingExposure), a.setValue(Bt, "toneMappingWhitePoint", ht.toneMappingWhitePoint), i.lights && (c = h, l.ambientLightColor.needsUpdate = c, l.lightProbe.needsUpdate = c, l.directionalLights.needsUpdate = c, l.pointLights.needsUpdate = c, l.spotLights.needsUpdate = c, l.rectAreaLights.needsUpdate = c, l.hemisphereLights.needsUpdate = c), e && i.fog && (l.fogColor.value.copy(e.color), e.isFog ? (l.fogNear.value = e.near, l.fogFar.value = e.far) : e.isFogExp2 && (l.fogDensity.value = e.density)), i.isMeshBasicMaterial ? x(l, i) : i.isMeshLambertMaterial ? (x(l, i), i.emissiveMap && (l.emissiveMap.value = i.emissiveMap)) : i.isMeshPhongMaterial ? (x(l, i), i.isMeshToonMaterial ? (M(l, i), i.gradientMap && (l.gradientMap.value = i.gradientMap)) : M(l, i)) : i.isMeshStandardMaterial ? (x(l, i), i.isMeshPhysicalMaterial ? (_(l, i), l.reflectivity.value = i.reflectivity, l.clearCoat.value = i.clearCoat, l.clearCoatRoughness.value = i.clearCoatRoughness) : _(l, i)) : i.isMeshMatcapMaterial ? (x(l, i), i.matcap && (l.matcap.value = i.matcap), i.bumpMap && (l.bumpMap.value = i.bumpMap, l.bumpScale.value = i.bumpScale, 1 === i.side && (l.bumpScale.value *= -1)), i.normalMap && (l.normalMap.value = i.normalMap, l.normalScale.value.copy(i.normalScale), 1 === i.side && l.normalScale.value.negate()), i.displacementMap && (l.displacementMap.value = i.displacementMap, l.displacementScale.value = i.displacementScale, l.displacementBias.value = i.displacementBias)) : i.isMeshDepthMaterial ? (x(l, i), i.displacementMap && (l.displacementMap.value = i.displacementMap, l.displacementScale.value = i.displacementScale, l.displacementBias.value = i.displacementBias)) : i.isMeshDistanceMaterial ? (x(l, i), i.displacementMap && (l.displacementMap.value = i.displacementMap, l.displacementScale.value = i.displacementScale, l.displacementBias.value = i.displacementBias), l.referencePosition.value.copy(i.referencePosition), l.nearDistance.value = i.nearDistance, l.farDistance.value = i.farDistance) : i.isMeshNormalMaterial ? (x(l, i), i.bumpMap && (l.bumpMap.value = i.bumpMap, l.bumpScale.value = i.bumpScale, 1 === i.side && (l.bumpScale.value *= -1)), i.normalMap && (l.normalMap.value = i.normalMap, l.normalScale.value.copy(i.normalScale), 1 === i.side && l.normalScale.value.negate()), i.displacementMap && (l.displacementMap.value = i.displacementMap, l.displacementScale.value = i.displacementScale, l.displacementBias.value = i.displacementBias)) : i.isLineBasicMaterial ? (l.diffuse.value.copy(i.color), l.opacity.value = i.opacity, i.isLineDashedMaterial && (l.dashSize.value = i.dashSize, l.totalSize.value = i.dashSize + i.gapSize, l.scale.value = i.scale)) : i.isPointsMaterial ? (l.diffuse.value.copy(i.color), l.opacity.value = i.opacity, l.size.value = i.size * Tt, l.scale.value = .5 * At, l.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), l.uvTransform.value.copy(i.map.matrix))) : i.isSpriteMaterial ? (l.diffuse.value.copy(i.color), l.opacity.value = i.opacity, l.rotation.value = i.rotation, l.map.value = i.map, null !== i.map && (!0 === i.map.matrixAutoUpdate && i.map.updateMatrix(), l.uvTransform.value.copy(i.map.matrix))) : i.isShadowMaterial && (l.color.value.copy(i.color), l.opacity.value = i.opacity), void 0 !== l.ltc_1 && (l.ltc_1.value = wo.LTC_1), void 0 !== l.ltc_2 && (l.ltc_2.value = wo.LTC_2), Wt.upload(Bt, r.uniformsList, l, H)), i.isShaderMaterial && !0 === i.uniformsNeedUpdate && (Wt.upload(Bt, r.uniformsList, l, H), i.uniformsNeedUpdate = !1), i.isSpriteMaterial && a.setValue(Bt, "center", n.center), a.setValue(Bt, "modelViewMatrix", n.modelViewMatrix), a.setValue(Bt, "normalMatrix", n.normalMatrix), a.setValue(Bt, "modelMatrix", n.matrixWorld), o } function x(t, e) { if (t.opacity.value = e.opacity, e.color && t.diffuse.value.copy(e.color), e.emissive && t.emissive.value.copy(e.emissive).multiplyScalar(e.emissiveIntensity), e.map && (t.map.value = e.map), e.alphaMap && (t.alphaMap.value = e.alphaMap), e.specularMap && (t.specularMap.value = e.specularMap), e.envMap && (t.envMap.value = e.envMap, t.flipEnvMap.value = e.envMap.isCubeTexture ? -1 : 1, t.reflectivity.value = e.reflectivity, t.refractionRatio.value = e.refractionRatio, t.maxMipLevel.value = G.get(e.envMap).__maxMipLevel), e.lightMap && (t.lightMap.value = e.lightMap, t.lightMapIntensity.value = e.lightMapIntensity), e.aoMap && (t.aoMap.value = e.aoMap, t.aoMapIntensity.value = e.aoMapIntensity), e.map) var i = e.map; else e.specularMap ? i = e.specularMap : e.displacementMap ? i = e.displacementMap : e.normalMap ? i = e.normalMap : e.bumpMap ? i = e.bumpMap : e.roughnessMap ? i = e.roughnessMap : e.metalnessMap ? i = e.metalnessMap : e.alphaMap ? i = e.alphaMap : e.emissiveMap && (i = e.emissiveMap); void 0 !== i && (i.isWebGLRenderTarget && (i = i.texture), !0 === i.matrixAutoUpdate && i.updateMatrix(), t.uvTransform.value.copy(i.matrix)) } function M(t, e) { t.specular.value.copy(e.specular), t.shininess.value = Math.max(e.shininess, 1e-4), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias) } function _(t, e) { t.roughness.value = e.roughness, t.metalness.value = e.metalness, e.roughnessMap && (t.roughnessMap.value = e.roughnessMap), e.metalnessMap && (t.metalnessMap.value = e.metalnessMap), e.emissiveMap && (t.emissiveMap.value = e.emissiveMap), e.bumpMap && (t.bumpMap.value = e.bumpMap, t.bumpScale.value = e.bumpScale, 1 === e.side && (t.bumpScale.value *= -1)), e.normalMap && (t.normalMap.value = e.normalMap, t.normalScale.value.copy(e.normalScale), 1 === e.side && t.normalScale.value.negate()), e.displacementMap && (t.displacementMap.value = e.displacementMap, t.displacementScale.value = e.displacementScale, t.displacementBias.value = e.displacementBias), e.envMap && (t.envMapIntensity.value = e.envMapIntensity) } console.log("THREE.WebGLRenderer", "105"); var E = void 0 !== (t = t || {}).canvas ? t.canvas : document.createElementNS("http://www.w3.org/1999/xhtml", "canvas"), A = void 0 !== t.context ? t.context : null, T = void 0 !== t.alpha && t.alpha, S = void 0 === t.depth || t.depth, L = void 0 === t.stencil || t.stencil, C = void 0 !== t.antialias && t.antialias, R = void 0 === t.premultipliedAlpha || t.premultipliedAlpha, P = void 0 !== t.preserveDrawingBuffer && t.preserveDrawingBuffer, I = void 0 !== t.powerPreference ? t.powerPreference : "default", O = void 0 !== t.failIfMajorPerformanceCaveat && t.failIfMajorPerformanceCaveat, D = null, N = null; this.domElement = E, this.context = null, this.debug = { checkShaderErrors: !0 }, this.sortObjects = this.autoClearStencil = this.autoClearDepth = this.autoClearColor = this.autoClear = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this.gammaFactor = 2, this.physicallyCorrectLights = this.gammaOutput = this.gammaInput = !1, this.toneMappingWhitePoint = this.toneMappingExposure = this.toneMapping = 1, this.maxMorphTargets = 8, this.maxMorphNormals = 4; var B, z, U, F, G, H, k, V, j, W, q, X, Y, Z, rt, st, ct, ht = this, lt = !1, ut = null, dt = 0, pt = 0, ft = null, mt = null, gt = -1, vt = e = null, yt = !1, xt = null, bt = null, wt = new s, Mt = new s, _t = null, Et = E.width, At = E.height, Tt = 1, St = new s(0, 0, Et, At), Lt = new s(0, 0, Et, At), Ct = !1, Rt = new m, Pt = new $, It = !1, Ot = !1, Dt = new g, Nt = new r; try { T = { alpha: T, depth: S, stencil: L, antialias: C, premultipliedAlpha: R, preserveDrawingBuffer: P, powerPreference: I, failIfMajorPerformanceCaveat: O, xrCompatible: !0 }, E.addEventListener("webglcontextlost", o, !1), E.addEventListener("webglcontextrestored", a, !1); var Bt = A || E.getContext("webgl", T) || E.getContext("experimental-webgl", T); if (null === Bt) { if (null !== E.getContext("webgl")) throw Error("Error creating WebGL context with your selected attributes."); throw Error("Error creating WebGL context.") } void 0 === Bt.getShaderPrecisionFormat && (Bt.getShaderPrecisionFormat = function () { return { rangeMin: 1, rangeMax: 1, precision: 1 } }) } catch (t) { throw console.error("THREE.WebGLRenderer: " + t.message), t } n(); var zt = "undefined" != typeof navigator && "xr" in navigator && "supportsSession" in navigator.xr ? new Ae(ht) : new Ee(ht); this.vr = zt; var Ut = new me(ht, j, z.maxTextureSize); this.shadowMap = Ut, this.getContext = function () { return Bt }, this.getContextAttributes = function () { return Bt.getContextAttributes() }, this.forceContextLoss = function () { var t = B.get("WEBGL_lose_context"); t && t.loseContext() }, this.forceContextRestore = function () { var t = B.get("WEBGL_lose_context"); t && t.restoreContext() }, this.getPixelRatio = function () { return Tt }, this.setPixelRatio = function (t) { void 0 !== t && (Tt = t, this.setSize(Et, At, !1)) }, this.getSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getsize() now requires a Vector2 as an argument"), t = new i), t.set(Et, At) }, this.setSize = function (t, e, i) { zt.isPresenting() ? console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.") : (Et = t, At = e, E.width = t * Tt, E.height = e * Tt, !1 !== i && (E.style.width = t + "px", E.style.height = e + "px"), this.setViewport(0, 0, t, e)) }, this.getDrawingBufferSize = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument"), t = new i), t.set(Et * Tt, At * Tt) }, this.setDrawingBufferSize = function (t, e, i) { Et = t, At = e, Tt = i, E.width = t * i, E.height = e * i, this.setViewport(0, 0, t, e) }, this.getCurrentViewport = function (t) { return void 0 === t && (console.warn("WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument"), t = new s), t.copy(wt) }, this.getViewport = function (t) { return t.copy(St) }, this.setViewport = function (t, e, i, n) { t.isVector4 ? St.set(t.x, t.y, t.z, t.w) : St.set(t, e, i, n), U.viewport(wt.copy(St).multiplyScalar(Tt)) }, this.getScissor = function (t) { return t.copy(Lt) }, this.setScissor = function (t, e, i, n) { t.isVector4 ? Lt.set(t.x, t.y, t.z, t.w) : Lt.set(t, e, i, n), U.scissor(Mt.copy(Lt).multiplyScalar(Tt)) }, this.getScissorTest = function () { return Ct }, this.setScissorTest = function (t) { U.setScissorTest(Ct = t) }, this.getClearColor = function () { return Y.getClearColor() }, this.setClearColor = function () { Y.setClearColor.apply(Y, arguments) }, this.getClearAlpha = function () { return Y.getClearAlpha() }, this.setClearAlpha = function () { Y.setClearAlpha.apply(Y, arguments) }, this.clear = function (t, e, i) { var n = 0; (void 0 === t || t) && (n |= 16384), (void 0 === e || e) && (n |= 256), (void 0 === i || i) && (n |= 1024), Bt.clear(n) }, this.clearColor = function () { this.clear(!0, !1, !1) }, this.clearDepth = function () { this.clear(!1, !0, !1) }, this.clearStencil = function () { this.clear(!1, !1, !0) }, this.dispose = function () { E.removeEventListener("webglcontextlost", o, !1), E.removeEventListener("webglcontextrestored", a, !1), q.dispose(), X.dispose(), G.dispose(), j.dispose(), zt.dispose(), Gt.stop() }, this.renderBufferImmediate = function (t, e) { U.initAttributes(); var i = G.get(t); t.hasPositions && !i.position && (i.position = Bt.createBuffer()), t.hasNormals && !i.normal && (i.normal = Bt.createBuffer()), t.hasUvs && !i.uv && (i.uv = Bt.createBuffer()), t.hasColors && !i.color && (i.color = Bt.createBuffer()), e = e.getAttributes(), t.hasPositions && (Bt.bindBuffer(34962, i.position), Bt.bufferData(34962, t.positionArray, 35048), U.enableAttribute(e.position), Bt.vertexAttribPointer(e.position, 3, 5126, !1, 0, 0)), t.hasNormals && (Bt.bindBuffer(34962, i.normal), Bt.bufferData(34962, t.normalArray, 35048), U.enableAttribute(e.normal), Bt.vertexAttribPointer(e.normal, 3, 5126, !1, 0, 0)), t.hasUvs && (Bt.bindBuffer(34962, i.uv), Bt.bufferData(34962, t.uvArray, 35048), U.enableAttribute(e.uv), Bt.vertexAttribPointer(e.uv, 2, 5126, !1, 0, 0)), t.hasColors && (Bt.bindBuffer(34962, i.color), Bt.bufferData(34962, t.colorArray, 35048), U.enableAttribute(e.color), Bt.vertexAttribPointer(e.color, 3, 5126, !1, 0, 0)), U.disableUnusedAttributes(), Bt.drawArrays(4, 0, t.count), t.count = 0 }, this.renderBufferDirect = function (t, i, n, r, o, a) { var s = o.isMesh && 0 > o.matrixWorld.determinant(); U.setMaterial(r, s); var c = y(t, i, r, o), h = !1; e === n.id && vt === c.id && yt === (!0 === r.wireframe) || (e = n.id, vt = c.id, yt = !0 === r.wireframe, h = !0), o.morphTargetInfluences && (Z.update(o, n, r, c), h = !0), s = n.index; var l = n.attributes.position; if (i = 1, !0 === r.wireframe && (s = V.getWireframeAttribute(n), i = 2), t = rt, null !== s) { var u = k.get(s); (t = st).setIndex(u) } if (h) { if (n && n.isInstancedBufferGeometry && !z.isWebGL2 && null === B.get("ANGLE_instanced_arrays")) console.error("THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."); else { U.initAttributes(), h = n.attributes, c = c.getAttributes(); var d = r.defaultAttributeValues; for (_ in c) { var p = c[_]; if (0 <= p) { var f = h[_]; if (void 0 !== f) { var m = f.normalized, g = f.itemSize, v = k.get(f); if (void 0 !== v) { var x = v.buffer, b = v.type; if (v = v.bytesPerElement, f.isInterleavedBufferAttribute) { var w = f.data, M = w.stride; f = f.offset, w && w.isInstancedInterleavedBuffer ? (U.enableAttributeAndDivisor(p, w.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = w.meshPerAttribute * w.count)) : U.enableAttribute(p), Bt.bindBuffer(34962, x), Bt.vertexAttribPointer(p, g, b, m, M * v, f * v) } else f.isInstancedBufferAttribute ? (U.enableAttributeAndDivisor(p, f.meshPerAttribute), void 0 === n.maxInstancedCount && (n.maxInstancedCount = f.meshPerAttribute * f.count)) : U.enableAttribute(p), Bt.bindBuffer(34962, x), Bt.vertexAttribPointer(p, g, b, m, 0, 0) } } else if (void 0 !== d && void 0 !== (m = d[_])) switch (m.length) { case 2: Bt.vertexAttrib2fv(p, m); break; case 3: Bt.vertexAttrib3fv(p, m); break; case 4: Bt.vertexAttrib4fv(p, m); break; default: Bt.vertexAttrib1fv(p, m) } } } U.disableUnusedAttributes() } null !== s && Bt.bindBuffer(34963, u.buffer) } u = 1 / 0, null !== s ? u = s.count : void 0 !== l && (u = l.count), s = n.drawRange.start * i, l = null !== a ? a.start * i : 0; var _ = Math.max(s, l); if (0 !== (a = Math.max(0, Math.min(u, s + n.drawRange.count * i, l + (null !== a ? a.count * i : 1 / 0)) - 1 - _ + 1))) { if (o.isMesh) if (!0 === r.wireframe) U.setLineWidth(r.wireframeLinewidth * (null === ft ? Tt : 1)), t.setMode(1); else switch (o.drawMode) { case 0: t.setMode(4); break; case 1: t.setMode(5); break; case 2: t.setMode(6) } else o.isLine ? (void 0 === (r = r.linewidth) && (r = 1), U.setLineWidth(r * (null === ft ? Tt : 1)), o.isLineSegments ? t.setMode(1) : o.isLineLoop ? t.setMode(2) : t.setMode(3)) : o.isPoints ? t.setMode(0) : o.isSprite && t.setMode(4); n && n.isInstancedBufferGeometry ? 0 < n.maxInstancedCount && t.renderInstances(n, _, a) : t.render(_, a) } }, this.compile = function (t, e) { (N = X.get(t, e)).init(), t.traverse((function (t) { t.isLight && (N.pushLight(t), t.castShadow && N.pushShadow(t)) })), N.setupLights(e), t.traverse((function (e) { if (e.material) if (Array.isArray(e.material)) for (var i = 0; i < e.material.length; i++)f(e.material[i], t.fog, e); else f(e.material, t.fog, e) })) }; var Ft = null, Gt = new b; Gt.setAnimationLoop((function (t) { zt.isPresenting() || Ft && Ft(t) })), "undefined" != typeof window && Gt.setContext(window), this.setAnimationLoop = function (t) { Ft = t, zt.setAnimationLoop(t), Gt.start() }, this.render = function (t, i, n, r) { if (void 0 !== n) { console.warn("THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead."); var o = n } if (void 0 !== r) { console.warn("THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead."); var a = r } i && i.isCamera ? lt || (vt = e = null, yt = !1, gt = -1, xt = null, !0 === t.autoUpdate && t.updateMatrixWorld(), null === i.parent && i.updateMatrixWorld(), zt.enabled && (i = zt.getCamera(i)), (N = X.get(t, i)).init(), t.onBeforeRender(ht, t, i, o || ft), Dt.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse), Rt.setFromMatrix(Dt), Ot = this.localClippingEnabled, It = Pt.init(this.clippingPlanes, Ot, i), (D = q.get(t, i)).init(), l(t, i, 0, ht.sortObjects), !0 === ht.sortObjects && D.sort(), It && Pt.beginShadows(), Ut.render(N.state.shadowsArray, t, i), N.setupLights(i), It && Pt.endShadows(), this.info.autoReset && this.info.reset(), void 0 !== o && this.setRenderTarget(o), Y.render(D, t, i, a), n = D.opaque, r = D.transparent, t.overrideMaterial ? (o = t.overrideMaterial, n.length && d(n, t, i, o), r.length && d(r, t, i, o)) : (n.length && d(n, t, i), r.length && d(r, t, i)), t.onAfterRender(ht, t, i), null !== ft && (H.updateRenderTargetMipmap(ft), H.updateMultisampleRenderTarget(ft)), U.buffers.depth.setTest(!0), U.buffers.depth.setMask(!0), U.buffers.color.setMask(!0), U.setPolygonOffset(!1), zt.enabled && zt.submitFrame(), N = D = null) : console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.") }, this.setFramebuffer = function (t) { ut !== t && Bt.bindFramebuffer(36160, t), ut = t }, this.getActiveCubeFace = function () { return dt }, this.getActiveMipMapLevel = function () { return pt }, this.getRenderTarget = function () { return ft }, this.setRenderTarget = function (t, e, i) { ft = t, dt = e, pt = i, t && void 0 === G.get(t).__webglFramebuffer && H.setupRenderTarget(t); var n = ut, r = !1; t ? (n = G.get(t).__webglFramebuffer, t.isWebGLRenderTargetCube ? (n = n[e || 0], r = !0) : n = t.isWebGLMultisampleRenderTarget ? G.get(t).__webglMultisampledFramebuffer : n, wt.copy(t.viewport), Mt.copy(t.scissor), _t = t.scissorTest) : (wt.copy(St).multiplyScalar(Tt), Mt.copy(Lt).multiplyScalar(Tt), _t = Ct), mt !== n && (Bt.bindFramebuffer(36160, n), mt = n), U.viewport(wt), U.scissor(Mt), U.setScissorTest(_t), r && (t = G.get(t.texture), Bt.framebufferTexture2D(36160, 36064, 34069 + (e || 0), t.__webglTexture, i || 0)) }, this.readRenderTargetPixels = function (t, e, i, n, r, o, a) { if (t && t.isWebGLRenderTarget) { var s = G.get(t).__webglFramebuffer; if (t.isWebGLRenderTargetCube && void 0 !== a && (s = s[a]), s) { a = !1, s !== mt && (Bt.bindFramebuffer(36160, s), a = !0); try { var c = t.texture, h = c.format, l = c.type; 1023 !== h && ct.convert(h) !== Bt.getParameter(35739) ? console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.") : 1009 === l || ct.convert(l) === Bt.getParameter(35738) || 1015 === l && (z.isWebGL2 || B.get("OES_texture_float") || B.get("WEBGL_color_buffer_float")) || 1016 === l && (z.isWebGL2 ? B.get("EXT_color_buffer_float") : B.get("EXT_color_buffer_half_float")) ? 36053 === Bt.checkFramebufferStatus(36160) ? 0 <= e && e <= t.width - n && 0 <= i && i <= t.height - r && Bt.readPixels(e, i, n, r, ct.convert(h), ct.convert(l), o) : console.error("THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.") : console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.") } finally { a && Bt.bindFramebuffer(36160, mt) } } } else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.") }, this.copyFramebufferToTexture = function (t, e, i) { var n = e.image.width, r = e.image.height, o = ct.convert(e.format); H.setTexture2D(e, 0), Bt.copyTexImage2D(3553, i || 0, o, t.x, t.y, n, r, 0) }, this.copyTextureToTexture = function (t, e, i, n) { var r = e.image.width, o = e.image.height, a = ct.convert(i.format), s = ct.convert(i.type); H.setTexture2D(i, 0), e.isDataTexture ? Bt.texSubImage2D(3553, n || 0, t.x, t.y, r, o, a, s, e.image.data) : Bt.texSubImage2D(3553, n || 0, t.x, t.y, a, s, e.image) } } function Se(t, e) { this.name = "", this.color = new x(t), this.density = void 0 !== e ? e : 25e-5 } function Le(t, e, i) { this.name = "", this.color = new x(t), this.near = void 0 !== e ? e : 1, this.far = void 0 !== i ? i : 1e3 } function Ce() { A.call(this), this.type = "Scene", this.overrideMaterial = this.fog = this.background = null, this.autoUpdate = !0 } function Re(t, e) { this.array = t, this.stride = e, this.count = void 0 !== t ? t.length / e : 0, this.dynamic = !1, this.updateRange = { offset: 0, count: -1 }, this.version = 0 } function Pe(t, e, i, n) { this.data = t, this.itemSize = e, this.offset = i, this.normalized = !0 === n } function Ie(t) { j.call(this), this.type = "SpriteMaterial", this.color = new x(16777215), this.map = null, this.rotation = 0, this.sizeAttenuation = !0, this.lights = !1, this.transparent = !0, this.setValues(t) } function Oe(t) { if (A.call(this), this.type = "Sprite", void 0 === Fo) { Fo = new F; var e = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]); e = new Re(e, 5), Fo.setIndex([0, 1, 2, 0, 2, 3]), Fo.addAttribute("position", new Pe(e, 3, 0, !1)), Fo.addAttribute("uv", new Pe(e, 2, 3, !1)) } this.geometry = Fo, this.material = void 0 !== t ? t : new Ie, this.center = new i(.5, .5) } function De() { A.call(this), this.type = "LOD", Object.defineProperties(this, { levels: { enumerable: !0, value: [] } }) } function Ne(t, e) { t && t.isGeometry && console.error("THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead."), Z.call(this, t, e), this.type = "SkinnedMesh", this.bindMode = "attached", this.bindMatrix = new g, this.bindMatrixInverse = new g } function Be(t, e) { if (t = t || [], this.bones = t.slice(0), this.boneMatrices = new Float32Array(16 * this.bones.length), void 0 === e) this.calculateInverses(); else if (this.bones.length === e.length) this.boneInverses = e.slice(0); else for (console.warn("THREE.Skeleton boneInverses is the wrong length."), this.boneInverses = [], t = 0, e = this.bones.length; t < e; t++)this.boneInverses.push(new g) } function ze() { A.call(this), this.type = "Bone" } function Ue(t) { j.call(this), this.type = "LineBasicMaterial", this.color = new x(16777215), this.linewidth = 1, this.linejoin = this.linecap = "round", this.lights = !1, this.setValues(t) } function Fe(t, e, i) { 1 === i && console.error("THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead."), A.call(this), this.type = "Line", this.geometry = void 0 !== t ? t : new F, this.material = void 0 !== e ? e : new Ue({ color: 16777215 * Math.random() }) } function Ge(t, e) { Fe.call(this, t, e), this.type = "LineSegments" } function He(t, e) { Fe.call(this, t, e), this.type = "LineLoop" } function ke(t) { j.call(this), this.type = "PointsMaterial", this.color = new x(16777215), this.map = null, this.size = 1, this.sizeAttenuation = !0, this.lights = this.morphTargets = !1, this.setValues(t) } function Ve(t, e) { A.call(this), this.type = "Points", this.geometry = void 0 !== t ? t : new F, this.material = void 0 !== e ? e : new ke({ color: 16777215 * Math.random() }) } function je(t, e, i, n, r, o, s, c, h) { a.call(this, t, e, i, n, r, o, s, c, h), this.format = void 0 !== s ? s : 1022, this.minFilter = void 0 !== o ? o : 1006, this.magFilter = void 0 !== r ? r : 1006, this.generateMipmaps = !1 } function We(t, e, i, n, r, o, s, c, h, l, u, d) { a.call(this, null, o, s, c, h, l, n, r, u, d), this.image = { width: e, height: i }, this.mipmaps = t, this.generateMipmaps = this.flipY = !1 } function qe(t, e, i, n, r, o, s, c, h) { a.call(this, t, e, i, n, r, o, s, c, h), this.needsUpdate = !0 } function Xe(t, e, i, n, r, o, s, c, h, l) { if (1026 !== (l = void 0 !== l ? l : 1026) && 1027 !== l) throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"); void 0 === i && 1026 === l && (i = 1012), void 0 === i && 1027 === l && (i = 1020), a.call(this, null, n, r, o, s, c, l, i, h), this.image = { width: t, height: e }, this.magFilter = void 0 !== s ? s : 1003, this.minFilter = void 0 !== c ? c : 1003, this.generateMipmaps = this.flipY = !1 } function Ye(t) { F.call(this), this.type = "WireframeGeometry"; var e, i, n, o = [], a = [0, 0], s = {}, c = ["a", "b", "c"]; if (t && t.isGeometry) { var h = t.faces, l = 0; for (i = h.length; l < i; l++) { var u = h[l]; for (e = 0; 3 > e; e++) { var d = u[c[e]], p = u[c[(e + 1) % 3]]; a[0] = Math.min(d, p), a[1] = Math.max(d, p), void 0 === s[d = a[0] + "," + a[1]] && (s[d] = { index1: a[0], index2: a[1] }) } } for (d in s) l = s[d], c = t.vertices[l.index1], o.push(c.x, c.y, c.z), c = t.vertices[l.index2], o.push(c.x, c.y, c.z) } else if (t && t.isBufferGeometry) if (c = new r, null !== t.index) { h = t.attributes.position, u = t.index; var f = t.groups; for (0 === f.length && (f = [{ start: 0, count: u.count, materialIndex: 0 }]), t = 0, n = f.length; t < n; ++t)for (e = (l = f[t]).start, i = l.count, l = e, i = e + i; l < i; l += 3)for (e = 0; 3 > e; e++)d = u.getX(l + e), p = u.getX(l + (e + 1) % 3), a[0] = Math.min(d, p), a[1] = Math.max(d, p), void 0 === s[d = a[0] + "," + a[1]] && (s[d] = { index1: a[0], index2: a[1] }); for (d in s) l = s[d], c.fromBufferAttribute(h, l.index1), o.push(c.x, c.y, c.z), c.fromBufferAttribute(h, l.index2), o.push(c.x, c.y, c.z) } else for (l = 0, i = (h = t.attributes.position).count / 3; l < i; l++)for (e = 0; 3 > e; e++)s = 3 * l + e, c.fromBufferAttribute(h, s), o.push(c.x, c.y, c.z), s = 3 * l + (e + 1) % 3, c.fromBufferAttribute(h, s), o.push(c.x, c.y, c.z); this.addAttribute("position", new N(o, 3)) } function Ze(t, e, i) { T.call(this), this.type = "ParametricGeometry", this.parameters = { func: t, slices: e, stacks: i }, this.fromBufferGeometry(new Je(t, e, i)), this.mergeVertices() } function Je(t, e, i) { F.call(this), this.type = "ParametricBufferGeometry", this.parameters = { func: t, slices: e, stacks: i }; var n, o, a = [], s = [], c = [], h = [], l = new r, u = new r, d = new r, p = new r, f = new r; 3 > t.length && console.error("THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter."); var m = e + 1; for (n = 0; n <= i; n++) { var g = n / i; for (o = 0; o <= e; o++) { var v = o / e; t(v, g, u), s.push(u.x, u.y, u.z), 0 <= v - 1e-5 ? (t(v - 1e-5, g, d), p.subVectors(u, d)) : (t(v + 1e-5, g, d), p.subVectors(d, u)), 0 <= g - 1e-5 ? (t(v, g - 1e-5, d), f.subVectors(u, d)) : (t(v, g + 1e-5, d), f.subVectors(d, u)), l.crossVectors(p, f).normalize(), c.push(l.x, l.y, l.z), h.push(v, g) } } for (n = 0; n < i; n++)for (o = 0; o < e; o++)t = n * m + o + 1, l = (n + 1) * m + o + 1, u = (n + 1) * m + o, a.push(n * m + o, t, u), a.push(t, l, u); this.setIndex(a), this.addAttribute("position", new N(s, 3)), this.addAttribute("normal", new N(c, 3)), this.addAttribute("uv", new N(h, 2)) } function Qe(t, e, i, n) { T.call(this), this.type = "PolyhedronGeometry", this.parameters = { vertices: t, indices: e, radius: i, detail: n }, this.fromBufferGeometry(new Ke(t, e, i, n)), this.mergeVertices() } function Ke(t, e, n, o) { function a(t) { h.push(t.x, t.y, t.z) } function s(e, i) { e *= 3, i.x = t[e + 0], i.y = t[e + 1], i.z = t[e + 2] } function c(t, e, i, n) { 0 > n && 1 === t.x && (l[e] = t.x - 1), 0 === i.x && 0 === i.z && (l[e] = n / 2 / Math.PI + .5) } F.call(this), this.type = "PolyhedronBufferGeometry", this.parameters = { vertices: t, indices: e, radius: n, detail: o }, n = n || 1; var h = [], l = []; !function (t) { for (var i = new r, n = new r, o = new r, c = 0; c < e.length; c += 3) { s(e[c + 0], i), s(e[c + 1], n), s(e[c + 2], o); var h, l, u = i, d = n, p = o, f = Math.pow(2, t), m = []; for (l = 0; l <= f; l++) { m[l] = []; var g = u.clone().lerp(p, l / f), v = d.clone().lerp(p, l / f), y = f - l; for (h = 0; h <= y; h++)m[l][h] = 0 === h && l === f ? g : g.clone().lerp(v, h / y) } for (l = 0; l < f; l++)for (h = 0; h < 2 * (f - l) - 1; h++)u = Math.floor(h / 2), 0 == h % 2 ? (a(m[l][u + 1]), a(m[l + 1][u]), a(m[l][u])) : (a(m[l][u + 1]), a(m[l + 1][u + 1]), a(m[l + 1][u])) } }(o = o || 0), function (t) { for (var e = new r, i = 0; i < h.length; i += 3)e.x = h[i + 0], e.y = h[i + 1], e.z = h[i + 2], e.normalize().multiplyScalar(t), h[i + 0] = e.x, h[i + 1] = e.y, h[i + 2] = e.z }(n), function () { for (var t = new r, e = 0; e < h.length; e += 3)t.x = h[e + 0], t.y = h[e + 1], t.z = h[e + 2], l.push(Math.atan2(t.z, -t.x) / 2 / Math.PI + .5, 1 - (Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI + .5)); t = new r, e = new r; for (var n = new r, o = new r, a = new i, s = new i, u = new i, d = 0, p = 0; d < h.length; d += 9, p += 6) { t.set(h[d + 0], h[d + 1], h[d + 2]), e.set(h[d + 3], h[d + 4], h[d + 5]), n.set(h[d + 6], h[d + 7], h[d + 8]), a.set(l[p + 0], l[p + 1]), s.set(l[p + 2], l[p + 3]), u.set(l[p + 4], l[p + 5]), o.copy(t).add(e).add(n).divideScalar(3); var f = Math.atan2(o.z, -o.x); c(a, p + 0, t, f), c(s, p + 2, e, f), c(u, p + 4, n, f) } for (t = 0; t < l.length; t += 6)e = l[t + 0], n = l[t + 2], o = l[t + 4], a = Math.min(e, n, o), .9 < Math.max(e, n, o) && .1 > a && (.2 > e && (l[t + 0] += 1), .2 > n && (l[t + 2] += 1), .2 > o && (l[t + 4] += 1)) }(), this.addAttribute("position", new N(h, 3)), this.addAttribute("normal", new N(h.slice(), 3)), this.addAttribute("uv", new N(l, 2)), 0 === o ? this.computeVertexNormals() : this.normalizeNormals() } function $e(t, e) { T.call(this), this.type = "TetrahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ti(t, e)), this.mergeVertices() } function ti(t, e) { Ke.call(this, [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1], [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1], t, e), this.type = "TetrahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function ei(t, e) { T.call(this), this.type = "OctahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ii(t, e)), this.mergeVertices() } function ii(t, e) { Ke.call(this, [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1], [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2], t, e), this.type = "OctahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function ni(t, e) { T.call(this), this.type = "IcosahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ri(t, e)), this.mergeVertices() } function ri(t, e) { var i = (1 + Math.sqrt(5)) / 2; Ke.call(this, [-1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, 0, 0, -1, i, 0, 1, i, 0, -1, -i, 0, 1, -i, i, 0, -1, i, 0, 1, -i, 0, -1, -i, 0, 1], [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1], t, e), this.type = "IcosahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function oi(t, e) { T.call(this), this.type = "DodecahedronGeometry", this.parameters = { radius: t, detail: e }, this.fromBufferGeometry(new ai(t, e)), this.mergeVertices() } function ai(t, e) { var i = (1 + Math.sqrt(5)) / 2, n = 1 / i; Ke.call(this, [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, -n, -i, 0, -n, i, 0, n, -i, 0, n, i, 0, -i, 0, -n, i, 0, -n, -i, 0, n, i, 0, n], [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9], t, e), this.type = "DodecahedronBufferGeometry", this.parameters = { radius: t, detail: e } } function si(t, e, i, n, r, o) { T.call(this), this.type = "TubeGeometry", this.parameters = { path: t, tubularSegments: e, radius: i, radialSegments: n, closed: r }, void 0 !== o && console.warn("THREE.TubeGeometry: taper has been removed."), t = new ci(t, e, i, n, r), this.tangents = t.tangents, this.normals = t.normals, this.binormals = t.binormals, this.fromBufferGeometry(t), this.mergeVertices() } function ci(t, e, n, o, a) { function s(i) { f = t.getPointAt(i / e, f); var r = c.normals[i]; for (i = c.binormals[i], l = 0; l <= o; l++) { var a = l / o * Math.PI * 2, s = Math.sin(a); a = -Math.cos(a), d.x = a * r.x + s * i.x, d.y = a * r.y + s * i.y, d.z = a * r.z + s * i.z, d.normalize(), g.push(d.x, d.y, d.z), u.x = f.x + n * d.x, u.y = f.y + n * d.y, u.z = f.z + n * d.z, m.push(u.x, u.y, u.z) } } F.call(this), this.type = "TubeBufferGeometry", this.parameters = { path: t, tubularSegments: e, radius: n, radialSegments: o, closed: a }, e = e || 64, n = n || 1, o = o || 8, a = a || !1; var c = t.computeFrenetFrames(e, a); this.tangents = c.tangents, this.normals = c.normals, this.binormals = c.binormals; var h, l, u = new r, d = new r, p = new i, f = new r, m = [], g = [], v = [], y = []; for (h = 0; h < e; h++)s(h); for (s(!1 === a ? e : 0), h = 0; h <= e; h++)for (l = 0; l <= o; l++)p.x = h / e, p.y = l / o, v.push(p.x, p.y); !function () { for (l = 1; l <= e; l++)for (h = 1; h <= o; h++) { var t = (o + 1) * l + (h - 1), i = (o + 1) * l + h, n = (o + 1) * (l - 1) + h; y.push((o + 1) * (l - 1) + (h - 1), t, n), y.push(t, i, n) } }(), this.setIndex(y), this.addAttribute("position", new N(m, 3)), this.addAttribute("normal", new N(g, 3)), this.addAttribute("uv", new N(v, 2)) } function hi(t, e, i, n, r, o, a) { T.call(this), this.type = "TorusKnotGeometry", this.parameters = { radius: t, tube: e, tubularSegments: i, radialSegments: n, p: r, q: o }, void 0 !== a && console.warn("THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead."), this.fromBufferGeometry(new li(t, e, i, n, r, o)), this.mergeVertices() } function li(t, e, i, n, o, a) { function s(t, e, i, n, r) { var o = Math.sin(t); e = i / e * t, i = Math.cos(e), r.x = n * (2 + i) * .5 * Math.cos(t), r.y = n * (2 + i) * o * .5, r.z = n * Math.sin(e) * .5 } F.call(this), this.type = "TorusKnotBufferGeometry", this.parameters = { radius: t, tube: e, tubularSegments: i, radialSegments: n, p: o, q: a }, t = t || 1, e = e || .4, i = Math.floor(i) || 64, n = Math.floor(n) || 8, o = o || 2, a = a || 3; var c, h = [], l = [], u = [], d = [], p = new r, f = new r, m = new r, g = new r, v = new r, y = new r, x = new r; for (c = 0; c <= i; ++c) { var b = c / i * o * Math.PI * 2; for (s(b, o, a, t, m), s(b + .01, o, a, t, g), y.subVectors(g, m), x.addVectors(g, m), v.crossVectors(y, x), x.crossVectors(v, y), v.normalize(), x.normalize(), b = 0; b <= n; ++b) { var w = b / n * Math.PI * 2, M = -e * Math.cos(w); w = e * Math.sin(w), p.x = m.x + (M * x.x + w * v.x), p.y = m.y + (M * x.y + w * v.y), p.z = m.z + (M * x.z + w * v.z), l.push(p.x, p.y, p.z), f.subVectors(p, m).normalize(), u.push(f.x, f.y, f.z), d.push(c / i), d.push(b / n) } } for (b = 1; b <= i; b++)for (c = 1; c <= n; c++)t = (n + 1) * b + (c - 1), e = (n + 1) * b + c, o = (n + 1) * (b - 1) + c, h.push((n + 1) * (b - 1) + (c - 1), t, o), h.push(t, e, o); this.setIndex(h), this.addAttribute("position", new N(l, 3)), this.addAttribute("normal", new N(u, 3)), this.addAttribute("uv", new N(d, 2)) } function ui(t, e, i, n, r) { T.call(this), this.type = "TorusGeometry", this.parameters = { radius: t, tube: e, radialSegments: i, tubularSegments: n, arc: r }, this.fromBufferGeometry(new di(t, e, i, n, r)), this.mergeVertices() } function di(t, e, i, n, o) { F.call(this), this.type = "TorusBufferGeometry", this.parameters = { radius: t, tube: e, radialSegments: i, tubularSegments: n, arc: o }, t = t || 1, e = e || .4, i = Math.floor(i) || 8, n = Math.floor(n) || 6, o = o || 2 * Math.PI; var a, s, c = [], h = [], l = [], u = [], d = new r, p = new r, f = new r; for (a = 0; a <= i; a++)for (s = 0; s <= n; s++) { var m = s / n * o, g = a / i * Math.PI * 2; p.x = (t + e * Math.cos(g)) * Math.cos(m), p.y = (t + e * Math.cos(g)) * Math.sin(m), p.z = e * Math.sin(g), h.push(p.x, p.y, p.z), d.x = t * Math.cos(m), d.y = t * Math.sin(m), f.subVectors(p, d).normalize(), l.push(f.x, f.y, f.z), u.push(s / n), u.push(a / i) } for (a = 1; a <= i; a++)for (s = 1; s <= n; s++)t = (n + 1) * (a - 1) + s - 1, e = (n + 1) * (a - 1) + s, o = (n + 1) * a + s, c.push((n + 1) * a + s - 1, t, o), c.push(t, e, o); this.setIndex(c), this.addAttribute("position", new N(h, 3)), this.addAttribute("normal", new N(l, 3)), this.addAttribute("uv", new N(u, 2)) } function pi(t, e, i, n, r) { for (var o, a = 0, s = e, c = i - n; s < i; s += n)a += (t[c] - t[s]) * (t[s + 1] + t[c + 1]), c = s; if (r === 0 < a) for (r = e; r < i; r += n)o = Ti(r, t[r], t[r + 1], o); else for (r = i - n; r >= e; r -= n)o = Ti(r, t[r], t[r + 1], o); return o && Mi(o, o.next) && (Si(o), o = o.next), o } function fi(t, e) { if (!t) return t; e || (e = t); do { var i = !1; if (t.steiner || !Mi(t, t.next) && 0 !== wi(t.prev, t, t.next)) t = t.next; else { if (Si(t), (t = e = t.prev) === t.next) break; i = !0 } } while (i || t !== e); return e } function mi(t, e, i, n, r, o, a) { if (t) { if (!a && o) { var s = t, c = s; do { null === c.z && (c.z = yi(c.x, c.y, n, r, o)), c.prevZ = c.prev, c = c.nextZ = c.next } while (c !== s); c.prevZ.nextZ = null, c.prevZ = null, s = c; var h, l, u, d, p = 1; do { c = s; var f = s = null; for (l = 0; c;) { l++; var m = c; for (h = u = 0; h < p && (u++, m = m.nextZ); h++); for (d = p; 0 < u || 0 < d && m;)0 !== u && (0 === d || !m || c.z <= m.z) ? (h = c, c = c.nextZ, u--) : (h = m, m = m.nextZ, d--), f ? f.nextZ = h : s = h, h.prevZ = f, f = h; c = m } f.nextZ = null, p *= 2 } while (1 < l) } for (s = t; t.prev !== t.next;) { if (c = t.prev, m = t.next, o) t: { d = n; var g = r, v = o; if (0 <= wi(l = (f = t).prev, u = f, p = f.next)) f = !1; else { var y = l.x > u.x ? l.x > p.x ? l.x : p.x : u.x > p.x ? u.x : p.x, x = l.y > u.y ? l.y > p.y ? l.y : p.y : u.y > p.y ? u.y : p.y; for (h = yi(l.x < u.x ? l.x < p.x ? l.x : p.x : u.x < p.x ? u.x : p.x, l.y < u.y ? l.y < p.y ? l.y : p.y : u.y < p.y ? u.y : p.y, d, g, v), d = yi(y, x, d, g, v), g = f.nextZ; g && g.z <= d;) { if (g !== f.prev && g !== f.next && bi(l.x, l.y, u.x, u.y, p.x, p.y, g.x, g.y) && 0 <= wi(g.prev, g, g.next)) { f = !1; break t } g = g.nextZ } for (g = f.prevZ; g && g.z >= h;) { if (g !== f.prev && g !== f.next && bi(l.x, l.y, u.x, u.y, p.x, p.y, g.x, g.y) && 0 <= wi(g.prev, g, g.next)) { f = !1; break t } g = g.prevZ } f = !0 } } else t: if (f = t, l = f.prev, u = f, p = f.next, 0 <= wi(l, u, p)) f = !1; else { for (h = f.next.next; h !== f.prev;) { if (bi(l.x, l.y, u.x, u.y, p.x, p.y, h.x, h.y) && 0 <= wi(h.prev, h, h.next)) { f = !1; break t } h = h.next } f = !0 } if (f) e.push(c.i / i), e.push(t.i / i), e.push(m.i / i), Si(t), s = t = m.next; else if ((t = m) === s) { if (a) { if (1 === a) { a = e, s = i, c = t; do { !Mi(m = c.prev, f = c.next.next) && _i(m, c, c.next, f) && Ei(m, f) && Ei(f, m) && (a.push(m.i / s), a.push(c.i / s), a.push(f.i / s), Si(c), Si(c.next), c = t = f), c = c.next } while (c !== t); mi(t = c, e, i, n, r, o, 2) } else if (2 === a) t: { a = t; do { for (s = a.next.next; s !== a.prev;) { if (c = a.i !== s.i) { if (m = s, f = (c = a).next.i !== m.i && c.prev.i !== m.i) { e: { f = c; do { if (f.i !== c.i && f.next.i !== c.i && f.i !== m.i && f.next.i !== m.i && _i(f, f.next, c, m)) { f = !0; break e } f = f.next } while (f !== c); f = !1 } f = !f } if (f = f && Ei(c, m) && Ei(m, c)) { f = c, l = !1, u = (c.x + m.x) / 2, m = (c.y + m.y) / 2; do { f.y > m != f.next.y > m && f.next.y !== f.y && u < (f.next.x - f.x) * (m - f.y) / (f.next.y - f.y) + f.x && (l = !l), f = f.next } while (f !== c); f = l } c = f } if (c) { t = Ai(a, s), a = fi(a, a.next), t = fi(t, t.next), mi(a, e, i, n, r, o), mi(t, e, i, n, r, o); break t } s = s.next } a = a.next } while (a !== t) } } else mi(fi(t), e, i, n, r, o, 1); break } } } } function gi(t, e) { return t.x - e.x } function vi(t, e) { var i = e, n = t.x, r = t.y, o = -1 / 0; do { if (r <= i.y && r >= i.next.y && i.next.y !== i.y) { var a = i.x + (r - i.y) * (i.next.x - i.x) / (i.next.y - i.y); if (a <= n && a > o) { if (o = a, a === n) { if (r === i.y) return i; if (r === i.next.y) return i.next } var s = i.x < i.next.x ? i : i.next } } i = i.next } while (i !== e); if (!s) return null; if (n === o) return s.prev; e = s, a = s.x; var c = s.y, h = 1 / 0; for (i = s.next; i !== e;) { if (n >= i.x && i.x >= a && n !== i.x && bi(r < c ? n : o, r, a, c, r < c ? o : n, r, i.x, i.y)) { var l = Math.abs(r - i.y) / (n - i.x); (l < h || l === h && i.x > s.x) && Ei(i, t) && (s = i, h = l) } i = i.next } return s } function yi(t, e, i, n, r) { return 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * r) | t << 8)) | t << 4)) | t << 2)) | t << 1) | (1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * r) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1 } function xi(t) { var e = t, i = t; do { e.x < i.x && (i = e), e = e.next } while (e !== t); return i } function bi(t, e, i, n, r, o, a, s) { return 0 <= (r - a) * (e - s) - (t - a) * (o - s) && 0 <= (t - a) * (n - s) - (i - a) * (e - s) && 0 <= (i - a) * (o - s) - (r - a) * (n - s) } function wi(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y) } function Mi(t, e) { return t.x === e.x && t.y === e.y } function _i(t, e, i, n) { return !!(Mi(t, e) && Mi(i, n) || Mi(t, n) && Mi(i, e)) || 0 < wi(t, e, i) != 0 < wi(t, e, n) && 0 < wi(i, n, t) != 0 < wi(i, n, e) } function Ei(t, e) { return 0 > wi(t.prev, t, t.next) ? 0 <= wi(t, e, t.next) && 0 <= wi(t, t.prev, e) : 0 > wi(t, e, t.prev) || 0 > wi(t, t.next, e) } function Ai(t, e) { var i = new Li(t.i, t.x, t.y), n = new Li(e.i, e.x, e.y), r = t.next, o = e.prev; return t.next = e, e.prev = t, i.next = r, r.prev = i, n.next = i, i.prev = n, o.next = n, n.prev = o, n } function Ti(t, e, i, n) { return t = new Li(t, e, i), n ? (t.next = n.next, t.prev = n, n.next.prev = t, n.next = t) : (t.prev = t, t.next = t), t } function Si(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ) } function Li(t, e, i) { this.i = t, this.x = e, this.y = i, this.nextZ = this.prevZ = this.z = this.next = this.prev = null, this.steiner = !1 } function Ci(t) { var e = t.length; 2 < e && t[e - 1].equals(t[0]) && t.pop() } function Ri(t, e) { for (var i = 0; i < e.length; i++)t.push(e[i].x), t.push(e[i].y) } function Pi(t, e) { T.call(this), this.type = "ExtrudeGeometry", this.parameters = { shapes: t, options: e }, this.fromBufferGeometry(new Ii(t, e)), this.mergeVertices() } function Ii(t, e) { function n(t) { function n(t, e, i) { return e || console.error("THREE.ExtrudeGeometry: vec does not exist"), e.clone().multiplyScalar(i).add(t) } function c(t, e, n) { var r = t.x - e.x, o = t.y - e.y, a = n.x - t.x, s = n.y - t.y, c = r * r + o * o; if (Math.abs(r * s - o * a) > Number.EPSILON) { var h = Math.sqrt(c), l = Math.sqrt(a * a + s * s); if (c = e.x - o / h, e = e.y + r / h, 2 >= (o = (a = c + r * (s = ((n.x - s / l - c) * s - (n.y + a / l - e) * a) / (r * s - o * a)) - t.x) * a + (r = e + o * s - t.y) * r)) return new i(a, r); o = Math.sqrt(o / 2) } else t = !1, r > Number.EPSILON ? a > Number.EPSILON && (t = !0) : r < -Number.EPSILON ? a < -Number.EPSILON && (t = !0) : Math.sign(o) === Math.sign(s) && (t = !0), t ? (a = -o, o = Math.sqrt(c)) : (a = r, r = o, o = Math.sqrt(c / 2)); return new i(a / o, r / o) } function h(t, e) { for (H = t.length; 0 <= --H;) { var i = H, n = H - 1; 0 > n && (n = t.length - 1); var r, s = g + 2 * M; for (r = 0; r < s; r++) { var c = F * r, h = F * (r + 1), l = e + n + c, u = e + n + h; h = e + i + h, d(e + i + c), d(l), d(h), d(l), d(u), d(h), c = a.length / 3, p((c = E.generateSideWallUV(o, a, c - 6, c - 3, c - 2, c - 1))[0]), p(c[1]), p(c[3]), p(c[1]), p(c[2]), p(c[3]) } } } function l(t, e, i) { f.push(t), f.push(e), f.push(i) } function u(t, e, i) { d(t), d(e), d(i), t = a.length / 3, p((t = E.generateTopUV(o, a, t - 3, t - 2, t - 1))[0]), p(t[1]), p(t[2]) } function d(t) { a.push(f[3 * t]), a.push(f[3 * t + 1]), a.push(f[3 * t + 2]) } function p(t) { s.push(t.x), s.push(t.y) } var f = [], m = void 0 !== e.curveSegments ? e.curveSegments : 12, g = void 0 !== e.steps ? e.steps : 1, v = void 0 !== e.depth ? e.depth : 100, y = void 0 === e.bevelEnabled || e.bevelEnabled, x = void 0 !== e.bevelThickness ? e.bevelThickness : 6, b = void 0 !== e.bevelSize ? e.bevelSize : x - 2, w = void 0 !== e.bevelOffset ? e.bevelOffset : 0, M = void 0 !== e.bevelSegments ? e.bevelSegments : 3, _ = e.extrudePath, E = void 0 !== e.UVGenerator ? e.UVGenerator : jo; void 0 !== e.amount && (console.warn("THREE.ExtrudeBufferGeometry: amount has been renamed to depth."), v = e.amount); var A, T = !1; if (_) { var S = _.getSpacedPoints(g); T = !0, y = !1; var L = _.computeFrenetFrames(g, !1), C = new r, R = new r, P = new r } y || (w = b = x = M = 0), m = t.extractPoints(m), t = m.shape; var I = m.holes; if (!Vo.isClockWise(t)) { t = t.reverse(); var O = 0; for (A = I.length; O < A; O++) { var D = I[O]; Vo.isClockWise(D) && (I[O] = D.reverse()) } } var N = Vo.triangulateShape(t, I), B = t; for (O = 0, A = I.length; O < A; O++)D = I[O], t = t.concat(D); var z, U, F = t.length, G = N.length; m = []; var H = 0, k = B.length, V = k - 1; for (z = H + 1; H < k; H++, V++, z++)V === k && (V = 0), z === k && (z = 0), m[H] = c(B[H], B[V], B[z]); _ = []; var j = m.concat(); for (O = 0, A = I.length; O < A; O++) { D = I[O]; var W = []; for (H = 0, V = (k = D.length) - 1, z = H + 1; H < k; H++, V++, z++)V === k && (V = 0), z === k && (z = 0), W[H] = c(D[H], D[V], D[z]); _.push(W), j = j.concat(W) } for (V = 0; V < M; V++) { k = V / M; var q = x * Math.cos(k * Math.PI / 2); for (z = b * Math.sin(k * Math.PI / 2) + w, H = 0, k = B.length; H < k; H++) { var X = n(B[H], m[H], z); l(X.x, X.y, -q) } for (O = 0, A = I.length; O < A; O++)for (D = I[O], W = _[O], H = 0, k = D.length; H < k; H++)l((X = n(D[H], W[H], z)).x, X.y, -q) } for (z = b + w, H = 0; H < F; H++)X = y ? n(t[H], j[H], z) : t[H], T ? (R.copy(L.normals[0]).multiplyScalar(X.x), C.copy(L.binormals[0]).multiplyScalar(X.y), P.copy(S[0]).add(R).add(C), l(P.x, P.y, P.z)) : l(X.x, X.y, 0); for (k = 1; k <= g; k++)for (H = 0; H < F; H++)X = y ? n(t[H], j[H], z) : t[H], T ? (R.copy(L.normals[k]).multiplyScalar(X.x), C.copy(L.binormals[k]).multiplyScalar(X.y), P.copy(S[k]).add(R).add(C), l(P.x, P.y, P.z)) : l(X.x, X.y, v / g * k); for (V = M - 1; 0 <= V; V--) { for (k = V / M, q = x * Math.cos(k * Math.PI / 2), z = b * Math.sin(k * Math.PI / 2) + w, H = 0, k = B.length; H < k; H++)l((X = n(B[H], m[H], z)).x, X.y, v + q); for (O = 0, A = I.length; O < A; O++)for (D = I[O], W = _[O], H = 0, k = D.length; H < k; H++)X = n(D[H], W[H], z), T ? l(X.x, X.y + S[g - 1].y, S[g - 1].x + q) : l(X.x, X.y, v + q) } !function () { var t = a.length / 3; if (y) { var e = 0 * F; for (H = 0; H < G; H++)u((U = N[H])[2] + e, U[1] + e, U[0] + e); for (e = F * (g + 2 * M), H = 0; H < G; H++)u((U = N[H])[0] + e, U[1] + e, U[2] + e) } else { for (H = 0; H < G; H++)u((U = N[H])[2], U[1], U[0]); for (H = 0; H < G; H++)u((U = N[H])[0] + F * g, U[1] + F * g, U[2] + F * g) } o.addGroup(t, a.length / 3 - t, 0) }(), function () { var t = a.length / 3, e = 0; for (h(B, e), e += B.length, O = 0, A = I.length; O < A; O++)h(D = I[O], e), e += D.length; o.addGroup(t, a.length / 3 - t, 1) }() } F.call(this), this.type = "ExtrudeBufferGeometry", this.parameters = { shapes: t, options: e }, t = Array.isArray(t) ? t : [t]; for (var o = this, a = [], s = [], c = 0, h = t.length; c < h; c++)n(t[c]); this.addAttribute("position", new N(a, 3)), this.addAttribute("uv", new N(s, 2)), this.computeVertexNormals() } function Oi(t, e, i) { if (i.shapes = [], Array.isArray(t)) for (var n = 0, r = t.length; n < r; n++)i.shapes.push(t[n].uuid); else i.shapes.push(t.uuid); return void 0 !== e.extrudePath && (i.options.extrudePath = e.extrudePath.toJSON()), i } function Di(t, e) { T.call(this), this.type = "TextGeometry", this.parameters = { text: t, parameters: e }, this.fromBufferGeometry(new Ni(t, e)), this.mergeVertices() } function Ni(t, e) { var i = (e = e || {}).font; if (!i || !i.isFont) return console.error("THREE.TextGeometry: font parameter is not an instance of THREE.Font."), new T; t = i.generateShapes(t, e.size), e.depth = void 0 !== e.height ? e.height : 50, void 0 === e.bevelThickness && (e.bevelThickness = 10), void 0 === e.bevelSize && (e.bevelSize = 8), void 0 === e.bevelEnabled && (e.bevelEnabled = !1), Ii.call(this, t, e), this.type = "TextBufferGeometry" } function Bi(t, e, i, n, r, o, a) { T.call(this), this.type = "SphereGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: i, phiStart: n, phiLength: r, thetaStart: o, thetaLength: a }, this.fromBufferGeometry(new zi(t, e, i, n, r, o, a)), this.mergeVertices() } function zi(t, e, i, n, o, a, s) { F.call(this), this.type = "SphereBufferGeometry", this.parameters = { radius: t, widthSegments: e, heightSegments: i, phiStart: n, phiLength: o, thetaStart: a, thetaLength: s }, t = t || 1, e = Math.max(3, Math.floor(e) || 8), i = Math.max(2, Math.floor(i) || 6), n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : Math.PI; var c, h, l = Math.min(a + s, Math.PI), u = 0, d = [], p = new r, f = new r, m = [], g = [], v = [], y = []; for (h = 0; h <= i; h++) { var x = [], b = h / i, w = 0; for (0 == h && 0 == a ? w = .5 / e : h == i && l == Math.PI && (w = -.5 / e), c = 0; c <= e; c++) { var M = c / e; p.x = -t * Math.cos(n + M * o) * Math.sin(a + b * s), p.y = t * Math.cos(a + b * s), p.z = t * Math.sin(n + M * o) * Math.sin(a + b * s), g.push(p.x, p.y, p.z), f.copy(p).normalize(), v.push(f.x, f.y, f.z), y.push(M + w, 1 - b), x.push(u++) } d.push(x) } for (h = 0; h < i; h++)for (c = 0; c < e; c++)t = d[h][c + 1], n = d[h][c], o = d[h + 1][c], s = d[h + 1][c + 1], (0 !== h || 0 < a) && m.push(t, n, s), (h !== i - 1 || l < Math.PI) && m.push(n, o, s); this.setIndex(m), this.addAttribute("position", new N(g, 3)), this.addAttribute("normal", new N(v, 3)), this.addAttribute("uv", new N(y, 2)) } function Ui(t, e, i, n, r, o) { T.call(this), this.type = "RingGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: i, phiSegments: n, thetaStart: r, thetaLength: o }, this.fromBufferGeometry(new Fi(t, e, i, n, r, o)), this.mergeVertices() } function Fi(t, e, n, o, a, s) { F.call(this), this.type = "RingBufferGeometry", this.parameters = { innerRadius: t, outerRadius: e, thetaSegments: n, phiSegments: o, thetaStart: a, thetaLength: s }, t = t || .5, e = e || 1, a = void 0 !== a ? a : 0, s = void 0 !== s ? s : 2 * Math.PI, n = void 0 !== n ? Math.max(3, n) : 8; var c, h, l = [], u = [], d = [], p = [], f = t, m = (e - t) / (o = void 0 !== o ? Math.max(1, o) : 1), g = new r, v = new i; for (c = 0; c <= o; c++) { for (h = 0; h <= n; h++)t = a + h / n * s, g.x = f * Math.cos(t), g.y = f * Math.sin(t), u.push(g.x, g.y, g.z), d.push(0, 0, 1), v.x = (g.x / e + 1) / 2, v.y = (g.y / e + 1) / 2, p.push(v.x, v.y); f += m } for (c = 0; c < o; c++)for (e = c * (n + 1), h = 0; h < n; h++)a = (t = h + e) + n + 1, s = t + n + 2, f = t + 1, l.push(t, a, f), l.push(a, s, f); this.setIndex(l), this.addAttribute("position", new N(u, 3)), this.addAttribute("normal", new N(d, 3)), this.addAttribute("uv", new N(p, 2)) } function Gi(t, e, i, n) { T.call(this), this.type = "LatheGeometry", this.parameters = { points: t, segments: e, phiStart: i, phiLength: n }, this.fromBufferGeometry(new Hi(t, e, i, n)), this.mergeVertices() } function Hi(t, e, n, o) { F.call(this), this.type = "LatheBufferGeometry", this.parameters = { points: t, segments: e, phiStart: n, phiLength: o }, e = Math.floor(e) || 12, n = n || 0, o = o || 2 * Math.PI, o = fo.clamp(o, 0, 2 * Math.PI); var a, s = [], c = [], h = [], l = 1 / e, u = new r, d = new i; for (a = 0; a <= e; a++) { var p = n + a * l * o, f = Math.sin(p), m = Math.cos(p); for (p = 0; p <= t.length - 1; p++)u.x = t[p].x * f, u.y = t[p].y, u.z = t[p].x * m, c.push(u.x, u.y, u.z), d.x = a / e, d.y = p / (t.length - 1), h.push(d.x, d.y) } for (a = 0; a < e; a++)for (p = 0; p < t.length - 1; p++)l = (n = p + a * t.length) + t.length, u = n + t.length + 1, d = n + 1, s.push(n, l, d), s.push(l, u, d); if (this.setIndex(s), this.addAttribute("position", new N(c, 3)), this.addAttribute("uv", new N(h, 2)), this.computeVertexNormals(), o === 2 * Math.PI) for (o = this.attributes.normal.array, s = new r, c = new r, h = new r, n = e * t.length * 3, p = a = 0; a < t.length; a++, p += 3)s.x = o[p + 0], s.y = o[p + 1], s.z = o[p + 2], c.x = o[n + p + 0], c.y = o[n + p + 1], c.z = o[n + p + 2], h.addVectors(s, c).normalize(), o[p + 0] = o[n + p + 0] = h.x, o[p + 1] = o[n + p + 1] = h.y, o[p + 2] = o[n + p + 2] = h.z } function ki(t, e) { T.call(this), this.type = "ShapeGeometry", "object" == typeof e && (console.warn("THREE.ShapeGeometry: Options parameter has been removed."), e = e.curveSegments), this.parameters = { shapes: t, curveSegments: e }, this.fromBufferGeometry(new Vi(t, e)), this.mergeVertices() } function Vi(t, e) { function i(t) { var i, s = r.length / 3, h = (t = t.extractPoints(e)).shape, l = t.holes; for (!1 === Vo.isClockWise(h) && (h = h.reverse()), t = 0, i = l.length; t < i; t++) { var u = l[t]; !0 === Vo.isClockWise(u) && (l[t] = u.reverse()) } var d = Vo.triangulateShape(h, l); for (t = 0, i = l.length; t < i; t++)u = l[t], h = h.concat(u); for (t = 0, i = h.length; t < i; t++)u = h[t], r.push(u.x, u.y, 0), o.push(0, 0, 1), a.push(u.x, u.y); for (t = 0, i = d.length; t < i; t++)h = d[t], n.push(h[0] + s, h[1] + s, h[2] + s), c += 3 } F.call(this), this.type = "ShapeBufferGeometry", this.parameters = { shapes: t, curveSegments: e }, e = e || 12; var n = [], r = [], o = [], a = [], s = 0, c = 0; if (!1 === Array.isArray(t)) i(t); else for (var h = 0; h < t.length; h++)i(t[h]), this.addGroup(s, c, h), s += c, c = 0; this.setIndex(n), this.addAttribute("position", new N(r, 3)), this.addAttribute("normal", new N(o, 3)), this.addAttribute("uv", new N(a, 2)) } function ji(t, e) { if (e.shapes = [], Array.isArray(t)) for (var i = 0, n = t.length; i < n; i++)e.shapes.push(t[i].uuid); else e.shapes.push(t.uuid); return e } function Wi(t, e) { F.call(this), this.type = "EdgesGeometry", this.parameters = { thresholdAngle: e }; var i = []; e = Math.cos(fo.DEG2RAD * (void 0 !== e ? e : 1)); var n = [0, 0], r = {}, o = ["a", "b", "c"]; if (t.isBufferGeometry) { var a = new T; a.fromBufferGeometry(t) } else a = t.clone(); a.mergeVertices(), a.computeFaceNormals(), t = a.vertices; for (var s = 0, c = (a = a.faces).length; s < c; s++)for (var h = a[s], l = 0; 3 > l; l++) { var u = h[o[l]], d = h[o[(l + 1) % 3]]; n[0] = Math.min(u, d), n[1] = Math.max(u, d), void 0 === r[u = n[0] + "," + n[1]] ? r[u] = { index1: n[0], index2: n[1], face1: s, face2: void 0 } : r[u].face2 = s } for (u in r) (void 0 === (n = r[u]).face2 || a[n.face1].normal.dot(a[n.face2].normal) <= e) && (o = t[n.index1], i.push(o.x, o.y, o.z), o = t[n.index2], i.push(o.x, o.y, o.z)); this.addAttribute("position", new N(i, 3)) } function qi(t, e, i, n, r, o, a, s) { T.call(this), this.type = "CylinderGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: i, radialSegments: n, heightSegments: r, openEnded: o, thetaStart: a, thetaLength: s }, this.fromBufferGeometry(new Xi(t, e, i, n, r, o, a, s)), this.mergeVertices() } function Xi(t, e, n, o, a, s, c, h) { function l(n) { var a, s = new i, l = new r, v = 0, b = !0 === n ? t : e, w = !0 === n ? 1 : -1, M = g; for (a = 1; a <= o; a++)p.push(0, y * w, 0), f.push(0, w, 0), m.push(.5, .5), g++; var _ = g; for (a = 0; a <= o; a++) { var E = a / o * h + c, A = Math.cos(E); E = Math.sin(E), l.x = b * E, l.y = y * w, l.z = b * A, p.push(l.x, l.y, l.z), f.push(0, w, 0), s.x = .5 * A + .5, s.y = .5 * E * w + .5, m.push(s.x, s.y), g++ } for (a = 0; a < o; a++)s = M + a, l = _ + a, !0 === n ? d.push(l, l + 1, s) : d.push(l + 1, l, s), v += 3; u.addGroup(x, v, !0 === n ? 1 : 2), x += v } F.call(this), this.type = "CylinderBufferGeometry", this.parameters = { radiusTop: t, radiusBottom: e, height: n, radialSegments: o, heightSegments: a, openEnded: s, thetaStart: c, thetaLength: h }; var u = this; t = void 0 !== t ? t : 1, e = void 0 !== e ? e : 1, n = n || 1, o = Math.floor(o) || 8, a = Math.floor(a) || 1, s = void 0 !== s && s, c = void 0 !== c ? c : 0, h = void 0 !== h ? h : 2 * Math.PI; var d = [], p = [], f = [], m = [], g = 0, v = [], y = n / 2, x = 0; !function () { var i, s, l = new r, b = new r, w = 0, M = (e - t) / n; for (s = 0; s <= a; s++) { var _ = [], E = s / a, A = E * (e - t) + t; for (i = 0; i <= o; i++) { var T = i / o, S = T * h + c, L = Math.sin(S); S = Math.cos(S), b.x = A * L, b.y = -E * n + y, b.z = A * S, p.push(b.x, b.y, b.z), l.set(L, M, S).normalize(), f.push(l.x, l.y, l.z), m.push(T, 1 - E), _.push(g++) } v.push(_) } for (i = 0; i < o; i++)for (s = 0; s < a; s++)l = v[s + 1][i], b = v[s + 1][i + 1], M = v[s][i + 1], d.push(v[s][i], l, M), d.push(l, b, M), w += 6; u.addGroup(x, w, 0), x += w }(), !1 === s && (0 < t && l(!0), 0 < e && l(!1)), this.setIndex(d), this.addAttribute("position", new N(p, 3)), this.addAttribute("normal", new N(f, 3)), this.addAttribute("uv", new N(m, 2)) } function Yi(t, e, i, n, r, o, a) { qi.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeGeometry", this.parameters = { radius: t, height: e, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: o, thetaLength: a } } function Zi(t, e, i, n, r, o, a) { Xi.call(this, 0, t, e, i, n, r, o, a), this.type = "ConeBufferGeometry", this.parameters = { radius: t, height: e, radialSegments: i, heightSegments: n, openEnded: r, thetaStart: o, thetaLength: a } } function Ji(t, e, i, n) { T.call(this), this.type = "CircleGeometry", this.parameters = { radius: t, segments: e, thetaStart: i, thetaLength: n }, this.fromBufferGeometry(new Qi(t, e, i, n)), this.mergeVertices() } function Qi(t, e, n, o) { F.call(this), this.type = "CircleBufferGeometry", this.parameters = { radius: t, segments: e, thetaStart: n, thetaLength: o }, t = t || 1, e = void 0 !== e ? Math.max(3, e) : 8, n = void 0 !== n ? n : 0, o = void 0 !== o ? o : 2 * Math.PI; var a, s = [], c = [], h = [], l = [], u = new r, d = new i; c.push(0, 0, 0), h.push(0, 0, 1), l.push(.5, .5); var p = 0; for (a = 3; p <= e; p++, a += 3) { var f = n + p / e * o; u.x = t * Math.cos(f), u.y = t * Math.sin(f), c.push(u.x, u.y, u.z), h.push(0, 0, 1), d.x = (c[a] / t + 1) / 2, d.y = (c[a + 1] / t + 1) / 2, l.push(d.x, d.y) } for (a = 1; a <= e; a++)s.push(a, a + 1, 0); this.setIndex(s), this.addAttribute("position", new N(c, 3)), this.addAttribute("normal", new N(h, 3)), this.addAttribute("uv", new N(l, 2)) } function Ki(t) { j.call(this), this.type = "ShadowMaterial", this.color = new x(0), this.transparent = !0, this.setValues(t) } function $i(t) { W.call(this, t), this.type = "RawShaderMaterial" } function tn(t) { j.call(this), this.defines = { STANDARD: "" }, this.type = "MeshStandardMaterial", this.color = new x(16777215), this.metalness = this.roughness = .5, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.metalnessMap = this.roughnessMap = null, this.envMapIntensity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t) } function en(t) { tn.call(this), this.defines = { PHYSICAL: "" }, this.type = "MeshPhysicalMaterial", this.reflectivity = .5, this.clearCoatRoughness = this.clearCoat = 0, this.setValues(t) } function nn(t) { j.call(this), this.type = "MeshPhongMaterial", this.color = new x(16777215), this.specular = new x(1118481), this.shininess = 30, this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.bumpMap = this.emissiveMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.envMap = this.alphaMap = this.specularMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t) } function rn(t) { nn.call(this), this.defines = { TOON: "" }, this.type = "MeshToonMaterial", this.gradientMap = null, this.setValues(t) } function on(t) { j.call(this), this.type = "MeshNormalMaterial", this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.morphNormals = this.morphTargets = this.skinning = this.lights = this.fog = !1, this.setValues(t) } function an(t) { j.call(this), this.type = "MeshLambertMaterial", this.color = new x(16777215), this.lightMap = this.map = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new x(0), this.emissiveIntensity = 1, this.envMap = this.alphaMap = this.specularMap = this.emissiveMap = null, this.combine = 0, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinejoin = this.wireframeLinecap = "round", this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t) } function sn(t) { j.call(this), this.defines = { MATCAP: "" }, this.type = "MeshMatcapMaterial", this.color = new x(16777215), this.bumpMap = this.map = this.matcap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = 0, this.normalScale = new i(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.lights = this.morphNormals = this.morphTargets = this.skinning = !1, this.setValues(t) } function cn(t) { Ue.call(this), this.type = "LineDashedMaterial", this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(t) } function hn(t, e, i, n) { this.parameterPositions = t, this._cachedIndex = 0, this.resultBuffer = void 0 !== n ? n : new e.constructor(i), this.sampleValues = e, this.valueSize = i } function ln(t, e, i, n) { hn.call(this, t, e, i, n), this._offsetNext = this._weightNext = this._offsetPrev = this._weightPrev = -0 } function un(t, e, i, n) { hn.call(this, t, e, i, n) } function dn(t, e, i, n) { hn.call(this, t, e, i, n) } function pn(t, e, i, n) { if (void 0 === t) throw Error("THREE.KeyframeTrack: track name is undefined"); if (void 0 === e || 0 === e.length) throw Error("THREE.KeyframeTrack: no keyframes in track named " + t); this.name = t, this.times = Xo.convertArray(e, this.TimeBufferType), this.values = Xo.convertArray(i, this.ValueBufferType), this.setInterpolation(n || this.DefaultInterpolation) } function fn(t, e, i) { pn.call(this, t, e, i) } function mn(t, e, i, n) { pn.call(this, t, e, i, n) } function gn(t, e, i, n) { pn.call(this, t, e, i, n) } function vn(t, e, i, n) { hn.call(this, t, e, i, n) } function yn(t, e, i, n) { pn.call(this, t, e, i, n) } function xn(t, e, i, n) { pn.call(this, t, e, i, n) } function bn(t, e, i, n) { pn.call(this, t, e, i, n) } function wn(t, e, i) { this.name = t, this.tracks = i, this.duration = void 0 !== e ? e : -1, this.uuid = fo.generateUUID(), 0 > this.duration && this.resetDuration() } function Mn(t) { if (void 0 === t.type) throw Error("THREE.KeyframeTrack: track type undefined, can not parse"); var e = function (t) { switch (t.toLowerCase()) { case "scalar": case "double": case "float": case "number": case "integer": return gn; case "vector": case "vector2": case "vector3": case "vector4": return bn; case "color": return mn; case "quaternion": return yn; case "bool": case "boolean": return fn; case "string": return xn }throw Error("THREE.KeyframeTrack: Unsupported typeName: " + t) }(t.type); if (void 0 === t.times) { var i = [], n = []; Xo.flattenJSON(t.keys, i, n, "value"), t.times = i, t.values = n } return void 0 !== e.parse ? e.parse(t) : new e(t.name, t.times, t.values, t.interpolation) } function _n(t, e, i) { var n = this, r = !1, o = 0, a = 0, s = void 0; this.onStart = void 0, this.onLoad = t, this.onProgress = e, this.onError = i, this.itemStart = function (t) { a++, !1 === r && void 0 !== n.onStart && n.onStart(t, o, a), r = !0 }, this.itemEnd = function (t) { o++, void 0 !== n.onProgress && n.onProgress(t, o, a), o === a && (r = !1, void 0 !== n.onLoad) && n.onLoad() }, this.itemError = function (t) { void 0 !== n.onError && n.onError(t) }, this.resolveURL = function (t) { return s ? s(t) : t }, this.setURLModifier = function (t) { return s = t, this } } function En(t) { this.manager = void 0 !== t ? t : Zo } function An(t) { this.manager = void 0 !== t ? t : Zo } function Tn(t) { this.manager = void 0 !== t ? t : Zo, this._parser = null } function Sn(t) { this.manager = void 0 !== t ? t : Zo, this._parser = null } function Ln(t) { this.manager = void 0 !== t ? t : Zo } function Cn(t) { this.manager = void 0 !== t ? t : Zo } function Rn(t) { this.manager = void 0 !== t ? t : Zo } function Pn() { this.type = "Curve", this.arcLengthDivisions = 200 } function In(t, e, i, n, r, o, a, s) { Pn.call(this), this.type = "EllipseCurve", this.aX = t || 0, this.aY = e || 0, this.xRadius = i || 1, this.yRadius = n || 1, this.aStartAngle = r || 0, this.aEndAngle = o || 2 * Math.PI, this.aClockwise = a || !1, this.aRotation = s || 0 } function On(t, e, i, n, r, o) { In.call(this, t, e, i, i, n, r, o), this.type = "ArcCurve" } function Dn() { var t = 0, e = 0, i = 0, n = 0; return { initCatmullRom: function (r, o, a, s, c) { t = o, e = r = c * (a - r), i = -3 * o + 3 * a - 2 * r - (s = c * (s - o)), n = 2 * o - 2 * a + r + s }, initNonuniformCatmullRom: function (r, o, a, s, c, h, l) { t = o, e = r = ((o - r) / c - (a - r) / (c + h) + (a - o) / h) * h, i = -3 * o + 3 * a - 2 * r - (s = ((a - o) / h - (s - o) / (h + l) + (s - a) / l) * h), n = 2 * o - 2 * a + r + s }, calc: function (r) { var o = r * r; return t + e * r + i * o + n * o * r } } } function Nn(t, e, i, n) { Pn.call(this), this.type = "CatmullRomCurve3", this.points = t || [], this.closed = e || !1, this.curveType = i || "centripetal", this.tension = n || .5 } function Bn(t, e, i, n, r) { var o = t * t; return (2 * i - 2 * n + (e = .5 * (n - e)) + (r = .5 * (r - i))) * t * o + (-3 * i + 3 * n - 2 * e - r) * o + e * t + i } function zn(t, e, i, n) { var r = 1 - t; return r * r * e + 2 * (1 - t) * t * i + t * t * n } function Un(t, e, i, n, r) { var o = 1 - t, a = 1 - t; return o * o * o * e + 3 * a * a * t * i + 3 * (1 - t) * t * t * n + t * t * t * r } function Fn(t, e, n, r) { Pn.call(this), this.type = "CubicBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i, this.v3 = r || new i } function Gn(t, e, i, n) { Pn.call(this), this.type = "CubicBezierCurve3", this.v0 = t || new r, this.v1 = e || new r, this.v2 = i || new r, this.v3 = n || new r } function Hn(t, e) { Pn.call(this), this.type = "LineCurve", this.v1 = t || new i, this.v2 = e || new i } function kn(t, e) { Pn.call(this), this.type = "LineCurve3", this.v1 = t || new r, this.v2 = e || new r } function Vn(t, e, n) { Pn.call(this), this.type = "QuadraticBezierCurve", this.v0 = t || new i, this.v1 = e || new i, this.v2 = n || new i } function jn(t, e, i) { Pn.call(this), this.type = "QuadraticBezierCurve3", this.v0 = t || new r, this.v1 = e || new r, this.v2 = i || new r } function Wn(t) { Pn.call(this), this.type = "SplineCurve", this.points = t || [] } function qn() { Pn.call(this), this.type = "CurvePath", this.curves = [], this.autoClose = !1 } function Xn(t) { qn.call(this), this.type = "Path", this.currentPoint = new i, t && this.setFromPoints(t) } function Yn(t) { Xn.call(this, t), this.uuid = fo.generateUUID(), this.type = "Shape", this.holes = [] } function Zn(t, e) { A.call(this), this.type = "Light", this.color = new x(t), this.intensity = void 0 !== e ? e : 1, this.receiveShadow = void 0 } function Jn(t, e, i) { Zn.call(this, t, i), this.type = "HemisphereLight", this.castShadow = void 0, this.position.copy(A.DefaultUp), this.updateMatrix(), this.groundColor = new x(e) } function Qn(t) { this.camera = t, this.bias = 0, this.radius = 1, this.mapSize = new i(512, 512), this.map = null, this.matrix = new g } function Kn() { Qn.call(this, new we(50, 1, .5, 500)) } function $n(t, e, i, n, r, o) { Zn.call(this, t, e), this.type = "SpotLight", this.position.copy(A.DefaultUp), this.updateMatrix(), this.target = new A, Object.defineProperty(this, "power", { get: function () { return this.intensity * Math.PI }, set: function (t) { this.intensity = t / Math.PI } }), this.distance = void 0 !== i ? i : 0, this.angle = void 0 !== n ? n : Math.PI / 3, this.penumbra = void 0 !== r ? r : 0, this.decay = void 0 !== o ? o : 1, this.shadow = new Kn } function tr(t, e, i, n) { Zn.call(this, t, e), this.type = "PointLight", Object.defineProperty(this, "power", { get: function () { return 4 * this.intensity * Math.PI }, set: function (t) { this.intensity = t / (4 * Math.PI) } }), this.distance = void 0 !== i ? i : 0, this.decay = void 0 !== n ? n : 1, this.shadow = new Qn(new we(90, 1, .5, 500)) } function er(t, e, i, n, r, o) { be.call(this), this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = void 0 !== t ? t : -1, this.right = void 0 !== e ? e : 1, this.top = void 0 !== i ? i : 1, this.bottom = void 0 !== n ? n : -1, this.near = void 0 !== r ? r : .1, this.far = void 0 !== o ? o : 2e3, this.updateProjectionMatrix() } function ir() { Qn.call(this, new er(-5, 5, 5, -5, .5, 500)) } function nr(t, e) { Zn.call(this, t, e), this.type = "DirectionalLight", this.position.copy(A.DefaultUp), this.updateMatrix(), this.target = new A, this.shadow = new ir } function rr(t, e) { Zn.call(this, t, e), this.type = "AmbientLight", this.castShadow = void 0 } function or(t, e, i, n) { Zn.call(this, t, e), this.type = "RectAreaLight", this.width = void 0 !== i ? i : 10, this.height = void 0 !== n ? n : 10 } function ar(t) { this.manager = void 0 !== t ? t : Zo, this.textures = {} } function sr() { F.call(this), this.type = "InstancedBufferGeometry", this.maxInstancedCount = void 0 } function cr(t, e, i, n) { "number" == typeof i && (n = i, i = !1, console.error("THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.")), S.call(this, t, e, i), this.meshPerAttribute = n || 1 } function hr(t) { this.manager = void 0 !== t ? t : Zo } function lr(t) { this.manager = void 0 !== t ? t : Zo, this.resourcePath = "" } function ur(t) { "undefined" == typeof createImageBitmap && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), "undefined" == typeof fetch && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.manager = void 0 !== t ? t : Zo, this.options = void 0 } function dr() { this.type = "ShapePath", this.color = new x, this.subPaths = [], this.currentPath = null } function pr(t) { this.type = "Font", this.data = t } function fr(t) { this.manager = void 0 !== t ? t : Zo } function mr() { } function gr(t) { this.manager = void 0 !== t ? t : Zo } function vr() { this.coefficients = []; for (var t = 0; 9 > t; t++)this.coefficients.push(new r) } function yr(t, e) { Zn.call(this, void 0, e), this.sh = void 0 !== t ? t : new vr } function xr(t, e, i) { yr.call(this, void 0, i), t = (new x).set(t), i = (new x).set(e), e = new r(t.r, t.g, t.b), t = new r(i.r, i.g, i.b); var n = (i = Math.sqrt(Math.PI)) * Math.sqrt(.75); this.sh.coefficients[0].copy(e).add(t).multiplyScalar(i), this.sh.coefficients[1].copy(e).sub(t).multiplyScalar(n) } function br(t, e) { yr.call(this, void 0, e), t = (new x).set(t), this.sh.coefficients[0].set(t.r, t.g, t.b).multiplyScalar(2 * Math.sqrt(Math.PI)) } function wr() { this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new we, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new we, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1 } function Mr(t, e, i, n) { A.call(this), this.type = "CubeCamera"; var o = new we(90, 1, t, e); o.up.set(0, -1, 0), o.lookAt(new r(1, 0, 0)), this.add(o); var a = new we(90, 1, t, e); a.up.set(0, -1, 0), a.lookAt(new r(-1, 0, 0)), this.add(a); var s = new we(90, 1, t, e); s.up.set(0, 0, 1), s.lookAt(new r(0, 1, 0)), this.add(s); var c = new we(90, 1, t, e); c.up.set(0, 0, -1), c.lookAt(new r(0, -1, 0)), this.add(c); var h = new we(90, 1, t, e); h.up.set(0, -1, 0), h.lookAt(new r(0, 0, 1)), this.add(h); var u = new we(90, 1, t, e); u.up.set(0, -1, 0), u.lookAt(new r(0, 0, -1)), this.add(u), n = n || { format: 1022, magFilter: 1006, minFilter: 1006 }, this.renderTarget = new l(i, i, n), this.renderTarget.texture.name = "CubeCamera", this.update = function (t, e) { null === this.parent && this.updateMatrixWorld(); var i = t.getRenderTarget(), n = this.renderTarget, r = n.texture.generateMipmaps; n.texture.generateMipmaps = !1, t.setRenderTarget(n, 0), t.render(e, o), t.setRenderTarget(n, 1), t.render(e, a), t.setRenderTarget(n, 2), t.render(e, s), t.setRenderTarget(n, 3), t.render(e, c), t.setRenderTarget(n, 4), t.render(e, h), n.texture.generateMipmaps = r, t.setRenderTarget(n, 5), t.render(e, u), t.setRenderTarget(i) }, this.clear = function (t, e, i, n) { for (var r = t.getRenderTarget(), o = this.renderTarget, a = 0; 6 > a; a++)t.setRenderTarget(o, a), t.clear(e, i, n); t.setRenderTarget(r) } } function _r(t) { this.autoStart = void 0 === t || t, this.elapsedTime = this.oldTime = this.startTime = 0, this.running = !1 } function Er() { A.call(this), this.type = "AudioListener", this.context = la.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0 } function Ar(t) { A.call(this), this.type = "Audio", this.listener = t, this.context = t.context, this.gain = this.context.createGain(), this.gain.connect(t.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.offset = this.startTime = 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.sourceType = "empty", this.filters = [] } function Tr(t) { Ar.call(this, t), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain) } function Sr(t, e) { this.analyser = t.context.createAnalyser(), this.analyser.fftSize = void 0 !== e ? e : 2048, this.data = new Uint8Array(this.analyser.frequencyBinCount), t.getOutput().connect(this.analyser) } function Lr(t, e, i) { switch (this.binding = t, this.valueSize = i, t = Float64Array, e) { case "quaternion": e = this._slerp; break; case "string": case "bool": t = Array, e = this._select; break; default: e = this._lerp }this.buffer = new t(4 * i), this._mixBufferRegion = e, this.referenceCount = this.useCount = this.cumulativeWeight = 0 } function Cr(t, e, i) { i = i || Rr.parseTrackName(e), this._targetGroup = t, this._bindings = t.subscribe_(e, i) } function Rr(t, e, i) { this.path = e, this.parsedPath = i || Rr.parseTrackName(e), this.node = Rr.findNode(t, this.parsedPath.nodeName) || t, this.rootNode = t } function Pr() { this.uuid = fo.generateUUID(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0; var t = {}; this._indicesByUUID = t; for (var e = 0, i = arguments.length; e !== i; ++e)t[arguments[e].uuid] = e; this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {}; var n = this; this.stats = { objects: { get total() { return n._objects.length }, get inUse() { return this.total - n.nCachedObjects_ } }, get bindingsPerObject() { return n._bindings.length } } } function Ir(t, e, i) { this._mixer = t, this._clip = e, this._localRoot = i || null, e = (t = e.tracks).length, i = Array(e); for (var n = { endingStart: 2400, endingEnd: 2400 }, r = 0; r !== e; ++r) { var o = t[r].createInterpolant(null); i[r] = o, o.settings = n } this._interpolantSettings = n, this._interpolants = i, this._propertyBindings = Array(e), this._weightInterpolant = this._timeScaleInterpolant = this._byClipCacheIndex = this._cacheIndex = null, this.loop = 2201, this._loopCount = -1, this._startTime = null, this.time = 0, this._effectiveWeight = this.weight = this._effectiveTimeScale = this.timeScale = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtEnd = this.zeroSlopeAtStart = !0 } function Or(t) { this._root = t, this._initMemoryManager(), this.time = this._accuIndex = 0, this.timeScale = 1 } function Dr(t, e) { "string" == typeof t && (console.warn("THREE.Uniform: Type parameter is no longer needed."), t = e), this.value = t } function Nr(t, e, i) { Re.call(this, t, e), this.meshPerAttribute = i || 1 } function Br(t, e, i, n) { this.ray = new q(t, e), this.near = i || 0, this.far = n || 1 / 0, this.params = { Mesh: {}, Line: {}, LOD: {}, Points: { threshold: 1 }, Sprite: {} }, Object.defineProperties(this.params, { PointCloud: { get: function () { return console.warn("THREE.Raycaster: params.PointCloud has been renamed to params.Points."), this.Points } } }) } function zr(t, e) { return t.distance - e.distance } function Ur(t, e, i, n) { if (!1 !== t.visible && (t.raycast(e, i), !0 === n)) { n = 0; for (var r = (t = t.children).length; n < r; n++)Ur(t[n], e, i, !0) } } function Fr(t, e, i) { return this.radius = void 0 !== t ? t : 1, this.phi = void 0 !== e ? e : 0, this.theta = void 0 !== i ? i : 0, this } function Gr(t, e, i) { return this.radius = void 0 !== t ? t : 1, this.theta = void 0 !== e ? e : 0, this.y = void 0 !== i ? i : 0, this } function Hr(t, e) { this.min = void 0 !== t ? t : new i(1 / 0, 1 / 0), this.max = void 0 !== e ? e : new i(-1 / 0, -1 / 0) } function kr(t, e) { this.start = void 0 !== t ? t : new r, this.end = void 0 !== e ? e : new r } function Vr(t) { A.call(this), this.material = t, this.render = function () { } } function jr(t, e, i, n) { this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16711680, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = 3 * i.faces.length : i && i.isBufferGeometry && (e = i.attributes.normal.count), i = new F, e = new N(6 * e, 3), i.addAttribute("position", e), Ge.call(this, i, new Ue({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update() } function Wr(t, e) { A.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = e, t = new F, e = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1]; for (var i = 0, n = 1; 32 > i; i++, n++) { var r = i / 32 * Math.PI * 2, o = n / 32 * Math.PI * 2; e.push(Math.cos(r), Math.sin(r), 1, Math.cos(o), Math.sin(o), 1) } t.addAttribute("position", new N(e, 3)), e = new Ue({ fog: !1 }), this.cone = new Ge(t, e), this.add(this.cone), this.update() } function qr(t) { var e = []; t && t.isBone && e.push(t); for (var i = 0; i < t.children.length; i++)e.push.apply(e, qr(t.children[i])); return e } function Xr(t) { for (var e = qr(t), i = new F, n = [], r = [], o = new x(0, 0, 1), a = new x(0, 1, 0), s = 0; s < e.length; s++) { var c = e[s]; c.parent && c.parent.isBone && (n.push(0, 0, 0), n.push(0, 0, 0), r.push(o.r, o.g, o.b), r.push(a.r, a.g, a.b)) } i.addAttribute("position", new N(n, 3)), i.addAttribute("color", new N(r, 3)), n = new Ue({ vertexColors: 2, depthTest: !1, depthWrite: !1, transparent: !0 }), Ge.call(this, i, n), this.root = t, this.bones = e, this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1 } function Yr(t, e, i) { this.light = t, this.light.updateMatrixWorld(), this.color = i, t = new zi(e, 4, 2), e = new Y({ wireframe: !0, fog: !1 }), Z.call(this, t, e), this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update() } function Zr(t, e) { this.type = "RectAreaLightHelper", this.light = t, this.color = e, (t = new F).addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0], 3)), t.computeBoundingSphere(), e = new Ue({ fog: !1 }), Fe.call(this, t, e), (t = new F).addAttribute("position", new N([1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0], 3)), t.computeBoundingSphere(), this.add(new Z(t, new Y({ side: 1, fog: !1 }))), this.update() } function Jr(t, e, i) { A.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, (t = new ii(e)).rotateY(.5 * Math.PI), this.material = new Y({ wireframe: !0, fog: !1 }), void 0 === this.color && (this.material.vertexColors = 2), e = t.getAttribute("position"), e = new Float32Array(3 * e.count), t.addAttribute("color", new S(e, 3)), this.add(new Z(t, this.material)), this.update() } function Qr(t, e) { this.lightProbe = t, this.size = e, t = new W({ defines: { GAMMA_OUTPUT: "" }, uniforms: { sh: { value: this.lightProbe.sh.coefficients }, intensity: { value: this.lightProbe.intensity } }, vertexShader: "varying vec3 vNormal;\nvoid main() {\n\tvNormal = normalize( normalMatrix * normal );\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}", fragmentShader: "#define RECIPROCAL_PI 0.318309886\nvec3 inverseTransformDirection( in vec3 normal, in mat4 matrix ) {\n\t// matrix is assumed to be orthogonal\n\treturn normalize( ( vec4( normal, 0.0 ) * matrix ).xyz );\n}\nvec3 linearToOutput( in vec3 a ) {\n\t#ifdef GAMMA_OUTPUT\n\t\treturn pow( a, vec3( 1.0 / float( GAMMA_FACTOR ) ) );\n\t#else\n\t\treturn a;\n\t#endif\n}\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\t// normal is assumed to have unit length\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\t// band 0\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\t// band 1\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\t// band 2\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nuniform vec3 sh[ 9 ]; // sh coefficients\nuniform float intensity; // light probe intensity\nvarying vec3 vNormal;\nvoid main() {\n\tvec3 normal = normalize( vNormal );\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, sh );\n\tvec3 outgoingLight = RECIPROCAL_PI * irradiance * intensity;\n\toutgoingLight = linearToOutput( outgoingLight );\n\tgl_FragColor = vec4( outgoingLight, 1.0 );\n}" }), e = new zi(1, 32, 16), Z.call(this, e, t), this.onBeforeRender() } function Kr(t, e, i, n) { t = t || 10, e = e || 10, i = new x(void 0 !== i ? i : 4473924), n = new x(void 0 !== n ? n : 8947848); var r = e / 2, o = t / e, a = t / 2; t = []; for (var s = [], c = 0, h = 0, l = -a; c <= e; c++, l += o) { t.push(-a, 0, l, a, 0, l), t.push(l, 0, -a, l, 0, a); var u = c === r ? i : n; u.toArray(s, h), h += 3, u.toArray(s, h), h += 3, u.toArray(s, h), h += 3, u.toArray(s, h), h += 3 } (e = new F).addAttribute("position", new N(t, 3)), e.addAttribute("color", new N(s, 3)), i = new Ue({ vertexColors: 2 }), Ge.call(this, e, i) } function $r(t, e, i, n, r, o) { t = t || 10, e = e || 16, i = i || 8, n = n || 64, r = new x(void 0 !== r ? r : 4473924), o = new x(void 0 !== o ? o : 8947848); var a, s = [], c = []; for (a = 0; a <= e; a++) { var h = a / e * 2 * Math.PI, l = Math.sin(h) * t; h = Math.cos(h) * t, s.push(0, 0, 0), s.push(l, 0, h); var u = 1 & a ? r : o; c.push(u.r, u.g, u.b), c.push(u.r, u.g, u.b) } for (a = 0; a <= i; a++) { u = 1 & a ? r : o; var d = t - t / i * a; for (e = 0; e < n; e++)h = e / n * 2 * Math.PI, l = Math.sin(h) * d, h = Math.cos(h) * d, s.push(l, 0, h), c.push(u.r, u.g, u.b), h = (e + 1) / n * 2 * Math.PI, l = Math.sin(h) * d, h = Math.cos(h) * d, s.push(l, 0, h), c.push(u.r, u.g, u.b) } (t = new F).addAttribute("position", new N(s, 3)), t.addAttribute("color", new N(c, 3)), s = new Ue({ vertexColors: 2 }), Ge.call(this, t, s) } function to(t, e, i, n) { this.audio = t, this.range = e || 1, this.divisionsInnerAngle = i || 16, this.divisionsOuterAngle = n || 2, t = new F, e = new Float32Array(3 * (3 * (this.divisionsInnerAngle + 2 * this.divisionsOuterAngle) + 3)), t.addAttribute("position", new S(e, 3)), e = new Ue({ color: 65280 }), i = new Ue({ color: 16776960 }), Fe.call(this, t, [i, e]), this.update() } function eo(t, e, i, n) { this.object = t, this.size = void 0 !== e ? e : 1, t = void 0 !== i ? i : 16776960, n = void 0 !== n ? n : 1, e = 0, (i = this.object.geometry) && i.isGeometry ? e = i.faces.length : console.warn("THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead."), i = new F, e = new N(6 * e, 3), i.addAttribute("position", e), Ge.call(this, i, new Ue({ color: t, linewidth: n })), this.matrixAutoUpdate = !1, this.update() } function io(t, e, i) { A.call(this), this.light = t, this.light.updateMatrixWorld(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.color = i, void 0 === e && (e = 1), (t = new F).addAttribute("position", new N([-e, e, 0, e, e, 0, e, -e, 0, -e, -e, 0, -e, e, 0], 3)), e = new Ue({ fog: !1 }), this.lightPlane = new Fe(t, e), this.add(this.lightPlane), (t = new F).addAttribute("position", new N([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Fe(t, e), this.add(this.targetLine), this.update() } function no(t) { function e(t, e, n) { i(t, n), i(e, n) } function i(t, e) { o.push(0, 0, 0), a.push(e.r, e.g, e.b), void 0 === s[t] && (s[t] = []), s[t].push(o.length / 3 - 1) } var n = new F, r = new Ue({ color: 16777215, vertexColors: 1 }), o = [], a = [], s = {}, c = new x(16755200), h = new x(16711680), l = new x(43775), u = new x(16777215), d = new x(3355443); e("n1", "n2", c), e("n2", "n4", c), e("n4", "n3", c), e("n3", "n1", c), e("f1", "f2", c), e("f2", "f4", c), e("f4", "f3", c), e("f3", "f1", c), e("n1", "f1", c), e("n2", "f2", c), e("n3", "f3", c), e("n4", "f4", c), e("p", "n1", h), e("p", "n2", h), e("p", "n3", h), e("p", "n4", h), e("u1", "u2", l), e("u2", "u3", l), e("u3", "u1", l), e("c", "t", u), e("p", "c", d), e("cn1", "cn2", d), e("cn3", "cn4", d), e("cf1", "cf2", d), e("cf3", "cf4", d), n.addAttribute("position", new N(o, 3)), n.addAttribute("color", new N(a, 3)), Ge.call(this, n, r), this.camera = t, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = t.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = s, this.update() } function ro(t, e) { this.object = t, void 0 === e && (e = 16776960), t = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var i = new Float32Array(24), n = new F; n.setIndex(new S(t, 1)), n.addAttribute("position", new S(i, 3)), Ge.call(this, n, new Ue({ color: e })), this.matrixAutoUpdate = !1, this.update() } function oo(t, e) { this.type = "Box3Helper", this.box = t, t = void 0 !== e ? e : 16776960, e = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]); var i = new F; i.setIndex(new S(e, 1)), i.addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1], 3)), Ge.call(this, i, new Ue({ color: t })), this.geometry.computeBoundingSphere() } function ao(t, e, i) { this.type = "PlaneHelper", this.plane = t, this.size = void 0 === e ? 1 : e, t = void 0 !== i ? i : 16776960, (e = new F).addAttribute("position", new N([1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0], 3)), e.computeBoundingSphere(), Fe.call(this, e, new Ue({ color: t })), (e = new F).addAttribute("position", new N([1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1], 3)), e.computeBoundingSphere(), this.add(new Z(e, new Y({ color: t, opacity: .2, transparent: !0, depthWrite: !1 }))) } function so(t, e, i, n, o, a) { A.call(this), void 0 === t && (t = new r(0, 0, 1)), void 0 === e && (e = new r(0, 0, 0)), void 0 === i && (i = 1), void 0 === n && (n = 16776960), void 0 === o && (o = .2 * i), void 0 === a && (a = .2 * o), void 0 === ca && ((ca = new F).addAttribute("position", new N([0, 0, 0, 0, 1, 0], 3)), (ha = new Xi(0, .5, 1, 5, 1)).translate(0, -.5, 0)), this.position.copy(e), this.line = new Fe(ca, new Ue({ color: n })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Z(ha, new Y({ color: n })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(t), this.setLength(i, o, a) } function co(t) { var e = [0, 0, 0, t = t || 1, 0, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 0, t]; (t = new F).addAttribute("position", new N(e, 3)), t.addAttribute("color", new N([1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1], 3)), e = new Ue({ vertexColors: 2 }), Ge.call(this, t, e) } function ho(t) { console.warn("THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Nn.call(this, t), this.type = "catmullrom", this.closed = !0 } function lo(t) { console.warn("THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead."), Nn.call(this, t), this.type = "catmullrom" } function uo(t) { console.warn("THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead."), Nn.call(this, t), this.type = "catmullrom" } void 0 === Number.EPSILON && (Number.EPSILON = Math.pow(2, -52)), void 0 === Number.isInteger && (Number.isInteger = function (t) { return "number" == typeof t && isFinite(t) && Math.floor(t) === t }), void 0 === Math.sign && (Math.sign = function (t) { return 0 > t ? -1 : 0 < t ? 1 : +t }), !1 == "name" in Function.prototype && Object.defineProperty(Function.prototype, "name", { get: function () { return this.toString().match(/^\s*function\s*([^\(\s]*)/)[1] } }), void 0 === Object.assign && (Object.assign = function (t) { if (null == t) throw new TypeError("Cannot convert undefined or null to object"); for (var e = Object(t), i = 1; i < arguments.length; i++) { var n = arguments[i]; if (null != n) for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }), Object.assign(e.prototype, { addEventListener: function (t, e) { void 0 === this._listeners && (this._listeners = {}); var i = this._listeners; void 0 === i[t] && (i[t] = []), -1 === i[t].indexOf(e) && i[t].push(e) }, hasEventListener: function (t, e) { if (void 0 === this._listeners) return !1; var i = this._listeners; return void 0 !== i[t] && -1 !== i[t].indexOf(e) }, removeEventListener: function (t, e) { void 0 !== this._listeners && (void 0 !== (t = this._listeners[t]) && (-1 !== (e = t.indexOf(e)) && t.splice(e, 1))) }, dispatchEvent: function (t) { if (void 0 !== this._listeners) { var e = this._listeners[t.type]; if (void 0 !== e) { t.target = this; for (var i = 0, n = (e = e.slice(0)).length; i < n; i++)e[i].call(this, t) } } } }); var po, fo = { DEG2RAD: Math.PI / 180, RAD2DEG: 180 / Math.PI, generateUUID: function () { for (var t = [], e = 0; 256 > e; e++)t[e] = (16 > e ? "0" : "") + e.toString(16); return function () { var e = 4294967295 * Math.random() | 0, i = 4294967295 * Math.random() | 0, n = 4294967295 * Math.random() | 0, r = 4294967295 * Math.random() | 0; return (t[255 & e] + t[e >> 8 & 255] + t[e >> 16 & 255] + t[e >> 24 & 255] + "-" + t[255 & i] + t[i >> 8 & 255] + "-" + t[i >> 16 & 15 | 64] + t[i >> 24 & 255] + "-" + t[63 & n | 128] + t[n >> 8 & 255] + "-" + t[n >> 16 & 255] + t[n >> 24 & 255] + t[255 & r] + t[r >> 8 & 255] + t[r >> 16 & 255] + t[r >> 24 & 255]).toUpperCase() } }(), clamp: function (t, e, i) { return Math.max(e, Math.min(i, t)) }, euclideanModulo: function (t, e) { return (t % e + e) % e }, mapLinear: function (t, e, i, n, r) { return n + (t - e) * (r - n) / (i - e) }, lerp: function (t, e, i) { return (1 - i) * t + i * e }, smoothstep: function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t) }, smootherstep: function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * t * (t * (6 * t - 15) + 10) }, randInt: function (t, e) { return t + Math.floor(Math.random() * (e - t + 1)) }, randFloat: function (t, e) { return t + Math.random() * (e - t) }, randFloatSpread: function (t) { return t * (.5 - Math.random()) }, degToRad: function (t) { return t * fo.DEG2RAD }, radToDeg: function (t) { return t * fo.RAD2DEG }, isPowerOfTwo: function (t) { return 0 == (t & t - 1) && 0 !== t }, ceilPowerOfTwo: function (t) { return Math.pow(2, Math.ceil(Math.log(t) / Math.LN2)) }, floorPowerOfTwo: function (t) { return Math.pow(2, Math.floor(Math.log(t) / Math.LN2)) } }; Object.defineProperties(i.prototype, { width: { get: function () { return this.x }, set: function (t) { this.x = t } }, height: { get: function () { return this.y }, set: function (t) { this.y = t } } }), Object.assign(i.prototype, { isVector2: !0, set: function (t, e) { return this.x = t, this.y = e, this }, setScalar: function (t) { return this.y = this.x = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; default: throw Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; default: throw Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y) }, copy: function (t) { return this.x = t.x, this.y = t.y, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this) }, addScalar: function (t) { return this.x += t, this.y += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this }, multiply: function (t) { return this.x *= t.x, this.y *= t.y, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, applyMatrix3: function (t) { var e = this.x, i = this.y; return t = t.elements, this.x = t[0] * e + t[3] * i + t[6], this.y = t[1] * e + t[4] * i + t[7], this }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this }, clampLength: function (t, e) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this }, roundToZero: function () { return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this }, dot: function (t) { return this.x * t.x + this.y * t.y }, cross: function (t) { return this.x * t.y - this.y * t.x }, lengthSq: function () { return this.x * this.x + this.y * this.y }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) }, normalize: function () { return this.divideScalar(this.length() || 1) }, angle: function () { var t = Math.atan2(this.y, this.x); return 0 > t && (t += 2 * Math.PI), t }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x; return e * e + (t = this.y - t.y) * t }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this }, lerpVectors: function (t, e, i) { return this.subVectors(e, t).multiplyScalar(i).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t }, fromBufferAttribute: function (t, e, i) { return void 0 !== i && console.warn("THREE.Vector2: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this }, rotateAround: function (t, e) { var i = Math.cos(e); e = Math.sin(e); var n = this.x - t.x, r = this.y - t.y; return this.x = n * i - r * e + t.x, this.y = n * e + r * i + t.y, this } }), Object.assign(n, { slerp: function (t, e, i, n) { return i.copy(t).slerp(e, n) }, slerpFlat: function (t, e, i, n, r, o, a) { var s = i[n + 0], c = i[n + 1], h = i[n + 2]; i = i[n + 3], n = r[o + 0]; var l = r[o + 1], u = r[o + 2]; if (i !== (r = r[o + 3]) || s !== n || c !== l || h !== u) { o = 1 - a; var d = s * n + c * l + h * u + i * r, p = 0 <= d ? 1 : -1, f = 1 - d * d; f > Number.EPSILON && (f = Math.sqrt(f), d = Math.atan2(f, d * p), o = Math.sin(o * d) / f, a = Math.sin(a * d) / f), s = s * o + n * (p *= a), c = c * o + l * p, h = h * o + u * p, i = i * o + r * p, o === 1 - a && (s *= a = 1 / Math.sqrt(s * s + c * c + h * h + i * i), c *= a, h *= a, i *= a) } t[e] = s, t[e + 1] = c, t[e + 2] = h, t[e + 3] = i } }), Object.defineProperties(n.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this.onChangeCallback() } }, w: { get: function () { return this._w }, set: function (t) { this._w = t, this.onChangeCallback() } } }), Object.assign(n.prototype, { isQuaternion: !0, set: function (t, e, i, n) { return this._x = t, this._y = e, this._z = i, this._w = n, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._w) }, copy: function (t) { return this._x = t.x, this._y = t.y, this._z = t.z, this._w = t.w, this.onChangeCallback(), this }, setFromEuler: function (t, e) { if (!t || !t.isEuler) throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order."); var i = t._x, n = t._y, r = t._z; t = t.order; var o = Math.cos, a = Math.sin, s = o(i / 2), c = o(n / 2); return o = o(r / 2), i = a(i / 2), n = a(n / 2), r = a(r / 2), "XYZ" === t ? (this._x = i * c * o + s * n * r, this._y = s * n * o - i * c * r, this._z = s * c * r + i * n * o, this._w = s * c * o - i * n * r) : "YXZ" === t ? (this._x = i * c * o + s * n * r, this._y = s * n * o - i * c * r, this._z = s * c * r - i * n * o, this._w = s * c * o + i * n * r) : "ZXY" === t ? (this._x = i * c * o - s * n * r, this._y = s * n * o + i * c * r, this._z = s * c * r + i * n * o, this._w = s * c * o - i * n * r) : "ZYX" === t ? (this._x = i * c * o - s * n * r, this._y = s * n * o + i * c * r, this._z = s * c * r - i * n * o, this._w = s * c * o + i * n * r) : "YZX" === t ? (this._x = i * c * o + s * n * r, this._y = s * n * o + i * c * r, this._z = s * c * r - i * n * o, this._w = s * c * o - i * n * r) : "XZY" === t && (this._x = i * c * o - s * n * r, this._y = s * n * o - i * c * r, this._z = s * c * r + i * n * o, this._w = s * c * o + i * n * r), !1 !== e && this.onChangeCallback(), this }, setFromAxisAngle: function (t, e) { e /= 2; var i = Math.sin(e); return this._x = t.x * i, this._y = t.y * i, this._z = t.z * i, this._w = Math.cos(e), this.onChangeCallback(), this }, setFromRotationMatrix: function (t) { var e = t.elements, i = e[0]; t = e[4]; var n = e[8], r = e[1], o = e[5], a = e[9], s = e[2], c = e[6], h = i + o + (e = e[10]); return 0 < h ? (i = .5 / Math.sqrt(h + 1), this._w = .25 / i, this._x = (c - a) * i, this._y = (n - s) * i, this._z = (r - t) * i) : i > o && i > e ? (i = 2 * Math.sqrt(1 + i - o - e), this._w = (c - a) / i, this._x = .25 * i, this._y = (t + r) / i, this._z = (n + s) / i) : o > e ? (i = 2 * Math.sqrt(1 + o - i - e), this._w = (n - s) / i, this._x = (t + r) / i, this._y = .25 * i, this._z = (a + c) / i) : (i = 2 * Math.sqrt(1 + e - i - o), this._w = (r - t) / i, this._x = (n + s) / i, this._y = (a + c) / i, this._z = .25 * i), this.onChangeCallback(), this }, setFromUnitVectors: function (t, e) { var i = t.dot(e) + 1; return 1e-6 > i ? (i = 0, Math.abs(t.x) > Math.abs(t.z) ? (this._x = -t.y, this._y = t.x, this._z = 0) : (this._x = 0, this._y = -t.z, this._z = t.y)) : (this._x = t.y * e.z - t.z * e.y, this._y = t.z * e.x - t.x * e.z, this._z = t.x * e.y - t.y * e.x), this._w = i, this.normalize() }, angleTo: function (t) { return 2 * Math.acos(Math.abs(fo.clamp(this.dot(t), -1, 1))) }, rotateTowards: function (t, e) { var i = this.angleTo(t); return 0 === i || this.slerp(t, Math.min(1, e / i)), this }, inverse: function () { return this.conjugate() }, conjugate: function () { return this._x *= -1, this._y *= -1, this._z *= -1, this.onChangeCallback(), this }, dot: function (t) { return this._x * t._x + this._y * t._y + this._z * t._z + this._w * t._w }, lengthSq: function () { return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w }, length: function () { return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w) }, normalize: function () { var t = this.length(); return 0 === t ? (this._z = this._y = this._x = 0, this._w = 1) : (t = 1 / t, this._x *= t, this._y *= t, this._z *= t, this._w *= t), this.onChangeCallback(), this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."), this.multiplyQuaternions(t, e)) : this.multiplyQuaternions(this, t) }, premultiply: function (t) { return this.multiplyQuaternions(t, this) }, multiplyQuaternions: function (t, e) { var i = t._x, n = t._y, r = t._z; t = t._w; var o = e._x, a = e._y, s = e._z; return e = e._w, this._x = i * e + t * o + n * s - r * a, this._y = n * e + t * a + r * o - i * s, this._z = r * e + t * s + i * a - n * o, this._w = t * e - i * o - n * a - r * s, this.onChangeCallback(), this }, slerp: function (t, e) { if (0 === e) return this; if (1 === e) return this.copy(t); var i = this._x, n = this._y, r = this._z, o = this._w, a = o * t._w + i * t._x + n * t._y + r * t._z; if (0 > a ? (this._w = -t._w, this._x = -t._x, this._y = -t._y, this._z = -t._z, a = -a) : this.copy(t), 1 <= a) return this._w = o, this._x = i, this._y = n, this._z = r, this; if ((t = 1 - a * a) <= Number.EPSILON) return a = 1 - e, this._w = a * o + e * this._w, this._x = a * i + e * this._x, this._y = a * n + e * this._y, this._z = a * r + e * this._z, this.normalize(); t = Math.sqrt(t); var s = Math.atan2(t, a); return a = Math.sin((1 - e) * s) / t, e = Math.sin(e * s) / t, this._w = o * a + this._w * e, this._x = i * a + this._x * e, this._y = n * a + this._y * e, this._z = r * a + this._z * e, this.onChangeCallback(), this }, equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._w === this._w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this._x = t[e], this._y = t[e + 1], this._z = t[e + 2], this._w = t[e + 3], this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._w, t }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { } }), Object.assign(r.prototype, { isVector3: !0, set: function (t, e, i) { return this.x = t, this.y = e, this.z = i, this }, setScalar: function (t) { return this.z = this.y = this.x = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; default: throw Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; default: throw Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this }, multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead."), this.multiplyVectors(t, e)) : (this.x *= t.x, this.y *= t.y, this.z *= t.z, this) }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this }, multiplyVectors: function (t, e) { return this.x = t.x * e.x, this.y = t.y * e.y, this.z = t.z * e.z, this }, applyEuler: (po = new n, function (t) { return t && t.isEuler || console.error("THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order."), this.applyQuaternion(po.setFromEuler(t)) }), applyAxisAngle: function () { var t = new n; return function (e, i) { return this.applyQuaternion(t.setFromAxisAngle(e, i)) } }(), applyMatrix3: function (t) { var e = this.x, i = this.y, n = this.z; return t = t.elements, this.x = t[0] * e + t[3] * i + t[6] * n, this.y = t[1] * e + t[4] * i + t[7] * n, this.z = t[2] * e + t[5] * i + t[8] * n, this }, applyMatrix4: function (t) { var e = this.x, i = this.y, n = this.z, r = 1 / ((t = t.elements)[3] * e + t[7] * i + t[11] * n + t[15]); return this.x = (t[0] * e + t[4] * i + t[8] * n + t[12]) * r, this.y = (t[1] * e + t[5] * i + t[9] * n + t[13]) * r, this.z = (t[2] * e + t[6] * i + t[10] * n + t[14]) * r, this }, applyQuaternion: function (t) { var e = this.x, i = this.y, n = this.z, r = t.x, o = t.y, a = t.z, s = (t = t.w) * e + o * n - a * i, c = t * i + a * e - r * n, h = t * n + r * i - o * e; return e = -r * e - o * i - a * n, this.x = s * t + e * -r + c * -a - h * -o, this.y = c * t + e * -o + h * -r - s * -a, this.z = h * t + e * -a + s * -o - c * -r, this }, project: function (t) { return this.applyMatrix4(t.matrixWorldInverse).applyMatrix4(t.projectionMatrix) }, unproject: function (t) { return this.applyMatrix4(t.projectionMatrixInverse).applyMatrix4(t.matrixWorld) }, transformDirection: function (t) { var e = this.x, i = this.y, n = this.z; return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n, this.y = t[1] * e + t[5] * i + t[9] * n, this.z = t[2] * e + t[6] * i + t[10] * n, this.normalize() }, divide: function (t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this }, clampScalar: function (t, e) { return this.x = Math.max(t, Math.min(e, this.x)), this.y = Math.max(t, Math.min(e, this.y)), this.z = Math.max(t, Math.min(e, this.z)), this }, clampLength: function (t, e) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this }, roundToZero: function () { return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this }, lerpVectors: function (t, e, i) { return this.subVectors(e, t).multiplyScalar(i).add(t) }, cross: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead."), this.crossVectors(t, e)) : this.crossVectors(this, t) }, crossVectors: function (t, e) { var i = t.x, n = t.y; t = t.z; var r = e.x, o = e.y; return e = e.z, this.x = n * e - t * o, this.y = t * r - i * e, this.z = i * o - n * r, this }, projectOnVector: function (t) { var e = t.dot(this) / t.lengthSq(); return this.copy(t).multiplyScalar(e) }, projectOnPlane: function () { var t = new r; return function (e) { return t.copy(this).projectOnVector(e), this.sub(t) } }(), reflect: function () { var t = new r; return function (e) { return this.sub(t.copy(e).multiplyScalar(2 * this.dot(e))) } }(), angleTo: function (t) { return t = this.dot(t) / Math.sqrt(this.lengthSq() * t.lengthSq()), Math.acos(fo.clamp(t, -1, 1)) }, distanceTo: function (t) { return Math.sqrt(this.distanceToSquared(t)) }, distanceToSquared: function (t) { var e = this.x - t.x, i = this.y - t.y; return e * e + i * i + (t = this.z - t.z) * t }, manhattanDistanceTo: function (t) { return Math.abs(this.x - t.x) + Math.abs(this.y - t.y) + Math.abs(this.z - t.z) }, setFromSpherical: function (t) { return this.setFromSphericalCoords(t.radius, t.phi, t.theta) }, setFromSphericalCoords: function (t, e, i) { var n = Math.sin(e) * t; return this.x = n * Math.sin(i), this.y = Math.cos(e) * t, this.z = n * Math.cos(i), this }, setFromCylindrical: function (t) { return this.setFromCylindricalCoords(t.radius, t.theta, t.y) }, setFromCylindricalCoords: function (t, e, i) { return this.x = t * Math.sin(e), this.y = i, this.z = t * Math.cos(e), this }, setFromMatrixPosition: function (t) { return t = t.elements, this.x = t[12], this.y = t[13], this.z = t[14], this }, setFromMatrixScale: function (t) { var e = this.setFromMatrixColumn(t, 0).length(), i = this.setFromMatrixColumn(t, 1).length(); return t = this.setFromMatrixColumn(t, 2).length(), this.x = e, this.y = i, this.z = t, this }, setFromMatrixColumn: function (t, e) { return this.fromArray(t.elements, 4 * e) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t }, fromBufferAttribute: function (t, e, i) { return void 0 !== i && console.warn("THREE.Vector3: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this } }), Object.assign(o.prototype, { isMatrix3: !0, set: function (t, e, i, n, r, o, a, s, c) { var h = this.elements; return h[0] = t, h[1] = n, h[2] = a, h[3] = e, h[4] = r, h[5] = s, h[6] = i, h[7] = o, h[8] = c, this }, identity: function () { return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this }, clone: function () { return (new this.constructor).fromArray(this.elements) }, copy: function (t) { var e = this.elements; return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this }, setFromMatrix4: function (t) { return t = t.elements, this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this }, applyToBufferAttribute: function () { var t = new r; return function (e) { for (var i = 0, n = e.count; i < n; i++)t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix3(this), e.setXYZ(i, t.x, t.y, t.z); return e } }(), multiply: function (t) { return this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { var i = t.elements, n = e.elements; e = this.elements, t = i[0]; var r = i[3], o = i[6], a = i[1], s = i[4], c = i[7], h = i[2], l = i[5]; i = i[8]; var u = n[0], d = n[3], p = n[6], f = n[1], m = n[4], g = n[7], v = n[2], y = n[5]; return n = n[8], e[0] = t * u + r * f + o * v, e[3] = t * d + r * m + o * y, e[6] = t * p + r * g + o * n, e[1] = a * u + s * f + c * v, e[4] = a * d + s * m + c * y, e[7] = a * p + s * g + c * n, e[2] = h * u + l * f + i * v, e[5] = h * d + l * m + i * y, e[8] = h * p + l * g + i * n, this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[3] *= t, e[6] *= t, e[1] *= t, e[4] *= t, e[7] *= t, e[2] *= t, e[5] *= t, e[8] *= t, this }, determinant: function () { var t = this.elements, e = t[0], i = t[1], n = t[2], r = t[3], o = t[4], a = t[5], s = t[6], c = t[7]; return e * o * (t = t[8]) - e * a * c - i * r * t + i * a * s + n * r * c - n * o * s }, getInverse: function (t, e) { t && t.isMatrix4 && console.error("THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument."); var i = t.elements; t = this.elements; var n = i[0], r = i[1], o = i[2], a = i[3], s = i[4], c = i[5], h = i[6], l = i[7], u = (i = i[8]) * s - c * l, d = c * h - i * a, p = l * a - s * h, f = n * u + r * d + o * p; if (0 === f) { if (!0 === e) throw Error("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"); return console.warn("THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0"), this.identity() } return e = 1 / f, t[0] = u * e, t[1] = (o * l - i * r) * e, t[2] = (c * r - o * s) * e, t[3] = d * e, t[4] = (i * n - o * h) * e, t[5] = (o * a - c * n) * e, t[6] = p * e, t[7] = (r * h - l * n) * e, t[8] = (s * n - r * a) * e, this }, transpose: function () { var t = this.elements, e = t[1]; return t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this }, getNormalMatrix: function (t) { return this.setFromMatrix4(t).getInverse(this).transpose() }, transposeIntoArray: function (t) { var e = this.elements; return t[0] = e[0], t[1] = e[3], t[2] = e[6], t[3] = e[1], t[4] = e[4], t[5] = e[7], t[6] = e[2], t[7] = e[5], t[8] = e[8], this }, setUvTransform: function (t, e, i, n, r, o, a) { var s = Math.cos(r); r = Math.sin(r), this.set(i * s, i * r, -i * (s * o + r * a) + o + t, -n * r, n * s, -n * (-r * o + s * a) + a + e, 0, 0, 1) }, scale: function (t, e) { var i = this.elements; return i[0] *= t, i[3] *= t, i[6] *= t, i[1] *= e, i[4] *= e, i[7] *= e, this }, rotate: function (t) { var e = Math.cos(t); t = Math.sin(t); var i = this.elements, n = i[0], r = i[3], o = i[6], a = i[1], s = i[4], c = i[7]; return i[0] = e * n + t * a, i[3] = e * r + t * s, i[6] = e * o + t * c, i[1] = -t * n + e * a, i[4] = -t * r + e * s, i[7] = -t * o + e * c, this }, translate: function (t, e) { var i = this.elements; return i[0] += t * i[2], i[3] += t * i[5], i[6] += t * i[8], i[1] += e * i[2], i[4] += e * i[5], i[7] += e * i[8], this }, equals: function (t) { var e = this.elements; t = t.elements; for (var i = 0; 9 > i; i++)if (e[i] !== t[i]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (var i = 0; 9 > i; i++)this.elements[i] = t[i + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var i = this.elements; return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t } }); var mo, go = { getDataURL: function (t) { if ("undefined" == typeof HTMLCanvasElement) return t.src; if (!(t instanceof HTMLCanvasElement)) { void 0 === mo && (mo = document.createElementNS("http://www.w3.org/1999/xhtml", "canvas")), mo.width = t.width, mo.height = t.height; var e = mo.getContext("2d"); t instanceof ImageData ? e.putImageData(t, 0, 0) : e.drawImage(t, 0, 0, t.width, t.height), t = mo } return 2048 < t.width || 2048 < t.height ? t.toDataURL("image/jpeg", .6) : t.toDataURL("image/png") } }, vo = 0; a.DEFAULT_IMAGE = void 0, a.DEFAULT_MAPPING = 300, a.prototype = Object.assign(Object.create(e.prototype), { constructor: a, isTexture: !0, updateMatrix: function () { this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.name = t.name, this.image = t.image, this.mipmaps = t.mipmaps.slice(0), this.mapping = t.mapping, this.wrapS = t.wrapS, this.wrapT = t.wrapT, this.magFilter = t.magFilter, this.minFilter = t.minFilter, this.anisotropy = t.anisotropy, this.format = t.format, this.type = t.type, this.offset.copy(t.offset), this.repeat.copy(t.repeat), this.center.copy(t.center), this.rotation = t.rotation, this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrix.copy(t.matrix), this.generateMipmaps = t.generateMipmaps, this.premultiplyAlpha = t.premultiplyAlpha, this.flipY = t.flipY, this.unpackAlignment = t.unpackAlignment, this.encoding = t.encoding, this }, toJSON: function (t) { var e = void 0 === t || "string" == typeof t; if (!e && void 0 !== t.textures[this.uuid]) return t.textures[this.uuid]; var i = { metadata: { version: 4.5, type: "Texture", generator: "Texture.toJSON" }, uuid: this.uuid, name: this.name, mapping: this.mapping, repeat: [this.repeat.x, this.repeat.y], offset: [this.offset.x, this.offset.y], center: [this.center.x, this.center.y], rotation: this.rotation, wrap: [this.wrapS, this.wrapT], format: this.format, type: this.type, encoding: this.encoding, minFilter: this.minFilter, magFilter: this.magFilter, anisotropy: this.anisotropy, flipY: this.flipY, premultiplyAlpha: this.premultiplyAlpha, unpackAlignment: this.unpackAlignment }; if (void 0 !== this.image) { var n = this.image; if (void 0 === n.uuid && (n.uuid = fo.generateUUID()), !e && void 0 === t.images[n.uuid]) { if (Array.isArray(n)) for (var r = [], o = 0, a = n.length; o < a; o++)r.push(go.getDataURL(n[o])); else r = go.getDataURL(n); t.images[n.uuid] = { uuid: n.uuid, url: r } } i.image = n.uuid } return e || (t.textures[this.uuid] = i), i }, dispose: function () { this.dispatchEvent({ type: "dispose" }) }, transformUv: function (t) { if (300 !== this.mapping) return t; if (t.applyMatrix3(this.matrix), 0 > t.x || 1 < t.x) switch (this.wrapS) { case 1e3: t.x -= Math.floor(t.x); break; case 1001: t.x = 0 > t.x ? 0 : 1; break; case 1002: t.x = 1 === Math.abs(Math.floor(t.x) % 2) ? Math.ceil(t.x) - t.x : t.x - Math.floor(t.x) }if (0 > t.y || 1 < t.y) switch (this.wrapT) { case 1e3: t.y -= Math.floor(t.y); break; case 1001: t.y = 0 > t.y ? 0 : 1; break; case 1002: t.y = 1 === Math.abs(Math.floor(t.y) % 2) ? Math.ceil(t.y) - t.y : t.y - Math.floor(t.y) }return this.flipY && (t.y = 1 - t.y), t } }), Object.defineProperty(a.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(s.prototype, { isVector4: !0, set: function (t, e, i, n) { return this.x = t, this.y = e, this.z = i, this.w = n, this }, setScalar: function (t) { return this.w = this.z = this.y = this.x = t, this }, setX: function (t) { return this.x = t, this }, setY: function (t) { return this.y = t, this }, setZ: function (t) { return this.z = t, this }, setW: function (t) { return this.w = t, this }, setComponent: function (t, e) { switch (t) { case 0: this.x = e; break; case 1: this.y = e; break; case 2: this.z = e; break; case 3: this.w = e; break; default: throw Error("index is out of range: " + t) }return this }, getComponent: function (t) { switch (t) { case 0: return this.x; case 1: return this.y; case 2: return this.z; case 3: return this.w; default: throw Error("index is out of range: " + t) } }, clone: function () { return new this.constructor(this.x, this.y, this.z, this.w) }, copy: function (t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = void 0 !== t.w ? t.w : 1, this }, add: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead."), this.addVectors(t, e)) : (this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this) }, addScalar: function (t) { return this.x += t, this.y += t, this.z += t, this.w += t, this }, addVectors: function (t, e) { return this.x = t.x + e.x, this.y = t.y + e.y, this.z = t.z + e.z, this.w = t.w + e.w, this }, addScaledVector: function (t, e) { return this.x += t.x * e, this.y += t.y * e, this.z += t.z * e, this.w += t.w * e, this }, sub: function (t, e) { return void 0 !== e ? (console.warn("THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead."), this.subVectors(t, e)) : (this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this) }, subScalar: function (t) { return this.x -= t, this.y -= t, this.z -= t, this.w -= t, this }, subVectors: function (t, e) { return this.x = t.x - e.x, this.y = t.y - e.y, this.z = t.z - e.z, this.w = t.w - e.w, this }, multiplyScalar: function (t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this }, applyMatrix4: function (t) { var e = this.x, i = this.y, n = this.z, r = this.w; return t = t.elements, this.x = t[0] * e + t[4] * i + t[8] * n + t[12] * r, this.y = t[1] * e + t[5] * i + t[9] * n + t[13] * r, this.z = t[2] * e + t[6] * i + t[10] * n + t[14] * r, this.w = t[3] * e + t[7] * i + t[11] * n + t[15] * r, this }, divideScalar: function (t) { return this.multiplyScalar(1 / t) }, setAxisAngleFromQuaternion: function (t) { this.w = 2 * Math.acos(t.w); var e = Math.sqrt(1 - t.w * t.w); return 1e-4 > e ? (this.x = 1, this.z = this.y = 0) : (this.x = t.x / e, this.y = t.y / e, this.z = t.z / e), this }, setAxisAngleFromRotationMatrix: function (t) { var e = (t = t.elements)[0], i = t[4], n = t[8], r = t[1], o = t[5], a = t[9], s = t[2], c = t[6], h = t[10]; return .01 > Math.abs(i - r) && .01 > Math.abs(n - s) && .01 > Math.abs(a - c) ? .1 > Math.abs(i + r) && .1 > Math.abs(n + s) && .1 > Math.abs(a + c) && .1 > Math.abs(e + o + h - 3) ? (this.set(1, 0, 0, 0), this) : (t = Math.PI, h = (h + 1) / 2, i = (i + r) / 4, n = (n + s) / 4, a = (a + c) / 4, (e = (e + 1) / 2) > (o = (o + 1) / 2) && e > h ? .01 > e ? (c = 0, i = s = .707106781) : (s = i / (c = Math.sqrt(e)), i = n / c) : o > h ? .01 > o ? (c = .707106781, s = 0, i = .707106781) : (c = i / (s = Math.sqrt(o)), i = a / s) : .01 > h ? (s = c = .707106781, i = 0) : (c = n / (i = Math.sqrt(h)), s = a / i), this.set(c, s, i, t), this) : (t = Math.sqrt((c - a) * (c - a) + (n - s) * (n - s) + (r - i) * (r - i)), .001 > Math.abs(t) && (t = 1), this.x = (c - a) / t, this.y = (n - s) / t, this.z = (r - i) / t, this.w = Math.acos((e + o + h - 1) / 2), this) }, min: function (t) { return this.x = Math.min(this.x, t.x), this.y = Math.min(this.y, t.y), this.z = Math.min(this.z, t.z), this.w = Math.min(this.w, t.w), this }, max: function (t) { return this.x = Math.max(this.x, t.x), this.y = Math.max(this.y, t.y), this.z = Math.max(this.z, t.z), this.w = Math.max(this.w, t.w), this }, clamp: function (t, e) { return this.x = Math.max(t.x, Math.min(e.x, this.x)), this.y = Math.max(t.y, Math.min(e.y, this.y)), this.z = Math.max(t.z, Math.min(e.z, this.z)), this.w = Math.max(t.w, Math.min(e.w, this.w)), this }, clampScalar: function () { var t, e; return function (i, n) { return void 0 === t && (t = new s, e = new s), t.set(i, i, i, i), e.set(n, n, n, n), this.clamp(t, e) } }(), clampLength: function (t, e) { var i = this.length(); return this.divideScalar(i || 1).multiplyScalar(Math.max(t, Math.min(e, i))) }, floor: function () { return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this }, ceil: function () { return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this }, round: function () { return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this }, roundToZero: function () { return this.x = 0 > this.x ? Math.ceil(this.x) : Math.floor(this.x), this.y = 0 > this.y ? Math.ceil(this.y) : Math.floor(this.y), this.z = 0 > this.z ? Math.ceil(this.z) : Math.floor(this.z), this.w = 0 > this.w ? Math.ceil(this.w) : Math.floor(this.w), this }, negate: function () { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this }, dot: function (t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w }, lengthSq: function () { return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w }, length: function () { return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w) }, manhattanLength: function () { return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w) }, normalize: function () { return this.divideScalar(this.length() || 1) }, setLength: function (t) { return this.normalize().multiplyScalar(t) }, lerp: function (t, e) { return this.x += (t.x - this.x) * e, this.y += (t.y - this.y) * e, this.z += (t.z - this.z) * e, this.w += (t.w - this.w) * e, this }, lerpVectors: function (t, e, i) { return this.subVectors(e, t).multiplyScalar(i).add(t) }, equals: function (t) { return t.x === this.x && t.y === this.y && t.z === this.z && t.w === this.w }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.x = t[e], this.y = t[e + 1], this.z = t[e + 2], this.w = t[e + 3], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.x, t[e + 1] = this.y, t[e + 2] = this.z, t[e + 3] = this.w, t }, fromBufferAttribute: function (t, e, i) { return void 0 !== i && console.warn("THREE.Vector4: offset has been removed from .fromBufferAttribute()."), this.x = t.getX(e), this.y = t.getY(e), this.z = t.getZ(e), this.w = t.getW(e), this } }), c.prototype = Object.assign(Object.create(e.prototype), { constructor: c, isWebGLRenderTarget: !0, setSize: function (t, e) { this.width === t && this.height === e || (this.width = t, this.height = e, this.dispose()), this.viewport.set(0, 0, t, e), this.scissor.set(0, 0, t, e) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.width = t.width, this.height = t.height, this.viewport.copy(t.viewport), this.texture = t.texture.clone(), this.depthBuffer = t.depthBuffer, this.stencilBuffer = t.stencilBuffer, this.depthTexture = t.depthTexture, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), h.prototype = Object.assign(Object.create(c.prototype), { constructor: h, isWebGLMultisampleRenderTarget: !0, copy: function (t) { return c.prototype.copy.call(this, t), this.samples = t.samples, this } }), l.prototype = Object.create(c.prototype), l.prototype.constructor = l, l.prototype.isWebGLRenderTargetCube = !0, u.prototype = Object.create(a.prototype), u.prototype.constructor = u, u.prototype.isDataTexture = !0, Object.assign(d.prototype, { isBox3: !0, set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromArray: function (t) { for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.length; s < c; s += 3) { var h = t[s], l = t[s + 1], u = t[s + 2]; h < e && (e = h), l < i && (i = l), u < n && (n = u), h > r && (r = h), l > o && (o = l), u > a && (a = u) } return this.min.set(e, i, n), this.max.set(r, o, a), this }, setFromBufferAttribute: function (t) { for (var e = 1 / 0, i = 1 / 0, n = 1 / 0, r = -1 / 0, o = -1 / 0, a = -1 / 0, s = 0, c = t.count; s < c; s++) { var h = t.getX(s), l = t.getY(s), u = t.getZ(s); h < e && (e = h), l < i && (i = l), u < n && (n = u), h > r && (r = h), l > o && (o = l), u > a && (a = u) } return this.min.set(e, i, n), this.max.set(r, o, a), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, i = t.length; e < i; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function () { var t = new r; return function (e, i) { return i = t.copy(i).multiplyScalar(.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this } }(), setFromObject: function (t) { return this.makeEmpty(), this.expandByObject(t) }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getCenter() target is now required"), t = new r), this.isEmpty() ? t.set(0, 0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box3: .getSize() target is now required"), t = new r), this.isEmpty() ? t.set(0, 0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, expandByObject: function () { function t(t) { var r = t.geometry; if (void 0 !== r) if (r.isGeometry) for (r = r.vertices, i = 0, n = r.length; i < n; i++)o.copy(r[i]), o.applyMatrix4(t.matrixWorld), e.expandByPoint(o); else if (r.isBufferGeometry && void 0 !== (r = r.attributes.position)) for (i = 0, n = r.count; i < n; i++)o.fromBufferAttribute(r, i).applyMatrix4(t.matrixWorld), e.expandByPoint(o) } var e, i, n, o = new r; return function (i) { return e = this, i.updateMatrixWorld(!0), i.traverse(t), this } }(), containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y || t.z < this.min.z || t.z > this.max.z) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y && this.min.z <= t.min.z && t.max.z <= this.max.z }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .getParameter() target is now required"), e = new r), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y), (t.z - this.min.z) / (this.max.z - this.min.z)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y || t.max.z < this.min.z || t.min.z > this.max.z) }, intersectsSphere: function () { var t = new r; return function (e) { return this.clampPoint(e.center, t), t.distanceToSquared(e.center) <= e.radius * e.radius } }(), intersectsPlane: function (t) { if (0 < t.normal.x) var e = t.normal.x * this.min.x, i = t.normal.x * this.max.x; else e = t.normal.x * this.max.x, i = t.normal.x * this.min.x; return 0 < t.normal.y ? (e += t.normal.y * this.min.y, i += t.normal.y * this.max.y) : (e += t.normal.y * this.max.y, i += t.normal.y * this.min.y), 0 < t.normal.z ? (e += t.normal.z * this.min.z, i += t.normal.z * this.max.z) : (e += t.normal.z * this.max.z, i += t.normal.z * this.min.z), e <= -t.constant && i >= -t.constant }, intersectsTriangle: function () { function t(t) { var r, o = 0; for (r = t.length - 3; o <= r; o += 3) { c.fromArray(t, o); var a = l.x * Math.abs(c.x) + l.y * Math.abs(c.y) + l.z * Math.abs(c.z), s = e.dot(c), h = i.dot(c), u = n.dot(c); if (Math.max(-Math.max(s, h, u), Math.min(s, h, u)) > a) return !1 } return !0 } var e = new r, i = new r, n = new r, o = new r, a = new r, s = new r, c = new r, h = new r, l = new r, u = new r; return function (r) { return !this.isEmpty() && (this.getCenter(h), l.subVectors(this.max, h), e.subVectors(r.a, h), i.subVectors(r.b, h), n.subVectors(r.c, h), o.subVectors(i, e), a.subVectors(n, i), s.subVectors(e, n), !!t(r = [0, -o.z, o.y, 0, -a.z, a.y, 0, -s.z, s.y, o.z, 0, -o.x, a.z, 0, -a.x, s.z, 0, -s.x, -o.y, o.x, 0, -a.y, a.x, 0, -s.y, s.x, 0]) && (!!t(r = [1, 0, 0, 0, 1, 0, 0, 0, 1]) && (u.crossVectors(o, a), t(r = [u.x, u.y, u.z])))) } }(), clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box3: .clampPoint() target is now required"), e = new r), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function () { var t = new r; return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }(), getBoundingSphere: function () { var t = new r; return function (e) { return void 0 === e && console.error("THREE.Box3: .getBoundingSphere() target is now required"), this.getCenter(e.center), e.radius = .5 * this.getSize(t).length(), e } }(), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this.isEmpty() && this.makeEmpty(), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, applyMatrix4: function () { var t = [new r, new r, new r, new r, new r, new r, new r, new r]; return function (e) { return this.isEmpty() || (t[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), t[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), t[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), t[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), t[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), t[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), t[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), t[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(t)), this } }(), translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }), Object.assign(p.prototype, { set: function (t, e) { return this.center.copy(t), this.radius = e, this }, setFromPoints: function () { var t = new d; return function (e, i) { var n = this.center; void 0 !== i ? n.copy(i) : t.setFromPoints(e).getCenter(n); for (var r = i = 0, o = e.length; r < o; r++)i = Math.max(i, n.distanceToSquared(e[r])); return this.radius = Math.sqrt(i), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.center.copy(t.center), this.radius = t.radius, this }, empty: function () { return 0 >= this.radius }, containsPoint: function (t) { return t.distanceToSquared(this.center) <= this.radius * this.radius }, distanceToPoint: function (t) { return t.distanceTo(this.center) - this.radius }, intersectsSphere: function (t) { var e = this.radius + t.radius; return t.center.distanceToSquared(this.center) <= e * e }, intersectsBox: function (t) { return t.intersectsSphere(this) }, intersectsPlane: function (t) { return Math.abs(t.distanceToPoint(this.center)) <= this.radius }, clampPoint: function (t, e) { var i = this.center.distanceToSquared(t); return void 0 === e && (console.warn("THREE.Sphere: .clampPoint() target is now required"), e = new r), e.copy(t), i > this.radius * this.radius && (e.sub(this.center).normalize(), e.multiplyScalar(this.radius).add(this.center)), e }, getBoundingBox: function (t) { return void 0 === t && (console.warn("THREE.Sphere: .getBoundingBox() target is now required"), t = new d), t.set(this.center, this.center), t.expandByScalar(this.radius), t }, applyMatrix4: function (t) { return this.center.applyMatrix4(t), this.radius *= t.getMaxScaleOnAxis(), this }, translate: function (t) { return this.center.add(t), this }, equals: function (t) { return t.center.equals(this.center) && t.radius === this.radius } }), Object.assign(f.prototype, { set: function (t, e) { return this.normal.copy(t), this.constant = e, this }, setComponents: function (t, e, i, n) { return this.normal.set(t, e, i), this.constant = n, this }, setFromNormalAndCoplanarPoint: function (t, e) { return this.normal.copy(t), this.constant = -e.dot(this.normal), this }, setFromCoplanarPoints: function () { var t = new r, e = new r; return function (i, n, r) { return n = t.subVectors(r, n).cross(e.subVectors(i, n)).normalize(), this.setFromNormalAndCoplanarPoint(n, i), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.normal.copy(t.normal), this.constant = t.constant, this }, normalize: function () { var t = 1 / this.normal.length(); return this.normal.multiplyScalar(t), this.constant *= t, this }, negate: function () { return this.constant *= -1, this.normal.negate(), this }, distanceToPoint: function (t) { return this.normal.dot(t) + this.constant }, distanceToSphere: function (t) { return this.distanceToPoint(t.center) - t.radius }, projectPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Plane: .projectPoint() target is now required"), e = new r), e.copy(this.normal).multiplyScalar(-this.distanceToPoint(t)).add(t) }, intersectLine: function () { var t = new r; return function (e, i) { void 0 === i && (console.warn("THREE.Plane: .intersectLine() target is now required"), i = new r); var n = e.delta(t), o = this.normal.dot(n); if (0 === o) { if (0 === this.distanceToPoint(e.start)) return i.copy(e.start) } else if (!(0 > (o = -(e.start.dot(this.normal) + this.constant) / o) || 1 < o)) return i.copy(n).multiplyScalar(o).add(e.start) } }(), intersectsLine: function (t) { var e = this.distanceToPoint(t.start); return t = this.distanceToPoint(t.end), 0 > e && 0 < t || 0 > t && 0 < e }, intersectsBox: function (t) { return t.intersectsPlane(this) }, intersectsSphere: function (t) { return t.intersectsPlane(this) }, coplanarPoint: function (t) { return void 0 === t && (console.warn("THREE.Plane: .coplanarPoint() target is now required"), t = new r), t.copy(this.normal).multiplyScalar(-this.constant) }, applyMatrix4: function () { var t = new r, e = new o; return function (i, n) { return n = n || e.getNormalMatrix(i), i = this.coplanarPoint(t).applyMatrix4(i), n = this.normal.applyMatrix3(n).normalize(), this.constant = -i.dot(n), this } }(), translate: function (t) { return this.constant -= t.dot(this.normal), this }, equals: function (t) { return t.normal.equals(this.normal) && t.constant === this.constant } }), Object.assign(m.prototype, { set: function (t, e, i, n, r, o) { var a = this.planes; return a[0].copy(t), a[1].copy(e), a[2].copy(i), a[3].copy(n), a[4].copy(r), a[5].copy(o), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { for (var e = this.planes, i = 0; 6 > i; i++)e[i].copy(t.planes[i]); return this }, setFromMatrix: function (t) { var e = this.planes, i = t.elements; t = i[0]; var n = i[1], r = i[2], o = i[3], a = i[4], s = i[5], c = i[6], h = i[7], l = i[8], u = i[9], d = i[10], p = i[11], f = i[12], m = i[13], g = i[14]; return i = i[15], e[0].setComponents(o - t, h - a, p - l, i - f).normalize(), e[1].setComponents(o + t, h + a, p + l, i + f).normalize(), e[2].setComponents(o + n, h + s, p + u, i + m).normalize(), e[3].setComponents(o - n, h - s, p - u, i - m).normalize(), e[4].setComponents(o - r, h - c, p - d, i - g).normalize(), e[5].setComponents(o + r, h + c, p + d, i + g).normalize(), this }, intersectsObject: function () { var t = new p; return function (e) { var i = e.geometry; return null === i.boundingSphere && i.computeBoundingSphere(), t.copy(i.boundingSphere).applyMatrix4(e.matrixWorld), this.intersectsSphere(t) } }(), intersectsSprite: function () { var t = new p; return function (e) { return t.center.set(0, 0, 0), t.radius = .7071067811865476, t.applyMatrix4(e.matrixWorld), this.intersectsSphere(t) } }(), intersectsSphere: function (t) { var e = this.planes, i = t.center; t = -t.radius; for (var n = 0; 6 > n; n++)if (e[n].distanceToPoint(i) < t) return !1; return !0 }, intersectsBox: function () { var t = new r; return function (e) { for (var i = this.planes, n = 0; 6 > n; n++) { var r = i[n]; if (t.x = 0 < r.normal.x ? e.max.x : e.min.x, t.y = 0 < r.normal.y ? e.max.y : e.min.y, t.z = 0 < r.normal.z ? e.max.z : e.min.z, 0 > r.distanceToPoint(t)) return !1 } return !0 } }(), containsPoint: function (t) { for (var e = this.planes, i = 0; 6 > i; i++)if (0 > e[i].distanceToPoint(t)) return !1; return !0 } }), Object.assign(g.prototype, { isMatrix4: !0, set: function (t, e, i, n, r, o, a, s, c, h, l, u, d, p, f, m) { var g = this.elements; return g[0] = t, g[4] = e, g[8] = i, g[12] = n, g[1] = r, g[5] = o, g[9] = a, g[13] = s, g[2] = c, g[6] = h, g[10] = l, g[14] = u, g[3] = d, g[7] = p, g[11] = f, g[15] = m, this }, identity: function () { return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, clone: function () { return (new g).fromArray(this.elements) }, copy: function (t) { var e = this.elements; return t = t.elements, e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this }, copyPosition: function (t) { var e = this.elements; return t = t.elements, e[12] = t[12], e[13] = t[13], e[14] = t[14], this }, extractBasis: function (t, e, i) { return t.setFromMatrixColumn(this, 0), e.setFromMatrixColumn(this, 1), i.setFromMatrixColumn(this, 2), this }, makeBasis: function (t, e, i) { return this.set(t.x, e.x, i.x, 0, t.y, e.y, i.y, 0, t.z, e.z, i.z, 0, 0, 0, 0, 1), this }, extractRotation: function () { var t = new r; return function (e) { var i = this.elements, n = e.elements, r = 1 / t.setFromMatrixColumn(e, 0).length(), o = 1 / t.setFromMatrixColumn(e, 1).length(); return e = 1 / t.setFromMatrixColumn(e, 2).length(), i[0] = n[0] * r, i[1] = n[1] * r, i[2] = n[2] * r, i[3] = 0, i[4] = n[4] * o, i[5] = n[5] * o, i[6] = n[6] * o, i[7] = 0, i[8] = n[8] * e, i[9] = n[9] * e, i[10] = n[10] * e, i[11] = 0, i[12] = 0, i[13] = 0, i[14] = 0, i[15] = 1, this } }(), makeRotationFromEuler: function (t) { t && t.isEuler || console.error("THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order."); var e = this.elements, i = t.x, n = t.y, r = t.z, o = Math.cos(i); i = Math.sin(i); var a = Math.cos(n); n = Math.sin(n); var s = Math.cos(r); if (r = Math.sin(r), "XYZ" === t.order) { t = o * s; var c = o * r, h = i * s, l = i * r; e[0] = a * s, e[4] = -a * r, e[8] = n, e[1] = c + h * n, e[5] = t - l * n, e[9] = -i * a, e[2] = l - t * n, e[6] = h + c * n, e[10] = o * a } else "YXZ" === t.order ? (t = a * s, c = a * r, h = n * s, l = n * r, e[0] = t + l * i, e[4] = h * i - c, e[8] = o * n, e[1] = o * r, e[5] = o * s, e[9] = -i, e[2] = c * i - h, e[6] = l + t * i, e[10] = o * a) : "ZXY" === t.order ? (t = a * s, c = a * r, h = n * s, l = n * r, e[0] = t - l * i, e[4] = -o * r, e[8] = h + c * i, e[1] = c + h * i, e[5] = o * s, e[9] = l - t * i, e[2] = -o * n, e[6] = i, e[10] = o * a) : "ZYX" === t.order ? (t = o * s, c = o * r, h = i * s, l = i * r, e[0] = a * s, e[4] = h * n - c, e[8] = t * n + l, e[1] = a * r, e[5] = l * n + t, e[9] = c * n - h, e[2] = -n, e[6] = i * a, e[10] = o * a) : "YZX" === t.order ? (t = o * a, c = o * n, h = i * a, l = i * n, e[0] = a * s, e[4] = l - t * r, e[8] = h * r + c, e[1] = r, e[5] = o * s, e[9] = -i * s, e[2] = -n * s, e[6] = c * r + h, e[10] = t - l * r) : "XZY" === t.order && (t = o * a, c = o * n, h = i * a, l = i * n, e[0] = a * s, e[4] = -r, e[8] = n * s, e[1] = t * r + l, e[5] = o * s, e[9] = c * r - h, e[2] = h * r - c, e[6] = i * s, e[10] = l * r + t); return e[3] = 0, e[7] = 0, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this }, makeRotationFromQuaternion: function () { var t = new r(0, 0, 0), e = new r(1, 1, 1); return function (i) { return this.compose(t, i, e) } }(), lookAt: function () { var t = new r, e = new r, i = new r; return function (n, r, o) { var a = this.elements; return i.subVectors(n, r), 0 === i.lengthSq() && (i.z = 1), i.normalize(), t.crossVectors(o, i), 0 === t.lengthSq() && (1 === Math.abs(o.z) ? i.x += 1e-4 : i.z += 1e-4, i.normalize(), t.crossVectors(o, i)), t.normalize(), e.crossVectors(i, t), a[0] = t.x, a[4] = e.x, a[8] = i.x, a[1] = t.y, a[5] = e.y, a[9] = i.y, a[2] = t.z, a[6] = e.z, a[10] = i.z, this } }(), multiply: function (t, e) { return void 0 !== e ? (console.warn("THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead."), this.multiplyMatrices(t, e)) : this.multiplyMatrices(this, t) }, premultiply: function (t) { return this.multiplyMatrices(t, this) }, multiplyMatrices: function (t, e) { var i = t.elements, n = e.elements; e = this.elements, t = i[0]; var r = i[4], o = i[8], a = i[12], s = i[1], c = i[5], h = i[9], l = i[13], u = i[2], d = i[6], p = i[10], f = i[14], m = i[3], g = i[7], v = i[11]; i = i[15]; var y = n[0], x = n[4], b = n[8], w = n[12], M = n[1], _ = n[5], E = n[9], A = n[13], T = n[2], S = n[6], L = n[10], C = n[14], R = n[3], P = n[7], I = n[11]; return n = n[15], e[0] = t * y + r * M + o * T + a * R, e[4] = t * x + r * _ + o * S + a * P, e[8] = t * b + r * E + o * L + a * I, e[12] = t * w + r * A + o * C + a * n, e[1] = s * y + c * M + h * T + l * R, e[5] = s * x + c * _ + h * S + l * P, e[9] = s * b + c * E + h * L + l * I, e[13] = s * w + c * A + h * C + l * n, e[2] = u * y + d * M + p * T + f * R, e[6] = u * x + d * _ + p * S + f * P, e[10] = u * b + d * E + p * L + f * I, e[14] = u * w + d * A + p * C + f * n, e[3] = m * y + g * M + v * T + i * R, e[7] = m * x + g * _ + v * S + i * P, e[11] = m * b + g * E + v * L + i * I, e[15] = m * w + g * A + v * C + i * n, this }, multiplyScalar: function (t) { var e = this.elements; return e[0] *= t, e[4] *= t, e[8] *= t, e[12] *= t, e[1] *= t, e[5] *= t, e[9] *= t, e[13] *= t, e[2] *= t, e[6] *= t, e[10] *= t, e[14] *= t, e[3] *= t, e[7] *= t, e[11] *= t, e[15] *= t, this }, applyToBufferAttribute: function () { var t = new r; return function (e) { for (var i = 0, n = e.count; i < n; i++)t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.applyMatrix4(this), e.setXYZ(i, t.x, t.y, t.z); return e } }(), determinant: function () { var t = this.elements, e = t[0], i = t[4], n = t[8], r = t[12], o = t[1], a = t[5], s = t[9], c = t[13], h = t[2], l = t[6], u = t[10], d = t[14]; return t[3] * (+r * s * l - n * c * l - r * a * u + i * c * u + n * a * d - i * s * d) + t[7] * (+e * s * d - e * c * u + r * o * u - n * o * d + n * c * h - r * s * h) + t[11] * (+e * c * l - e * a * d - r * o * l + i * o * d + r * a * h - i * c * h) + t[15] * (-n * a * h - e * s * l + e * a * u + n * o * l - i * o * u + i * s * h) }, transpose: function () { var t = this.elements, e = t[1]; return t[1] = t[4], t[4] = e, e = t[2], t[2] = t[8], t[8] = e, e = t[6], t[6] = t[9], t[9] = e, e = t[3], t[3] = t[12], t[12] = e, e = t[7], t[7] = t[13], t[13] = e, e = t[11], t[11] = t[14], t[14] = e, this }, setPosition: function (t, e, i) { var n = this.elements; return t.isVector3 ? (n[12] = t.x, n[13] = t.y, n[14] = t.z) : (n[12] = t, n[13] = e, n[14] = i), this }, getInverse: function (t, e) { var i = this.elements, n = t.elements; t = n[0]; var r = n[1], o = n[2], a = n[3], s = n[4], c = n[5], h = n[6], l = n[7], u = n[8], d = n[9], p = n[10], f = n[11], m = n[12], g = n[13], v = n[14], y = d * v * l - g * p * l + g * h * f - c * v * f - d * h * (n = n[15]) + c * p * n, x = m * p * l - u * v * l - m * h * f + s * v * f + u * h * n - s * p * n, b = u * g * l - m * d * l + m * c * f - s * g * f - u * c * n + s * d * n, w = m * d * h - u * g * h - m * c * p + s * g * p + u * c * v - s * d * v, M = t * y + r * x + o * b + a * w; if (0 === M) { if (!0 === e) throw Error("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"); return console.warn("THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0"), this.identity() } return e = 1 / M, i[0] = y * e, i[1] = (g * p * a - d * v * a - g * o * f + r * v * f + d * o * n - r * p * n) * e, i[2] = (c * v * a - g * h * a + g * o * l - r * v * l - c * o * n + r * h * n) * e, i[3] = (d * h * a - c * p * a - d * o * l + r * p * l + c * o * f - r * h * f) * e, i[4] = x * e, i[5] = (u * v * a - m * p * a + m * o * f - t * v * f - u * o * n + t * p * n) * e, i[6] = (m * h * a - s * v * a - m * o * l + t * v * l + s * o * n - t * h * n) * e, i[7] = (s * p * a - u * h * a + u * o * l - t * p * l - s * o * f + t * h * f) * e, i[8] = b * e, i[9] = (m * d * a - u * g * a - m * r * f + t * g * f + u * r * n - t * d * n) * e, i[10] = (s * g * a - m * c * a + m * r * l - t * g * l - s * r * n + t * c * n) * e, i[11] = (u * c * a - s * d * a - u * r * l + t * d * l + s * r * f - t * c * f) * e, i[12] = w * e, i[13] = (u * g * o - m * d * o + m * r * p - t * g * p - u * r * v + t * d * v) * e, i[14] = (m * c * o - s * g * o - m * r * h + t * g * h + s * r * v - t * c * v) * e, i[15] = (s * d * o - u * c * o + u * r * h - t * d * h - s * r * p + t * c * p) * e, this }, scale: function (t) { var e = this.elements, i = t.x, n = t.y; return t = t.z, e[0] *= i, e[4] *= n, e[8] *= t, e[1] *= i, e[5] *= n, e[9] *= t, e[2] *= i, e[6] *= n, e[10] *= t, e[3] *= i, e[7] *= n, e[11] *= t, this }, getMaxScaleOnAxis: function () { var t = this.elements; return Math.sqrt(Math.max(t[0] * t[0] + t[1] * t[1] + t[2] * t[2], t[4] * t[4] + t[5] * t[5] + t[6] * t[6], t[8] * t[8] + t[9] * t[9] + t[10] * t[10])) }, makeTranslation: function (t, e, i) { return this.set(1, 0, 0, t, 0, 1, 0, e, 0, 0, 1, i, 0, 0, 0, 1), this }, makeRotationX: function (t) { var e = Math.cos(t); return t = Math.sin(t), this.set(1, 0, 0, 0, 0, e, -t, 0, 0, t, e, 0, 0, 0, 0, 1), this }, makeRotationY: function (t) { var e = Math.cos(t); return t = Math.sin(t), this.set(e, 0, t, 0, 0, 1, 0, 0, -t, 0, e, 0, 0, 0, 0, 1), this }, makeRotationZ: function (t) { var e = Math.cos(t); return t = Math.sin(t), this.set(e, -t, 0, 0, t, e, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this }, makeRotationAxis: function (t, e) { var i = Math.cos(e); e = Math.sin(e); var n = 1 - i, r = t.x, o = t.y; t = t.z; var a = n * r, s = n * o; return this.set(a * r + i, a * o - e * t, a * t + e * o, 0, a * o + e * t, s * o + i, s * t - e * r, 0, a * t - e * o, s * t + e * r, n * t * t + i, 0, 0, 0, 0, 1), this }, makeScale: function (t, e, i) { return this.set(t, 0, 0, 0, 0, e, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this }, makeShear: function (t, e, i) { return this.set(1, e, i, 0, t, 1, i, 0, t, e, 1, 0, 0, 0, 0, 1), this }, compose: function (t, e, i) { var n = this.elements, r = e._x, o = e._y, a = e._z, s = e._w, c = r + r, h = o + o, l = a + a; e = r * c; var u = r * h; r *= l; var d = o * h; o *= l, a *= l, c *= s, h *= s, s *= l, l = i.x; var p = i.y; return i = i.z, n[0] = (1 - (d + a)) * l, n[1] = (u + s) * l, n[2] = (r - h) * l, n[3] = 0, n[4] = (u - s) * p, n[5] = (1 - (e + a)) * p, n[6] = (o + c) * p, n[7] = 0, n[8] = (r + h) * i, n[9] = (o - c) * i, n[10] = (1 - (e + d)) * i, n[11] = 0, n[12] = t.x, n[13] = t.y, n[14] = t.z, n[15] = 1, this }, decompose: function () { var t = new r, e = new g; return function (i, n, r) { var o = this.elements, a = t.set(o[0], o[1], o[2]).length(), s = t.set(o[4], o[5], o[6]).length(), c = t.set(o[8], o[9], o[10]).length(); 0 > this.determinant() && (a = -a), i.x = o[12], i.y = o[13], i.z = o[14], e.copy(this), i = 1 / a, o = 1 / s; var h = 1 / c; return e.elements[0] *= i, e.elements[1] *= i, e.elements[2] *= i, e.elements[4] *= o, e.elements[5] *= o, e.elements[6] *= o, e.elements[8] *= h, e.elements[9] *= h, e.elements[10] *= h, n.setFromRotationMatrix(e), r.x = a, r.y = s, r.z = c, this } }(), makePerspective: function (t, e, i, n, r, o) { void 0 === o && console.warn("THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs."); var a = this.elements; return a[0] = 2 * r / (e - t), a[4] = 0, a[8] = (e + t) / (e - t), a[12] = 0, a[1] = 0, a[5] = 2 * r / (i - n), a[9] = (i + n) / (i - n), a[13] = 0, a[2] = 0, a[6] = 0, a[10] = -(o + r) / (o - r), a[14] = -2 * o * r / (o - r), a[3] = 0, a[7] = 0, a[11] = -1, a[15] = 0, this }, makeOrthographic: function (t, e, i, n, r, o) { var a = this.elements, s = 1 / (e - t), c = 1 / (i - n), h = 1 / (o - r); return a[0] = 2 * s, a[4] = 0, a[8] = 0, a[12] = -(e + t) * s, a[1] = 0, a[5] = 2 * c, a[9] = 0, a[13] = -(i + n) * c, a[2] = 0, a[6] = 0, a[10] = -2 * h, a[14] = -(o + r) * h, a[3] = 0, a[7] = 0, a[11] = 0, a[15] = 1, this }, equals: function (t) { var e = this.elements; t = t.elements; for (var i = 0; 16 > i; i++)if (e[i] !== t[i]) return !1; return !0 }, fromArray: function (t, e) { void 0 === e && (e = 0); for (var i = 0; 16 > i; i++)this.elements[i] = t[i + e]; return this }, toArray: function (t, e) { void 0 === t && (t = []), void 0 === e && (e = 0); var i = this.elements; return t[e] = i[0], t[e + 1] = i[1], t[e + 2] = i[2], t[e + 3] = i[3], t[e + 4] = i[4], t[e + 5] = i[5], t[e + 6] = i[6], t[e + 7] = i[7], t[e + 8] = i[8], t[e + 9] = i[9], t[e + 10] = i[10], t[e + 11] = i[11], t[e + 12] = i[12], t[e + 13] = i[13], t[e + 14] = i[14], t[e + 15] = i[15], t } }); var yo = { alphamap_fragment: "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif", alphamap_pars_fragment: "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif", alphatest_fragment: "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif", aomap_fragment: "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif", aomap_pars_fragment: "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif", begin_vertex: "vec3 transformed = vec3( position );", beginnormal_vertex: "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif", bsdfs: "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nvec3 F_Schlick_RoughnessDependent( const in vec3 F0, const in float dotNV, const in float roughness ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotNV - 6.98316 ) * dotNV );\n\tvec3 Fr = max( vec3( 1.0 - roughness ), F0 ) - F0;\n\treturn Fr * fresnel + F0;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick_RoughnessDependent( specularColor, dotNV, roughness );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}", bumpmap_pars_fragment: "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif", clipping_planes_fragment: "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif", clipping_planes_pars_fragment: "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif", clipping_planes_pars_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif", clipping_planes_vertex: "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif", color_fragment: "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif", color_pars_fragment: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_pars_vertex: "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif", color_vertex: "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif", common: "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}", cube_uv_reflection_fragment: "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif", defaultnormal_vertex: "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = normalMatrix * objectTangent;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif", displacementmap_pars_vertex: "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif", displacementmap_vertex: "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif", emissivemap_fragment: "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif", emissivemap_pars_fragment: "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif", encodings_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );", encodings_pars_fragment: "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}", envmap_fragment: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif", envmap_pars_fragment: "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif", envmap_pars_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif", envmap_physical_pars_fragment: "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif", envmap_vertex: "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif", fog_vertex: "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif", fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif", fog_fragment: "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif", fog_pars_fragment: "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif", gradientmap_pars_fragment: "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif", lightmap_fragment: "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif", lightmap_pars_fragment: "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif", lights_lambert_vertex: "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif", lights_pars_begin: "uniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in GeometricContext geometry ) {\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif", lights_phong_fragment: "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;", lights_phong_pars_fragment: "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)", lights_physical_fragment: "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif", lights_physical_pars_fragment: "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor * ( 1.0 - ( singleScattering + multiScattering ) );\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}", lights_fragment_begin: "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif", lights_fragment_maps: "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif", lights_fragment_end: "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif", logdepthbuf_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif", logdepthbuf_pars_fragment: "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif", logdepthbuf_pars_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif", logdepthbuf_vertex: "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif", map_fragment: "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif", map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif", map_particle_fragment: "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif", map_particle_pars_fragment: "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif", metalnessmap_fragment: "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif", metalnessmap_pars_fragment: "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif", morphnormal_vertex: "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif", morphtarget_pars_vertex: "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif", morphtarget_vertex: "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif", normal_fragment_begin: "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent = normalize( vTangent );\n\t\tvec3 bitangent = normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent = tangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\tbitangent = bitangent * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t#endif\n#endif", normal_fragment_maps: "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\t#ifdef USE_TANGENT\n\t\t\tmat3 vTBN = mat3( tangent, bitangent, normal );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy = normalScale * mapN.xy;\n\t\t\tnormal = normalize( vTBN * mapN );\n\t\t#else\n\t\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t\t#endif\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif", normalmap_pars_fragment: "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif", packing: "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}", premultiplied_alpha_fragment: "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif", project_vertex: "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;", dithering_fragment: "#if defined( DITHERING )\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif", dithering_pars_fragment: "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif", roughnessmap_fragment: "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif", roughnessmap_pars_fragment: "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif", shadowmap_pars_fragment: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif", shadowmap_pars_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif", shadowmap_vertex: "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif", shadowmask_pars_fragment: "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}", skinbase_vertex: "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif", skinning_pars_vertex: "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif", skinning_vertex: "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif", skinnormal_vertex: "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif", specularmap_fragment: "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif", specularmap_pars_fragment: "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif", tonemapping_fragment: "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif", tonemapping_pars_fragment: "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}", uv_pars_fragment: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif", uv_pars_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif", uv_vertex: "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif", uv2_pars_fragment: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif", uv2_pars_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif", uv2_vertex: "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif", worldpos_vertex: "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif", background_frag: "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", background_vert: "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}", cube_frag: "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", cube_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}", depth_frag: "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}", depth_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}", distanceRGBA_frag: "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}", distanceRGBA_vert: "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}", equirect_frag: "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}", equirect_vert: "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}", linedashed_frag: "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", linedashed_vert: "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}", meshbasic_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshbasic_vert: "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}", meshlambert_frag: "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshlambert_vert: "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshmatcap_frag: "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", meshmatcap_vert: "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}", meshphong_frag: "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphong_vert: "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", meshphysical_frag: "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}", meshphysical_vert: "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", normal_frag: "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}", normal_vert: "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}", points_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", points_vert: "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}", shadow_frag: "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}", shadow_vert: "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}", sprite_frag: "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}", sprite_vert: "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}" }, xo = { clone: v, merge: y }, bo = { aliceblue: 15792383, antiquewhite: 16444375, aqua: 65535, aquamarine: 8388564, azure: 15794175, beige: 16119260, bisque: 16770244, black: 0, blanchedalmond: 16772045, blue: 255, blueviolet: 9055202, brown: 10824234, burlywood: 14596231, cadetblue: 6266528, chartreuse: 8388352, chocolate: 13789470, coral: 16744272, cornflowerblue: 6591981, cornsilk: 16775388, crimson: 14423100, cyan: 65535, darkblue: 139, darkcyan: 35723, darkgoldenrod: 12092939, darkgray: 11119017, darkgreen: 25600, darkgrey: 11119017, darkkhaki: 12433259, darkmagenta: 9109643, darkolivegreen: 5597999, darkorange: 16747520, darkorchid: 10040012, darkred: 9109504, darksalmon: 15308410, darkseagreen: 9419919, darkslateblue: 4734347, darkslategray: 3100495, darkslategrey: 3100495, darkturquoise: 52945, darkviolet: 9699539, deeppink: 16716947, deepskyblue: 49151, dimgray: 6908265, dimgrey: 6908265, dodgerblue: 2003199, firebrick: 11674146, floralwhite: 16775920, forestgreen: 2263842, fuchsia: 16711935, gainsboro: 14474460, ghostwhite: 16316671, gold: 16766720, goldenrod: 14329120, gray: 8421504, green: 32768, greenyellow: 11403055, grey: 8421504, honeydew: 15794160, hotpink: 16738740, indianred: 13458524, indigo: 4915330, ivory: 16777200, khaki: 15787660, lavender: 15132410, lavenderblush: 16773365, lawngreen: 8190976, lemonchiffon: 16775885, lightblue: 11393254, lightcoral: 15761536, lightcyan: 14745599, lightgoldenrodyellow: 16448210, lightgray: 13882323, lightgreen: 9498256, lightgrey: 13882323, lightpink: 16758465, lightsalmon: 16752762, lightseagreen: 2142890, lightskyblue: 8900346, lightslategray: 7833753, lightslategrey: 7833753, lightsteelblue: 11584734, lightyellow: 16777184, lime: 65280, limegreen: 3329330, linen: 16445670, magenta: 16711935, maroon: 8388608, mediumaquamarine: 6737322, mediumblue: 205, mediumorchid: 12211667, mediumpurple: 9662683, mediumseagreen: 3978097, mediumslateblue: 8087790, mediumspringgreen: 64154, mediumturquoise: 4772300, mediumvioletred: 13047173, midnightblue: 1644912, mintcream: 16121850, mistyrose: 16770273, moccasin: 16770229, navajowhite: 16768685, navy: 128, oldlace: 16643558, olive: 8421376, olivedrab: 7048739, orange: 16753920, orangered: 16729344, orchid: 14315734, palegoldenrod: 15657130, palegreen: 10025880, paleturquoise: 11529966, palevioletred: 14381203, papayawhip: 16773077, peachpuff: 16767673, peru: 13468991, pink: 16761035, plum: 14524637, powderblue: 11591910, purple: 8388736, rebeccapurple: 6697881, red: 16711680, rosybrown: 12357519, royalblue: 4286945, saddlebrown: 9127187, salmon: 16416882, sandybrown: 16032864, seagreen: 3050327, seashell: 16774638, sienna: 10506797, silver: 12632256, skyblue: 8900331, slateblue: 6970061, slategray: 7372944, slategrey: 7372944, snow: 16775930, springgreen: 65407, steelblue: 4620980, tan: 13808780, teal: 32896, thistle: 14204888, tomato: 16737095, turquoise: 4251856, violet: 15631086, wheat: 16113331, white: 16777215, whitesmoke: 16119285, yellow: 16776960, yellowgreen: 10145074 }; Object.assign(x.prototype, { isColor: !0, r: 1, g: 1, b: 1, set: function (t) { return t && t.isColor ? this.copy(t) : "number" == typeof t ? this.setHex(t) : "string" == typeof t && this.setStyle(t), this }, setScalar: function (t) { return this.b = this.g = this.r = t, this }, setHex: function (t) { return t = Math.floor(t), this.r = (t >> 16 & 255) / 255, this.g = (t >> 8 & 255) / 255, this.b = (255 & t) / 255, this }, setRGB: function (t, e, i) { return this.r = t, this.g = e, this.b = i, this }, setHSL: function () { function t(t, e, i) { return 0 > i && (i += 1), 1 < i && --i, i < 1 / 6 ? t + 6 * (e - t) * i : .5 > i ? e : i < 2 / 3 ? t + 6 * (e - t) * (2 / 3 - i) : t } return function (e, i, n) { return e = fo.euclideanModulo(e, 1), i = fo.clamp(i, 0, 1), n = fo.clamp(n, 0, 1), 0 === i ? this.r = this.g = this.b = n : (n = 2 * n - (i = .5 >= n ? n * (1 + i) : n + i - n * i), this.r = t(n, i, e + 1 / 3), this.g = t(n, i, e), this.b = t(n, i, e - 1 / 3)), this } }(), setStyle: function (t) { function e(e) { void 0 !== e && 1 > parseFloat(e) && console.warn("THREE.Color: Alpha component of " + t + " will be ignored.") } var i; if (i = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec(t)) { var n = i[2]; switch (i[1]) { case "rgb": case "rgba": if (i = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(255, parseInt(i[1], 10)) / 255, this.g = Math.min(255, parseInt(i[2], 10)) / 255, this.b = Math.min(255, parseInt(i[3], 10)) / 255, e(i[5]), this; if (i = /^(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) return this.r = Math.min(100, parseInt(i[1], 10)) / 100, this.g = Math.min(100, parseInt(i[2], 10)) / 100, this.b = Math.min(100, parseInt(i[3], 10)) / 100, e(i[5]), this; break; case "hsl": case "hsla": if (i = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec(n)) { n = parseFloat(i[1]) / 360; var r = parseInt(i[2], 10) / 100, o = parseInt(i[3], 10) / 100; return e(i[5]), this.setHSL(n, r, o) } } } else if (i = /^#([A-Fa-f0-9]+)$/.exec(t)) { if (3 === (n = (i = i[1]).length)) return this.r = parseInt(i.charAt(0) + i.charAt(0), 16) / 255, this.g = parseInt(i.charAt(1) + i.charAt(1), 16) / 255, this.b = parseInt(i.charAt(2) + i.charAt(2), 16) / 255, this; if (6 === n) return this.r = parseInt(i.charAt(0) + i.charAt(1), 16) / 255, this.g = parseInt(i.charAt(2) + i.charAt(3), 16) / 255, this.b = parseInt(i.charAt(4) + i.charAt(5), 16) / 255, this } return t && 0 < t.length && (void 0 !== (i = bo[t]) ? this.setHex(i) : console.warn("THREE.Color: Unknown color " + t)), this }, clone: function () { return new this.constructor(this.r, this.g, this.b) }, copy: function (t) { return this.r = t.r, this.g = t.g, this.b = t.b, this }, copyGammaToLinear: function (t, e) { return void 0 === e && (e = 2), this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, copyLinearToGamma: function (t, e) { return void 0 === e && (e = 2), e = 0 < e ? 1 / e : 1, this.r = Math.pow(t.r, e), this.g = Math.pow(t.g, e), this.b = Math.pow(t.b, e), this }, convertGammaToLinear: function (t) { return this.copyGammaToLinear(this, t), this }, convertLinearToGamma: function (t) { return this.copyLinearToGamma(this, t), this }, copySRGBToLinear: function () { function t(t) { return .04045 > t ? .0773993808 * t : Math.pow(.9478672986 * t + .0521327014, 2.4) } return function (e) { return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this } }(), copyLinearToSRGB: function () { function t(t) { return .0031308 > t ? 12.92 * t : 1.055 * Math.pow(t, .41666) - .055 } return function (e) { return this.r = t(e.r), this.g = t(e.g), this.b = t(e.b), this } }(), convertSRGBToLinear: function () { return this.copySRGBToLinear(this), this }, convertLinearToSRGB: function () { return this.copyLinearToSRGB(this), this }, getHex: function () { return 255 * this.r << 16 ^ 255 * this.g << 8 ^ 255 * this.b << 0 }, getHexString: function () { return ("000000" + this.getHex().toString(16)).slice(-6) }, getHSL: function (t) { void 0 === t && (console.warn("THREE.Color: .getHSL() target is now required"), t = { h: 0, s: 0, l: 0 }); var e, i = this.r, n = this.g, r = this.b, o = Math.max(i, n, r), a = Math.min(i, n, r), s = (a + o) / 2; if (a === o) a = e = 0; else { var c = o - a; switch (a = .5 >= s ? c / (o + a) : c / (2 - o - a), o) { case i: e = (n - r) / c + (n < r ? 6 : 0); break; case n: e = (r - i) / c + 2; break; case r: e = (i - n) / c + 4 }e /= 6 } return t.h = e, t.s = a, t.l = s, t }, getStyle: function () { return "rgb(" + (255 * this.r | 0) + "," + (255 * this.g | 0) + "," + (255 * this.b | 0) + ")" }, offsetHSL: function () { var t = {}; return function (e, i, n) { return this.getHSL(t), t.h += e, t.s += i, t.l += n, this.setHSL(t.h, t.s, t.l), this } }(), add: function (t) { return this.r += t.r, this.g += t.g, this.b += t.b, this }, addColors: function (t, e) { return this.r = t.r + e.r, this.g = t.g + e.g, this.b = t.b + e.b, this }, addScalar: function (t) { return this.r += t, this.g += t, this.b += t, this }, sub: function (t) { return this.r = Math.max(0, this.r - t.r), this.g = Math.max(0, this.g - t.g), this.b = Math.max(0, this.b - t.b), this }, multiply: function (t) { return this.r *= t.r, this.g *= t.g, this.b *= t.b, this }, multiplyScalar: function (t) { return this.r *= t, this.g *= t, this.b *= t, this }, lerp: function (t, e) { return this.r += (t.r - this.r) * e, this.g += (t.g - this.g) * e, this.b += (t.b - this.b) * e, this }, lerpHSL: function () { var t = { h: 0, s: 0, l: 0 }, e = { h: 0, s: 0, l: 0 }; return function (i, n) { this.getHSL(t), i.getHSL(e), i = fo.lerp(t.h, e.h, n); var r = fo.lerp(t.s, e.s, n); return n = fo.lerp(t.l, e.l, n), this.setHSL(i, r, n), this } }(), equals: function (t) { return t.r === this.r && t.g === this.g && t.b === this.b }, fromArray: function (t, e) { return void 0 === e && (e = 0), this.r = t[e], this.g = t[e + 1], this.b = t[e + 2], this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this.r, t[e + 1] = this.g, t[e + 2] = this.b, t }, toJSON: function () { return this.getHex() } }); var wo = { common: { diffuse: { value: new x(15658734) }, opacity: { value: 1 }, map: { value: null }, uvTransform: { value: new o }, alphaMap: { value: null } }, specularmap: { specularMap: { value: null } }, envmap: { envMap: { value: null }, flipEnvMap: { value: -1 }, reflectivity: { value: 1 }, refractionRatio: { value: .98 }, maxMipLevel: { value: 0 } }, aomap: { aoMap: { value: null }, aoMapIntensity: { value: 1 } }, lightmap: { lightMap: { value: null }, lightMapIntensity: { value: 1 } }, emissivemap: { emissiveMap: { value: null } }, bumpmap: { bumpMap: { value: null }, bumpScale: { value: 1 } }, normalmap: { normalMap: { value: null }, normalScale: { value: new i(1, 1) } }, displacementmap: { displacementMap: { value: null }, displacementScale: { value: 1 }, displacementBias: { value: 0 } }, roughnessmap: { roughnessMap: { value: null } }, metalnessmap: { metalnessMap: { value: null } }, gradientmap: { gradientMap: { value: null } }, fog: { fogDensity: { value: 25e-5 }, fogNear: { value: 1 }, fogFar: { value: 2e3 }, fogColor: { value: new x(16777215) } }, lights: { ambientLightColor: { value: [] }, lightProbe: { value: [] }, directionalLights: { value: [], properties: { direction: {}, color: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, directionalShadowMap: { value: [] }, directionalShadowMatrix: { value: [] }, spotLights: { value: [], properties: { color: {}, position: {}, direction: {}, distance: {}, coneCos: {}, penumbraCos: {}, decay: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {} } }, spotShadowMap: { value: [] }, spotShadowMatrix: { value: [] }, pointLights: { value: [], properties: { color: {}, position: {}, decay: {}, distance: {}, shadow: {}, shadowBias: {}, shadowRadius: {}, shadowMapSize: {}, shadowCameraNear: {}, shadowCameraFar: {} } }, pointShadowMap: { value: [] }, pointShadowMatrix: { value: [] }, hemisphereLights: { value: [], properties: { direction: {}, skyColor: {}, groundColor: {} } }, rectAreaLights: { value: [], properties: { color: {}, position: {}, width: {}, height: {} } } }, points: { diffuse: { value: new x(15658734) }, opacity: { value: 1 }, size: { value: 1 }, scale: { value: 1 }, map: { value: null }, uvTransform: { value: new o } }, sprite: { diffuse: { value: new x(15658734) }, opacity: { value: 1 }, center: { value: new i(.5, .5) }, rotation: { value: 0 }, map: { value: null }, uvTransform: { value: new o } } }, Mo = { basic: { uniforms: y([wo.common, wo.specularmap, wo.envmap, wo.aomap, wo.lightmap, wo.fog]), vertexShader: yo.meshbasic_vert, fragmentShader: yo.meshbasic_frag }, lambert: { uniforms: y([wo.common, wo.specularmap, wo.envmap, wo.aomap, wo.lightmap, wo.emissivemap, wo.fog, wo.lights, { emissive: { value: new x(0) } }]), vertexShader: yo.meshlambert_vert, fragmentShader: yo.meshlambert_frag }, phong: { uniforms: y([wo.common, wo.specularmap, wo.envmap, wo.aomap, wo.lightmap, wo.emissivemap, wo.bumpmap, wo.normalmap, wo.displacementmap, wo.gradientmap, wo.fog, wo.lights, { emissive: { value: new x(0) }, specular: { value: new x(1118481) }, shininess: { value: 30 } }]), vertexShader: yo.meshphong_vert, fragmentShader: yo.meshphong_frag }, standard: { uniforms: y([wo.common, wo.envmap, wo.aomap, wo.lightmap, wo.emissivemap, wo.bumpmap, wo.normalmap, wo.displacementmap, wo.roughnessmap, wo.metalnessmap, wo.fog, wo.lights, { emissive: { value: new x(0) }, roughness: { value: .5 }, metalness: { value: .5 }, envMapIntensity: { value: 1 } }]), vertexShader: yo.meshphysical_vert, fragmentShader: yo.meshphysical_frag }, matcap: { uniforms: y([wo.common, wo.bumpmap, wo.normalmap, wo.displacementmap, wo.fog, { matcap: { value: null } }]), vertexShader: yo.meshmatcap_vert, fragmentShader: yo.meshmatcap_frag }, points: { uniforms: y([wo.points, wo.fog]), vertexShader: yo.points_vert, fragmentShader: yo.points_frag }, dashed: { uniforms: y([wo.common, wo.fog, { scale: { value: 1 }, dashSize: { value: 1 }, totalSize: { value: 2 } }]), vertexShader: yo.linedashed_vert, fragmentShader: yo.linedashed_frag }, depth: { uniforms: y([wo.common, wo.displacementmap]), vertexShader: yo.depth_vert, fragmentShader: yo.depth_frag }, normal: { uniforms: y([wo.common, wo.bumpmap, wo.normalmap, wo.displacementmap, { opacity: { value: 1 } }]), vertexShader: yo.normal_vert, fragmentShader: yo.normal_frag }, sprite: { uniforms: y([wo.sprite, wo.fog]), vertexShader: yo.sprite_vert, fragmentShader: yo.sprite_frag }, background: { uniforms: { uvTransform: { value: new o }, t2D: { value: null } }, vertexShader: yo.background_vert, fragmentShader: yo.background_frag }, cube: { uniforms: { tCube: { value: null }, tFlip: { value: -1 }, opacity: { value: 1 } }, vertexShader: yo.cube_vert, fragmentShader: yo.cube_frag }, equirect: { uniforms: { tEquirect: { value: null } }, vertexShader: yo.equirect_vert, fragmentShader: yo.equirect_frag }, distanceRGBA: { uniforms: y([wo.common, wo.displacementmap, { referencePosition: { value: new r }, nearDistance: { value: 1 }, farDistance: { value: 1e3 } }]), vertexShader: yo.distanceRGBA_vert, fragmentShader: yo.distanceRGBA_frag }, shadow: { uniforms: y([wo.lights, wo.fog, { color: { value: new x(0) }, opacity: { value: 1 } }]), vertexShader: yo.shadow_vert, fragmentShader: yo.shadow_frag } }; Mo.physical = { uniforms: y([Mo.standard.uniforms, { clearCoat: { value: 0 }, clearCoatRoughness: { value: 0 } }]), vertexShader: yo.meshphysical_vert, fragmentShader: yo.meshphysical_frag }, Object.assign(M.prototype, { clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.a = t.a, this.b = t.b, this.c = t.c, this.normal.copy(t.normal), this.color.copy(t.color), this.materialIndex = t.materialIndex; for (var e = 0, i = t.vertexNormals.length; e < i; e++)this.vertexNormals[e] = t.vertexNormals[e].clone(); for (e = 0, i = t.vertexColors.length; e < i; e++)this.vertexColors[e] = t.vertexColors[e].clone(); return this } }), _.RotationOrders = "XYZ YZX ZXY XZY YXZ ZYX".split(" "), _.DefaultOrder = "XYZ", Object.defineProperties(_.prototype, { x: { get: function () { return this._x }, set: function (t) { this._x = t, this.onChangeCallback() } }, y: { get: function () { return this._y }, set: function (t) { this._y = t, this.onChangeCallback() } }, z: { get: function () { return this._z }, set: function (t) { this._z = t, this.onChangeCallback() } }, order: { get: function () { return this._order }, set: function (t) { this._order = t, this.onChangeCallback() } } }), Object.assign(_.prototype, { isEuler: !0, set: function (t, e, i, n) { return this._x = t, this._y = e, this._z = i, this._order = n || this._order, this.onChangeCallback(), this }, clone: function () { return new this.constructor(this._x, this._y, this._z, this._order) }, copy: function (t) { return this._x = t._x, this._y = t._y, this._z = t._z, this._order = t._order, this.onChangeCallback(), this }, setFromRotationMatrix: function (t, e, i) { var n = fo.clamp, r = t.elements; t = r[0]; var o = r[4], a = r[8], s = r[1], c = r[5], h = r[9], l = r[2], u = r[6]; return r = r[10], "XYZ" === (e = e || this._order) ? (this._y = Math.asin(n(a, -1, 1)), .99999 > Math.abs(a) ? (this._x = Math.atan2(-h, r), this._z = Math.atan2(-o, t)) : (this._x = Math.atan2(u, c), this._z = 0)) : "YXZ" === e ? (this._x = Math.asin(-n(h, -1, 1)), .99999 > Math.abs(h) ? (this._y = Math.atan2(a, r), this._z = Math.atan2(s, c)) : (this._y = Math.atan2(-l, t), this._z = 0)) : "ZXY" === e ? (this._x = Math.asin(n(u, -1, 1)), .99999 > Math.abs(u) ? (this._y = Math.atan2(-l, r), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(s, t))) : "ZYX" === e ? (this._y = Math.asin(-n(l, -1, 1)), .99999 > Math.abs(l) ? (this._x = Math.atan2(u, r), this._z = Math.atan2(s, t)) : (this._x = 0, this._z = Math.atan2(-o, c))) : "YZX" === e ? (this._z = Math.asin(n(s, -1, 1)), .99999 > Math.abs(s) ? (this._x = Math.atan2(-h, c), this._y = Math.atan2(-l, t)) : (this._x = 0, this._y = Math.atan2(a, r))) : "XZY" === e ? (this._z = Math.asin(-n(o, -1, 1)), .99999 > Math.abs(o) ? (this._x = Math.atan2(u, c), this._y = Math.atan2(a, t)) : (this._x = Math.atan2(-h, r), this._y = 0)) : console.warn("THREE.Euler: .setFromRotationMatrix() given unsupported order: " + e), this._order = e, !1 !== i && this.onChangeCallback(), this }, setFromQuaternion: function () { var t = new g; return function (e, i, n) { return t.makeRotationFromQuaternion(e), this.setFromRotationMatrix(t, i, n) } }(), setFromVector3: function (t, e) { return this.set(t.x, t.y, t.z, e || this._order) }, reorder: function () { var t = new n; return function (e) { return t.setFromEuler(this), this.setFromQuaternion(t, e) } }(), equals: function (t) { return t._x === this._x && t._y === this._y && t._z === this._z && t._order === this._order }, fromArray: function (t) { return this._x = t[0], this._y = t[1], this._z = t[2], void 0 !== t[3] && (this._order = t[3]), this.onChangeCallback(), this }, toArray: function (t, e) { return void 0 === t && (t = []), void 0 === e && (e = 0), t[e] = this._x, t[e + 1] = this._y, t[e + 2] = this._z, t[e + 3] = this._order, t }, toVector3: function (t) { return t ? t.set(this._x, this._y, this._z) : new r(this._x, this._y, this._z) }, onChange: function (t) { return this.onChangeCallback = t, this }, onChangeCallback: function () { } }), Object.assign(E.prototype, { set: function (t) { this.mask = 1 << t | 0 }, enable: function (t) { this.mask = this.mask | 1 << t | 0 }, toggle: function (t) { this.mask ^= 1 << t | 0 }, disable: function (t) { this.mask &= ~(1 << t | 0) }, test: function (t) { return 0 != (this.mask & t.mask) } }); var _o = 0; A.DefaultUp = new r(0, 1, 0), A.DefaultMatrixAutoUpdate = !0, A.prototype = Object.assign(Object.create(e.prototype), { constructor: A, isObject3D: !0, onBeforeRender: function () { }, onAfterRender: function () { }, applyMatrix: function (t) { this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(t), this.matrix.decompose(this.position, this.quaternion, this.scale) }, applyQuaternion: function (t) { return this.quaternion.premultiply(t), this }, setRotationFromAxisAngle: function (t, e) { this.quaternion.setFromAxisAngle(t, e) }, setRotationFromEuler: function (t) { this.quaternion.setFromEuler(t, !0) }, setRotationFromMatrix: function (t) { this.quaternion.setFromRotationMatrix(t) }, setRotationFromQuaternion: function (t) { this.quaternion.copy(t) }, rotateOnAxis: function () { var t = new n; return function (e, i) { return t.setFromAxisAngle(e, i), this.quaternion.multiply(t), this } }(), rotateOnWorldAxis: function () { var t = new n; return function (e, i) { return t.setFromAxisAngle(e, i), this.quaternion.premultiply(t), this } }(), rotateX: function () { var t = new r(1, 0, 0); return function (e) { return this.rotateOnAxis(t, e) } }(), rotateY: function () { var t = new r(0, 1, 0); return function (e) { return this.rotateOnAxis(t, e) } }(), rotateZ: function () { var t = new r(0, 0, 1); return function (e) { return this.rotateOnAxis(t, e) } }(), translateOnAxis: function () { var t = new r; return function (e, i) { return t.copy(e).applyQuaternion(this.quaternion), this.position.add(t.multiplyScalar(i)), this } }(), translateX: function () { var t = new r(1, 0, 0); return function (e) { return this.translateOnAxis(t, e) } }(), translateY: function () { var t = new r(0, 1, 0); return function (e) { return this.translateOnAxis(t, e) } }(), translateZ: function () { var t = new r(0, 0, 1); return function (e) { return this.translateOnAxis(t, e) } }(), localToWorld: function (t) { return t.applyMatrix4(this.matrixWorld) }, worldToLocal: function () { var t = new g; return function (e) { return e.applyMatrix4(t.getInverse(this.matrixWorld)) } }(), lookAt: function () { var t = new n, e = new g, i = new r, o = new r; return function (n, r, a) { n.isVector3 ? i.copy(n) : i.set(n, r, a), n = this.parent, this.updateWorldMatrix(!0, !1), o.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? e.lookAt(o, i, this.up) : e.lookAt(i, o, this.up), this.quaternion.setFromRotationMatrix(e), n && (e.extractRotation(n.matrixWorld), t.setFromRotationMatrix(e), this.quaternion.premultiply(t.inverse())) } }(), add: function (t) { if (1 < arguments.length) { for (var e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } return t === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", t), this) : (t && t.isObject3D ? (null !== t.parent && t.parent.remove(t), t.parent = this, t.dispatchEvent({ type: "added" }), this.children.push(t)) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", t), this) }, remove: function (t) { if (1 < arguments.length) { for (var e = 0; e < arguments.length; e++)this.remove(arguments[e]); return this } return -1 !== (e = this.children.indexOf(t)) && (t.parent = null, t.dispatchEvent({ type: "removed" }), this.children.splice(e, 1)), this }, attach: function () { var t = new g; return function (e) { return this.updateWorldMatrix(!0, !1), t.getInverse(this.matrixWorld), null !== e.parent && (e.parent.updateWorldMatrix(!0, !1), t.multiply(e.parent.matrixWorld)), e.applyMatrix(t), e.updateWorldMatrix(!1, !1), this.add(e), this } }(), getObjectById: function (t) { return this.getObjectByProperty("id", t) }, getObjectByName: function (t) { return this.getObjectByProperty("name", t) }, getObjectByProperty: function (t, e) { if (this[t] === e) return this; for (var i = 0, n = this.children.length; i < n; i++) { var r = this.children[i].getObjectByProperty(t, e); if (void 0 !== r) return r } }, getWorldPosition: function (t) { return void 0 === t && (console.warn("THREE.Object3D: .getWorldPosition() target is now required"), t = new r), this.updateMatrixWorld(!0), t.setFromMatrixPosition(this.matrixWorld) }, getWorldQuaternion: function () { var t = new r, e = new r; return function (i) { return void 0 === i && (console.warn("THREE.Object3D: .getWorldQuaternion() target is now required"), i = new n), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, i, e), i } }(), getWorldScale: function () { var t = new r, e = new n; return function (i) { return void 0 === i && (console.warn("THREE.Object3D: .getWorldScale() target is now required"), i = new r), this.updateMatrixWorld(!0), this.matrixWorld.decompose(t, e, i), i } }(), getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Object3D: .getWorldDirection() target is now required"), t = new r), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(e[8], e[9], e[10]).normalize() }, raycast: function () { }, traverse: function (t) { t(this); for (var e = this.children, i = 0, n = e.length; i < n; i++)e[i].traverse(t) }, traverseVisible: function (t) { if (!1 !== this.visible) { t(this); for (var e = this.children, i = 0, n = e.length; i < n; i++)e[i].traverseVisible(t) } }, traverseAncestors: function (t) { var e = this.parent; null !== e && (t(e), e.traverseAncestors(t)) }, updateMatrix: function () { this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0 }, updateMatrixWorld: function (t) { this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || t) && (null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), this.matrixWorldNeedsUpdate = !1, t = !0); for (var e = this.children, i = 0, n = e.length; i < n; i++)e[i].updateMatrixWorld(t) }, updateWorldMatrix: function (t, e) { var i = this.parent; if (!0 === t && null !== i && i.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), null === this.parent ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix), !0 === e) for (e = 0, i = (t = this.children).length; e < i; e++)t[e].updateWorldMatrix(!1, !0) }, toJSON: function (t) { function e(e, i) { return void 0 === e[i.uuid] && (e[i.uuid] = i.toJSON(t)), i.uuid } function i(t) { var e, i = []; for (e in t) { var n = t[e]; delete n.metadata, i.push(n) } return i } var n = void 0 === t || "string" == typeof t, r = {}; n && (t = { geometries: {}, materials: {}, textures: {}, images: {}, shapes: {} }, r.metadata = { version: 4.5, type: "Object", generator: "Object3D.toJSON" }); var o = {}; if (o.uuid = this.uuid, o.type = this.type, "" !== this.name && (o.name = this.name), !0 === this.castShadow && (o.castShadow = !0), !0 === this.receiveShadow && (o.receiveShadow = !0), !1 === this.visible && (o.visible = !1), !1 === this.frustumCulled && (o.frustumCulled = !1), 0 !== this.renderOrder && (o.renderOrder = this.renderOrder), "{}" !== JSON.stringify(this.userData) && (o.userData = this.userData), o.layers = this.layers.mask, o.matrix = this.matrix.toArray(), !1 === this.matrixAutoUpdate && (o.matrixAutoUpdate = !1), this.isMesh && 0 !== this.drawMode && (o.drawMode = this.drawMode), this.isMesh || this.isLine || this.isPoints) { o.geometry = e(t.geometries, this.geometry); var a = this.geometry.parameters; if (void 0 !== a && void 0 !== a.shapes) if (a = a.shapes, Array.isArray(a)) for (var s = 0, c = a.length; s < c; s++)e(t.shapes, a[s]); else e(t.shapes, a) } if (void 0 !== this.material) if (Array.isArray(this.material)) { for (a = [], s = 0, c = this.material.length; s < c; s++)a.push(e(t.materials, this.material[s])); o.material = a } else o.material = e(t.materials, this.material); if (0 < this.children.length) for (o.children = [], s = 0; s < this.children.length; s++)o.children.push(this.children[s].toJSON(t).object); if (n) { n = i(t.geometries), s = i(t.materials), c = i(t.textures); var h = i(t.images); a = i(t.shapes), 0 < n.length && (r.geometries = n), 0 < s.length && (r.materials = s), 0 < c.length && (r.textures = c), 0 < h.length && (r.images = h), 0 < a.length && (r.shapes = a) } return r.object = o, r }, clone: function (t) { return (new this.constructor).copy(this, t) }, copy: function (t, e) { if (void 0 === e && (e = !0), this.name = t.name, this.up.copy(t.up), this.position.copy(t.position), this.quaternion.copy(t.quaternion), this.scale.copy(t.scale), this.matrix.copy(t.matrix), this.matrixWorld.copy(t.matrixWorld), this.matrixAutoUpdate = t.matrixAutoUpdate, this.matrixWorldNeedsUpdate = t.matrixWorldNeedsUpdate, this.layers.mask = t.layers.mask, this.visible = t.visible, this.castShadow = t.castShadow, this.receiveShadow = t.receiveShadow, this.frustumCulled = t.frustumCulled, this.renderOrder = t.renderOrder, this.userData = JSON.parse(JSON.stringify(t.userData)), !0 === e) for (e = 0; e < t.children.length; e++)this.add(t.children[e].clone()); return this } }); var Eo = 0; T.prototype = Object.assign(Object.create(e.prototype), { constructor: T, isGeometry: !0, applyMatrix: function (t) { for (var e = (new o).getNormalMatrix(t), i = 0, n = this.vertices.length; i < n; i++)this.vertices[i].applyMatrix4(t); for (i = 0, n = this.faces.length; i < n; i++) { (t = this.faces[i]).normal.applyMatrix3(e).normalize(); for (var r = 0, a = t.vertexNormals.length; r < a; r++)t.vertexNormals[r].applyMatrix3(e).normalize() } return null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this.normalsNeedUpdate = this.verticesNeedUpdate = !0, this }, rotateX: function () { var t = new g; return function (e) { return t.makeRotationX(e), this.applyMatrix(t), this } }(), rotateY: function () { var t = new g; return function (e) { return t.makeRotationY(e), this.applyMatrix(t), this } }(), rotateZ: function () { var t = new g; return function (e) { return t.makeRotationZ(e), this.applyMatrix(t), this } }(), translate: function () { var t = new g; return function (e, i, n) { return t.makeTranslation(e, i, n), this.applyMatrix(t), this } }(), scale: function () { var t = new g; return function (e, i, n) { return t.makeScale(e, i, n), this.applyMatrix(t), this } }(), lookAt: function () { var t = new A; return function (e) { t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix) } }(), fromBufferGeometry: function (t) { function e(t, e, o, a) { var s = void 0 === h ? [] : [n.colors[t].clone(), n.colors[e].clone(), n.colors[o].clone()]; a = new M(t, e, o, void 0 === c ? [] : [(new r).fromArray(c, 3 * t), (new r).fromArray(c, 3 * e), (new r).fromArray(c, 3 * o)], s, a), n.faces.push(a), void 0 !== l && n.faceVertexUvs[0].push([(new i).fromArray(l, 2 * t), (new i).fromArray(l, 2 * e), (new i).fromArray(l, 2 * o)]), void 0 !== u && n.faceVertexUvs[1].push([(new i).fromArray(u, 2 * t), (new i).fromArray(u, 2 * e), (new i).fromArray(u, 2 * o)]) } var n = this, o = null !== t.index ? t.index.array : void 0, a = t.attributes, s = a.position.array, c = void 0 !== a.normal ? a.normal.array : void 0, h = void 0 !== a.color ? a.color.array : void 0, l = void 0 !== a.uv ? a.uv.array : void 0, u = void 0 !== a.uv2 ? a.uv2.array : void 0; for (void 0 !== u && (this.faceVertexUvs[1] = []), a = 0; a < s.length; a += 3)n.vertices.push((new r).fromArray(s, a)), void 0 !== h && n.colors.push((new x).fromArray(h, a)); var d = t.groups; if (0 < d.length) for (a = 0; a < d.length; a++) { var p = (s = d[a]).start, f = p; for (p += s.count; f < p; f += 3)void 0 !== o ? e(o[f], o[f + 1], o[f + 2], s.materialIndex) : e(f, f + 1, f + 2, s.materialIndex) } else if (void 0 !== o) for (a = 0; a < o.length; a += 3)e(o[a], o[a + 1], o[a + 2]); else for (a = 0; a < s.length / 3; a += 3)e(a, a + 1, a + 2); return this.computeFaceNormals(), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), this }, center: function () { var t = new r; return function () { return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this } }(), normalize: function () { this.computeBoundingSphere(); var t = this.boundingSphere.center, e = this.boundingSphere.radius; e = 0 === e ? 1 : 1 / e; var i = new g; return i.set(e, 0, 0, -e * t.x, 0, e, 0, -e * t.y, 0, 0, e, -e * t.z, 0, 0, 0, 1), this.applyMatrix(i), this }, computeFaceNormals: function () { for (var t = new r, e = new r, i = 0, n = this.faces.length; i < n; i++) { var o = this.faces[i], a = this.vertices[o.a], s = this.vertices[o.b]; t.subVectors(this.vertices[o.c], s), e.subVectors(a, s), t.cross(e), t.normalize(), o.normal.copy(t) } }, computeVertexNormals: function (t) { var e; void 0 === t && (t = !0); var i = Array(this.vertices.length), n = 0; for (e = this.vertices.length; n < e; n++)i[n] = new r; if (t) { var o = new r, a = new r; for (t = 0, n = this.faces.length; t < n; t++) { e = this.faces[t]; var s = this.vertices[e.a], c = this.vertices[e.b], h = this.vertices[e.c]; o.subVectors(h, c), a.subVectors(s, c), o.cross(a), i[e.a].add(o), i[e.b].add(o), i[e.c].add(o) } } else for (this.computeFaceNormals(), t = 0, n = this.faces.length; t < n; t++)i[(e = this.faces[t]).a].add(e.normal), i[e.b].add(e.normal), i[e.c].add(e.normal); for (n = 0, e = this.vertices.length; n < e; n++)i[n].normalize(); for (t = 0, n = this.faces.length; t < n; t++)3 === (s = (e = this.faces[t]).vertexNormals).length ? (s[0].copy(i[e.a]), s[1].copy(i[e.b]), s[2].copy(i[e.c])) : (s[0] = i[e.a].clone(), s[1] = i[e.b].clone(), s[2] = i[e.c].clone()); 0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeFlatVertexNormals: function () { var t; this.computeFaceNormals(); var e = 0; for (t = this.faces.length; e < t; e++) { var i = this.faces[e], n = i.vertexNormals; 3 === n.length ? (n[0].copy(i.normal), n[1].copy(i.normal), n[2].copy(i.normal)) : (n[0] = i.normal.clone(), n[1] = i.normal.clone(), n[2] = i.normal.clone()) } 0 < this.faces.length && (this.normalsNeedUpdate = !0) }, computeMorphNormals: function () { var t, e, i = 0; for (e = this.faces.length; i < e; i++) { var n = this.faces[i]; n.__originalFaceNormal ? n.__originalFaceNormal.copy(n.normal) : n.__originalFaceNormal = n.normal.clone(), n.__originalVertexNormals || (n.__originalVertexNormals = []); var o = 0; for (t = n.vertexNormals.length; o < t; o++)n.__originalVertexNormals[o] ? n.__originalVertexNormals[o].copy(n.vertexNormals[o]) : n.__originalVertexNormals[o] = n.vertexNormals[o].clone() } var a = new T; for (a.faces = this.faces, o = 0, t = this.morphTargets.length; o < t; o++) { if (!this.morphNormals[o]) { this.morphNormals[o] = {}, this.morphNormals[o].faceNormals = [], this.morphNormals[o].vertexNormals = [], n = this.morphNormals[o].faceNormals; var s = this.morphNormals[o].vertexNormals; for (i = 0, e = this.faces.length; i < e; i++) { var c = new r, h = { a: new r, b: new r, c: new r }; n.push(c), s.push(h) } } for (s = this.morphNormals[o], a.vertices = this.morphTargets[o].vertices, a.computeFaceNormals(), a.computeVertexNormals(), i = 0, e = this.faces.length; i < e; i++)n = this.faces[i], c = s.faceNormals[i], h = s.vertexNormals[i], c.copy(n.normal), h.a.copy(n.vertexNormals[0]), h.b.copy(n.vertexNormals[1]), h.c.copy(n.vertexNormals[2]) } for (i = 0, e = this.faces.length; i < e; i++)(n = this.faces[i]).normal = n.__originalFaceNormal, n.vertexNormals = n.__originalVertexNormals }, computeBoundingBox: function () { null === this.boundingBox && (this.boundingBox = new d), this.boundingBox.setFromPoints(this.vertices) }, computeBoundingSphere: function () { null === this.boundingSphere && (this.boundingSphere = new p), this.boundingSphere.setFromPoints(this.vertices) }, merge: function (t, e, i) { if (t && t.isGeometry) { var n, r = this.vertices.length, a = this.vertices, s = t.vertices, c = this.faces, h = t.faces, l = this.faceVertexUvs[0], u = t.faceVertexUvs[0], d = this.colors, p = t.colors; void 0 === i && (i = 0), void 0 !== e && (n = (new o).getNormalMatrix(e)), t = 0; for (var f = s.length; t < f; t++) { var m = s[t].clone(); void 0 !== e && m.applyMatrix4(e), a.push(m) } for (t = 0, f = p.length; t < f; t++)d.push(p[t].clone()); for (t = 0, f = h.length; t < f; t++) { var g = (s = h[t]).vertexNormals; for (p = s.vertexColors, (d = new M(s.a + r, s.b + r, s.c + r)).normal.copy(s.normal), void 0 !== n && d.normal.applyMatrix3(n).normalize(), e = 0, a = g.length; e < a; e++)m = g[e].clone(), void 0 !== n && m.applyMatrix3(n).normalize(), d.vertexNormals.push(m); for (d.color.copy(s.color), e = 0, a = p.length; e < a; e++)m = p[e], d.vertexColors.push(m.clone()); d.materialIndex = s.materialIndex + i, c.push(d) } for (t = 0, f = u.length; t < f; t++)if (n = [], void 0 !== (i = u[t])) { for (e = 0, a = i.length; e < a; e++)n.push(i[e].clone()); l.push(n) } } else console.error("THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.", t) }, mergeMesh: function (t) { t && t.isMesh ? (t.matrixAutoUpdate && t.updateMatrix(), this.merge(t.geometry, t.matrix)) : console.error("THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.", t) }, mergeVertices: function () { var t, e = {}, i = [], n = [], r = Math.pow(10, 4), o = 0; for (t = this.vertices.length; o < t; o++) { var a = this.vertices[o]; void 0 === e[a = Math.round(a.x * r) + "_" + Math.round(a.y * r) + "_" + Math.round(a.z * r)] ? (e[a] = o, i.push(this.vertices[o]), n[o] = i.length - 1) : n[o] = n[e[a]] } for (e = [], o = 0, t = this.faces.length; o < t; o++)for ((r = this.faces[o]).a = n[r.a], r.b = n[r.b], r.c = n[r.c], r = [r.a, r.b, r.c], a = 0; 3 > a; a++)if (r[a] === r[(a + 1) % 3]) { e.push(o); break } for (o = e.length - 1; 0 <= o; o--)for (r = e[o], this.faces.splice(r, 1), n = 0, t = this.faceVertexUvs.length; n < t; n++)this.faceVertexUvs[n].splice(r, 1); return o = this.vertices.length - i.length, this.vertices = i, o }, setFromPoints: function (t) { this.vertices = []; for (var e = 0, i = t.length; e < i; e++) { var n = t[e]; this.vertices.push(new r(n.x, n.y, n.z || 0)) } return this }, sortFacesByMaterialIndex: function () { for (var t = this.faces, e = t.length, i = 0; i < e; i++)t[i]._id = i; t.sort((function (t, e) { return t.materialIndex - e.materialIndex })); var n, r, o = this.faceVertexUvs[0], a = this.faceVertexUvs[1]; for (o && o.length === e && (n = []), a && a.length === e && (r = []), i = 0; i < e; i++) { var s = t[i]._id; n && n.push(o[s]), r && r.push(a[s]) } n && (this.faceVertexUvs[0] = n), r && (this.faceVertexUvs[1] = r) }, toJSON: function () { function t(t, e, i) { return i ? t | 1 << e : t & ~(1 << e) } function e(t) { var e = t.x.toString() + t.y.toString() + t.z.toString(); return void 0 !== h[e] || (h[e] = c.length / 3, c.push(t.x, t.y, t.z)), h[e] } function i(t) { var e = t.r.toString() + t.g.toString() + t.b.toString(); return void 0 !== u[e] || (u[e] = l.length, l.push(t.getHex())), u[e] } function n(t) { var e = t.x.toString() + t.y.toString(); return void 0 !== p[e] || (p[e] = d.length / 2, d.push(t.x, t.y)), p[e] } var r = { metadata: { version: 4.5, type: "Geometry", generator: "Geometry.toJSON" } }; if (r.uuid = this.uuid, r.type = this.type, "" !== this.name && (r.name = this.name), void 0 !== this.parameters) { var o, a = this.parameters; for (o in a) void 0 !== a[o] && (r[o] = a[o]); return r } for (a = [], o = 0; o < this.vertices.length; o++) { var s = this.vertices[o]; a.push(s.x, s.y, s.z) } s = []; var c = [], h = {}, l = [], u = {}, d = [], p = {}; for (o = 0; o < this.faces.length; o++) { var f = this.faces[o], m = void 0 !== this.faceVertexUvs[0][o], g = 0 < f.normal.length(), v = 0 < f.vertexNormals.length, y = 1 !== f.color.r || 1 !== f.color.g || 1 !== f.color.b, x = 0 < f.vertexColors.length, b = 0; b = t(b, 0, 0), b = t(b, 1, !0), b = t(b, 2, !1), b = t(b, 3, m), b = t(b, 4, g), b = t(b, 5, v), b = t(b, 6, y), b = t(b, 7, x), s.push(b), s.push(f.a, f.b, f.c), s.push(f.materialIndex), m && (m = this.faceVertexUvs[0][o], s.push(n(m[0]), n(m[1]), n(m[2]))), g && s.push(e(f.normal)), v && (g = f.vertexNormals, s.push(e(g[0]), e(g[1]), e(g[2]))), y && s.push(i(f.color)), x && (f = f.vertexColors, s.push(i(f[0]), i(f[1]), i(f[2]))) } return r.data = {}, r.data.vertices = a, r.data.normals = c, 0 < l.length && (r.data.colors = l), 0 < d.length && (r.data.uvs = [d]), r.data.faces = s, r }, clone: function () { return (new T).copy(this) }, copy: function (t) { var e, i, n; this.vertices = [], this.colors = [], this.faces = [], this.faceVertexUvs = [[]], this.morphTargets = [], this.morphNormals = [], this.skinWeights = [], this.skinIndices = [], this.lineDistances = [], this.boundingSphere = this.boundingBox = null, this.name = t.name; var r = t.vertices, o = 0; for (e = r.length; o < e; o++)this.vertices.push(r[o].clone()); for (o = 0, e = (r = t.colors).length; o < e; o++)this.colors.push(r[o].clone()); for (o = 0, e = (r = t.faces).length; o < e; o++)this.faces.push(r[o].clone()); for (o = 0, e = t.faceVertexUvs.length; o < e; o++) { var a = t.faceVertexUvs[o]; for (void 0 === this.faceVertexUvs[o] && (this.faceVertexUvs[o] = []), r = 0, i = a.length; r < i; r++) { var s = a[r], c = [], h = 0; for (n = s.length; h < n; h++)c.push(s[h].clone()); this.faceVertexUvs[o].push(c) } } for (o = 0, e = (h = t.morphTargets).length; o < e; o++) { if ((n = {}).name = h[o].name, void 0 !== h[o].vertices) for (n.vertices = [], r = 0, i = h[o].vertices.length; r < i; r++)n.vertices.push(h[o].vertices[r].clone()); if (void 0 !== h[o].normals) for (n.normals = [], r = 0, i = h[o].normals.length; r < i; r++)n.normals.push(h[o].normals[r].clone()); this.morphTargets.push(n) } for (o = 0, e = (h = t.morphNormals).length; o < e; o++) { if (n = {}, void 0 !== h[o].vertexNormals) for (n.vertexNormals = [], r = 0, i = h[o].vertexNormals.length; r < i; r++)a = h[o].vertexNormals[r], (s = {}).a = a.a.clone(), s.b = a.b.clone(), s.c = a.c.clone(), n.vertexNormals.push(s); if (void 0 !== h[o].faceNormals) for (n.faceNormals = [], r = 0, i = h[o].faceNormals.length; r < i; r++)n.faceNormals.push(h[o].faceNormals[r].clone()); this.morphNormals.push(n) } for (o = 0, e = (r = t.skinWeights).length; o < e; o++)this.skinWeights.push(r[o].clone()); for (o = 0, e = (r = t.skinIndices).length; o < e; o++)this.skinIndices.push(r[o].clone()); for (o = 0, e = (r = t.lineDistances).length; o < e; o++)this.lineDistances.push(r[o]); return null !== (o = t.boundingBox) && (this.boundingBox = o.clone()), null !== (o = t.boundingSphere) && (this.boundingSphere = o.clone()), this.elementsNeedUpdate = t.elementsNeedUpdate, this.verticesNeedUpdate = t.verticesNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.lineDistancesNeedUpdate = t.lineDistancesNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(S.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(S.prototype, { isBufferAttribute: !0, onUploadCallback: function () { }, setArray: function (t) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== t ? t.length / this.itemSize : 0, this.array = t, this }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.name = t.name, this.array = new t.array.constructor(t.array), this.itemSize = t.itemSize, this.count = t.count, this.normalized = t.normalized, this.dynamic = t.dynamic, this }, copyAt: function (t, e, i) { t *= this.itemSize, i *= e.itemSize; for (var n = 0, r = this.itemSize; n < r; n++)this.array[t + n] = e.array[i + n]; return this }, copyArray: function (t) { return this.array.set(t), this }, copyColorsArray: function (t) { for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) { var o = t[n]; void 0 === o && (console.warn("THREE.BufferAttribute.copyColorsArray(): color is undefined", n), o = new x), e[i++] = o.r, e[i++] = o.g, e[i++] = o.b } return this }, copyVector2sArray: function (t) { for (var e = this.array, n = 0, r = 0, o = t.length; r < o; r++) { var a = t[r]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector2sArray(): vector is undefined", r), a = new i), e[n++] = a.x, e[n++] = a.y } return this }, copyVector3sArray: function (t) { for (var e = this.array, i = 0, n = 0, o = t.length; n < o; n++) { var a = t[n]; void 0 === a && (console.warn("THREE.BufferAttribute.copyVector3sArray(): vector is undefined", n), a = new r), e[i++] = a.x, e[i++] = a.y, e[i++] = a.z } return this }, copyVector4sArray: function (t) { for (var e = this.array, i = 0, n = 0, r = t.length; n < r; n++) { var o = t[n]; void 0 === o && (console.warn("THREE.BufferAttribute.copyVector4sArray(): vector is undefined", n), o = new s), e[i++] = o.x, e[i++] = o.y, e[i++] = o.z, e[i++] = o.w } return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, getX: function (t) { return this.array[t * this.itemSize] }, setX: function (t, e) { return this.array[t * this.itemSize] = e, this }, getY: function (t) { return this.array[t * this.itemSize + 1] }, setY: function (t, e) { return this.array[t * this.itemSize + 1] = e, this }, getZ: function (t) { return this.array[t * this.itemSize + 2] }, setZ: function (t, e) { return this.array[t * this.itemSize + 2] = e, this }, getW: function (t) { return this.array[t * this.itemSize + 3] }, setW: function (t, e) { return this.array[t * this.itemSize + 3] = e, this }, setXY: function (t, e, i) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this }, setXYZ: function (t, e, i, n) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this }, setXYZW: function (t, e, i, n, r) { return t *= this.itemSize, this.array[t + 0] = e, this.array[t + 1] = i, this.array[t + 2] = n, this.array[t + 3] = r, this }, onUpload: function (t) { return this.onUploadCallback = t, this }, clone: function () { return new this.constructor(this.array, this.itemSize).copy(this) }, toJSON: function () { return { itemSize: this.itemSize, type: this.array.constructor.name, array: Array.prototype.slice.call(this.array), normalized: this.normalized } } }), L.prototype = Object.create(S.prototype), L.prototype.constructor = L, C.prototype = Object.create(S.prototype), C.prototype.constructor = C, R.prototype = Object.create(S.prototype), R.prototype.constructor = R, P.prototype = Object.create(S.prototype), P.prototype.constructor = P, I.prototype = Object.create(S.prototype), I.prototype.constructor = I, O.prototype = Object.create(S.prototype), O.prototype.constructor = O, D.prototype = Object.create(S.prototype), D.prototype.constructor = D, N.prototype = Object.create(S.prototype), N.prototype.constructor = N, B.prototype = Object.create(S.prototype), B.prototype.constructor = B, Object.assign(z.prototype, { computeGroups: function (t) { var e = [], i = void 0; t = t.faces; for (var n = 0; n < t.length; n++) { var r = t[n]; if (r.materialIndex !== i) { i = r.materialIndex, void 0 !== o && (o.count = 3 * n - o.start, e.push(o)); var o = { start: 3 * n, materialIndex: i } } } void 0 !== o && (o.count = 3 * n - o.start, e.push(o)), this.groups = e }, fromGeometry: function (t) { var e = t.faces, n = t.vertices, r = t.faceVertexUvs, o = r[0] && 0 < r[0].length, a = r[1] && 0 < r[1].length, s = t.morphTargets, c = s.length; if (0 < c) { for (var h = [], l = 0; l < c; l++)h[l] = { name: s[l].name, data: [] }; this.morphTargets.position = h } var u = t.morphNormals, d = u.length; if (0 < d) { var p = []; for (l = 0; l < d; l++)p[l] = { name: u[l].name, data: [] }; this.morphTargets.normal = p } var f = t.skinIndices, m = t.skinWeights, g = f.length === n.length, v = m.length === n.length; for (0 < n.length && 0 === e.length && console.error("THREE.DirectGeometry: Faceless geometries are not supported."), l = 0; l < e.length; l++) { var y = e[l]; this.vertices.push(n[y.a], n[y.b], n[y.c]); var x = y.vertexNormals; for (3 === x.length ? this.normals.push(x[0], x[1], x[2]) : (x = y.normal, this.normals.push(x, x, x)), 3 === (x = y.vertexColors).length ? this.colors.push(x[0], x[1], x[2]) : (x = y.color, this.colors.push(x, x, x)), !0 === o && (void 0 !== (x = r[0][l]) ? this.uvs.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ", l), this.uvs.push(new i, new i, new i))), !0 === a && (void 0 !== (x = r[1][l]) ? this.uvs2.push(x[0], x[1], x[2]) : (console.warn("THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ", l), this.uvs2.push(new i, new i, new i))), x = 0; x < c; x++) { var b = s[x].vertices; h[x].data.push(b[y.a], b[y.b], b[y.c]) } for (x = 0; x < d; x++)b = u[x].vertexNormals[l], p[x].data.push(b.a, b.b, b.c); g && this.skinIndices.push(f[y.a], f[y.b], f[y.c]), v && this.skinWeights.push(m[y.a], m[y.b], m[y.c]) } return this.computeGroups(t), this.verticesNeedUpdate = t.verticesNeedUpdate, this.normalsNeedUpdate = t.normalsNeedUpdate, this.colorsNeedUpdate = t.colorsNeedUpdate, this.uvsNeedUpdate = t.uvsNeedUpdate, this.groupsNeedUpdate = t.groupsNeedUpdate, this } }); var Ao = 1; F.prototype = Object.assign(Object.create(e.prototype), { constructor: F, isBufferGeometry: !0, getIndex: function () { return this.index }, setIndex: function (t) { Array.isArray(t) ? this.index = new (65535 < U(t) ? D : I)(t, 1) : this.index = t }, addAttribute: function (t, e, i) { return e && e.isBufferAttribute || e && e.isInterleavedBufferAttribute ? "index" === t ? (console.warn("THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute."), this.setIndex(e), this) : (this.attributes[t] = e, this) : (console.warn("THREE.BufferGeometry: .addAttribute() now expects ( name, attribute )."), this.addAttribute(t, new S(e, i))) }, getAttribute: function (t) { return this.attributes[t] }, removeAttribute: function (t) { return delete this.attributes[t], this }, addGroup: function (t, e, i) { this.groups.push({ start: t, count: e, materialIndex: void 0 !== i ? i : 0 }) }, clearGroups: function () { this.groups = [] }, setDrawRange: function (t, e) { this.drawRange.start = t, this.drawRange.count = e }, applyMatrix: function (t) { var e = this.attributes.position; void 0 !== e && (t.applyToBufferAttribute(e), e.needsUpdate = !0); var i = this.attributes.normal; return void 0 !== i && ((e = (new o).getNormalMatrix(t)).applyToBufferAttribute(i), i.needsUpdate = !0), void 0 !== (i = this.attributes.tangent) && ((e = (new o).getNormalMatrix(t)).applyToBufferAttribute(i), i.needsUpdate = !0), null !== this.boundingBox && this.computeBoundingBox(), null !== this.boundingSphere && this.computeBoundingSphere(), this }, rotateX: function () { var t = new g; return function (e) { return t.makeRotationX(e), this.applyMatrix(t), this } }(), rotateY: function () { var t = new g; return function (e) { return t.makeRotationY(e), this.applyMatrix(t), this } }(), rotateZ: function () { var t = new g; return function (e) { return t.makeRotationZ(e), this.applyMatrix(t), this } }(), translate: function () { var t = new g; return function (e, i, n) { return t.makeTranslation(e, i, n), this.applyMatrix(t), this } }(), scale: function () { var t = new g; return function (e, i, n) { return t.makeScale(e, i, n), this.applyMatrix(t), this } }(), lookAt: function () { var t = new A; return function (e) { t.lookAt(e), t.updateMatrix(), this.applyMatrix(t.matrix) } }(), center: function () { var t = new r; return function () { return this.computeBoundingBox(), this.boundingBox.getCenter(t).negate(), this.translate(t.x, t.y, t.z), this } }(), setFromObject: function (t) { var e = t.geometry; if (t.isPoints || t.isLine) { t = new N(3 * e.vertices.length, 3); var i = new N(3 * e.colors.length, 3); this.addAttribute("position", t.copyVector3sArray(e.vertices)), this.addAttribute("color", i.copyColorsArray(e.colors)), e.lineDistances && e.lineDistances.length === e.vertices.length && (t = new N(e.lineDistances.length, 1), this.addAttribute("lineDistance", t.copyArray(e.lineDistances))), null !== e.boundingSphere && (this.boundingSphere = e.boundingSphere.clone()), null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()) } else t.isMesh && e && e.isGeometry && this.fromGeometry(e); return this }, setFromPoints: function (t) { for (var e = [], i = 0, n = t.length; i < n; i++) { var r = t[i]; e.push(r.x, r.y, r.z || 0) } return this.addAttribute("position", new N(e, 3)), this }, updateFromObject: function (t) { var e = t.geometry; if (t.isMesh) { var i = e.__directGeometry; if (!0 === e.elementsNeedUpdate && (i = void 0, e.elementsNeedUpdate = !1), void 0 === i) return this.fromGeometry(e); i.verticesNeedUpdate = e.verticesNeedUpdate, i.normalsNeedUpdate = e.normalsNeedUpdate, i.colorsNeedUpdate = e.colorsNeedUpdate, i.uvsNeedUpdate = e.uvsNeedUpdate, i.groupsNeedUpdate = e.groupsNeedUpdate, e.verticesNeedUpdate = !1, e.normalsNeedUpdate = !1, e.colorsNeedUpdate = !1, e.uvsNeedUpdate = !1, e.groupsNeedUpdate = !1, e = i } return !0 === e.verticesNeedUpdate && (void 0 !== (i = this.attributes.position) && (i.copyVector3sArray(e.vertices), i.needsUpdate = !0), e.verticesNeedUpdate = !1), !0 === e.normalsNeedUpdate && (void 0 !== (i = this.attributes.normal) && (i.copyVector3sArray(e.normals), i.needsUpdate = !0), e.normalsNeedUpdate = !1), !0 === e.colorsNeedUpdate && (void 0 !== (i = this.attributes.color) && (i.copyColorsArray(e.colors), i.needsUpdate = !0), e.colorsNeedUpdate = !1), e.uvsNeedUpdate && (void 0 !== (i = this.attributes.uv) && (i.copyVector2sArray(e.uvs), i.needsUpdate = !0), e.uvsNeedUpdate = !1), e.lineDistancesNeedUpdate && (void 0 !== (i = this.attributes.lineDistance) && (i.copyArray(e.lineDistances), i.needsUpdate = !0), e.lineDistancesNeedUpdate = !1), e.groupsNeedUpdate && (e.computeGroups(t.geometry), this.groups = e.groups, e.groupsNeedUpdate = !1), this }, fromGeometry: function (t) { return t.__directGeometry = (new z).fromGeometry(t), this.fromDirectGeometry(t.__directGeometry) }, fromDirectGeometry: function (t) { var e = new Float32Array(3 * t.vertices.length); for (var i in this.addAttribute("position", new S(e, 3).copyVector3sArray(t.vertices)), 0 < t.normals.length && (e = new Float32Array(3 * t.normals.length), this.addAttribute("normal", new S(e, 3).copyVector3sArray(t.normals))), 0 < t.colors.length && (e = new Float32Array(3 * t.colors.length), this.addAttribute("color", new S(e, 3).copyColorsArray(t.colors))), 0 < t.uvs.length && (e = new Float32Array(2 * t.uvs.length), this.addAttribute("uv", new S(e, 2).copyVector2sArray(t.uvs))), 0 < t.uvs2.length && (e = new Float32Array(2 * t.uvs2.length), this.addAttribute("uv2", new S(e, 2).copyVector2sArray(t.uvs2))), this.groups = t.groups, t.morphTargets) { e = []; for (var n = t.morphTargets[i], r = 0, o = n.length; r < o; r++) { var a = n[r], s = new N(3 * a.data.length, 3); s.name = a.name, e.push(s.copyVector3sArray(a.data)) } this.morphAttributes[i] = e } return 0 < t.skinIndices.length && (i = new N(4 * t.skinIndices.length, 4), this.addAttribute("skinIndex", i.copyVector4sArray(t.skinIndices))), 0 < t.skinWeights.length && (i = new N(4 * t.skinWeights.length, 4), this.addAttribute("skinWeight", i.copyVector4sArray(t.skinWeights))), null !== t.boundingSphere && (this.boundingSphere = t.boundingSphere.clone()), null !== t.boundingBox && (this.boundingBox = t.boundingBox.clone()), this }, computeBoundingBox: function () { var t = new d; return function () { null === this.boundingBox && (this.boundingBox = new d); var e = this.attributes.position, i = this.morphAttributes.position; if (void 0 !== e) { if (this.boundingBox.setFromBufferAttribute(e), i) { e = 0; for (var n = i.length; e < n; e++)t.setFromBufferAttribute(i[e]), this.boundingBox.expandByPoint(t.min), this.boundingBox.expandByPoint(t.max) } } else this.boundingBox.makeEmpty(); (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this) } }(), computeBoundingSphere: function () { var t = new d, e = new d, i = new r; return function () { null === this.boundingSphere && (this.boundingSphere = new p); var n = this.attributes.position, r = this.morphAttributes.position; if (n) { var o = this.boundingSphere.center; if (t.setFromBufferAttribute(n), r) for (var a = 0, s = r.length; a < s; a++) { var c = r[a]; e.setFromBufferAttribute(c), t.expandByPoint(e.min), t.expandByPoint(e.max) } t.getCenter(o); var h = 0; for (a = 0, s = n.count; a < s; a++)i.fromBufferAttribute(n, a), h = Math.max(h, o.distanceToSquared(i)); if (r) for (a = 0, s = r.length; a < s; a++) { n = 0; for (var l = (c = r[a]).count; n < l; n++)i.fromBufferAttribute(c, n), h = Math.max(h, o.distanceToSquared(i)) } this.boundingSphere.radius = Math.sqrt(h), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this) } } }(), computeFaceNormals: function () { }, computeVertexNormals: function () { var t = this.index, e = this.attributes; if (e.position) { var i = e.position.array; if (void 0 === e.normal) this.addAttribute("normal", new S(new Float32Array(i.length), 3)); else for (var n = e.normal.array, o = 0, a = n.length; o < a; o++)n[o] = 0; n = e.normal.array; var s = new r, c = new r, h = new r, l = new r, u = new r; if (t) { var d = t.array; for (o = 0, a = t.count; o < a; o += 3) { t = 3 * d[o + 0]; var p = 3 * d[o + 1], f = 3 * d[o + 2]; s.fromArray(i, t), c.fromArray(i, p), h.fromArray(i, f), l.subVectors(h, c), u.subVectors(s, c), l.cross(u), n[t] += l.x, n[t + 1] += l.y, n[t + 2] += l.z, n[p] += l.x, n[p + 1] += l.y, n[p + 2] += l.z, n[f] += l.x, n[f + 1] += l.y, n[f + 2] += l.z } } else for (o = 0, a = i.length; o < a; o += 9)s.fromArray(i, o), c.fromArray(i, o + 3), h.fromArray(i, o + 6), l.subVectors(h, c), u.subVectors(s, c), l.cross(u), n[o] = l.x, n[o + 1] = l.y, n[o + 2] = l.z, n[o + 3] = l.x, n[o + 4] = l.y, n[o + 5] = l.z, n[o + 6] = l.x, n[o + 7] = l.y, n[o + 8] = l.z; this.normalizeNormals(), e.normal.needsUpdate = !0 } }, merge: function (t, e) { if (t && t.isBufferGeometry) { void 0 === e && (e = 0, console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.")); var i, n = this.attributes; for (i in n) if (void 0 !== t.attributes[i]) { var r = n[i].array, o = t.attributes[i], a = o.array, s = o.itemSize * e; o = Math.min(a.length, r.length - s); for (var c = 0; c < o; c++, s++)r[s] = a[c] } return this } console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.", t) }, normalizeNormals: function () { var t = new r; return function () { for (var e = this.attributes.normal, i = 0, n = e.count; i < n; i++)t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.normalize(), e.setXYZ(i, t.x, t.y, t.z) } }(), toNonIndexed: function () { function t(t, e) { var i = t.array; t = t.itemSize; for (var n, r = new i.constructor(e.length * t), o = 0, a = 0, s = e.length; a < s; a++) { n = e[a] * t; for (var c = 0; c < t; c++)r[o++] = i[n++] } return new S(r, t) } if (null === this.index) return console.warn("THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed."), this; var e, i = new F, n = this.index.array, r = this.attributes; for (e in r) { var o = r[e]; o = t(o, n), i.addAttribute(e, o) } var a = this.morphAttributes; for (e in a) { var s = [], c = a[e]; r = 0; for (var h = c.length; r < h; r++)o = t(o = c[r], n), s.push(o); i.morphAttributes[e] = s } for (r = 0, e = (n = this.groups).length; r < e; r++)o = n[r], i.addGroup(o.start, o.count, o.materialIndex); return i }, toJSON: function () { var t = { metadata: { version: 4.5, type: "BufferGeometry", generator: "BufferGeometry.toJSON" } }; if (t.uuid = this.uuid, t.type = this.type, "" !== this.name && (t.name = this.name), 0 < Object.keys(this.userData).length && (t.userData = this.userData), void 0 !== this.parameters) { var e = this.parameters; for (h in e) void 0 !== e[h] && (t[h] = e[h]); return t } t.data = { attributes: {} }, null !== (e = this.index) && (t.data.index = { type: e.array.constructor.name, array: Array.prototype.slice.call(e.array) }); var i = this.attributes; for (h in i) { var n = (e = i[h]).toJSON(); "" !== e.name && (n.name = e.name), t.data.attributes[h] = n } i = {}; var r = !1; for (h in this.morphAttributes) { for (var o = this.morphAttributes[h], a = [], s = 0, c = o.length; s < c; s++)n = (e = o[s]).toJSON(), "" !== e.name && (n.name = e.name), a.push(n); 0 < a.length && (i[h] = a, r = !0) } r && (t.data.morphAttributes = i); var h = this.groups; return 0 < h.length && (t.data.groups = JSON.parse(JSON.stringify(h))), null !== (h = this.boundingSphere) && (t.data.boundingSphere = { center: h.center.toArray(), radius: h.radius }), t }, clone: function () { return (new F).copy(this) }, copy: function (t) { var e; this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingSphere = this.boundingBox = null, this.name = t.name; var i = t.index; for (a in null !== i && this.setIndex(i.clone()), i = t.attributes) this.addAttribute(a, i[a].clone()); var n = t.morphAttributes; for (a in n) { var r = [], o = n[a]; for (i = 0, e = o.length; i < e; i++)r.push(o[i].clone()); this.morphAttributes[a] = r } var a = t.groups; for (i = 0, e = a.length; i < e; i++)n = a[i], this.addGroup(n.start, n.count, n.materialIndex); return null !== (a = t.boundingBox) && (this.boundingBox = a.clone()), null !== (a = t.boundingSphere) && (this.boundingSphere = a.clone()), this.drawRange.start = t.drawRange.start, this.drawRange.count = t.drawRange.count, this.userData = t.userData, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), G.prototype = Object.create(T.prototype), G.prototype.constructor = G, H.prototype = Object.create(F.prototype), H.prototype.constructor = H, k.prototype = Object.create(T.prototype), k.prototype.constructor = k, V.prototype = Object.create(F.prototype), V.prototype.constructor = V; var To = 0; j.prototype = Object.assign(Object.create(e.prototype), { constructor: j, isMaterial: !0, onBeforeCompile: function () { }, setValues: function (t) { if (void 0 !== t) for (var e in t) { var i = t[e]; if (void 0 === i) console.warn("THREE.Material: '" + e + "' parameter is undefined."); else if ("shading" === e) console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === i; else { var n = this[e]; void 0 === n ? console.warn("THREE." + this.type + ": '" + e + "' is not a property of this material.") : n && n.isColor ? n.set(i) : n && n.isVector3 && i && i.isVector3 ? n.copy(i) : this[e] = i } } }, toJSON: function (t) { function e(t) { var e, i = []; for (e in t) { var n = t[e]; delete n.metadata, i.push(n) } return i } var i = void 0 === t || "string" == typeof t; i && (t = { textures: {}, images: {} }); var n = { metadata: { version: 4.5, type: "Material", generator: "Material.toJSON" } }; return n.uuid = this.uuid, n.type = this.type, "" !== this.name && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), void 0 !== this.roughness && (n.roughness = this.roughness), void 0 !== this.metalness && (n.metalness = this.metalness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), 1 !== this.emissiveIntensity && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), void 0 !== this.shininess && (n.shininess = this.shininess), void 0 !== this.clearCoat && (n.clearCoat = this.clearCoat), void 0 !== this.clearCoatRoughness && (n.clearCoatRoughness = this.clearCoatRoughness), this.map && this.map.isTexture && (n.map = this.map.toJSON(t).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(t).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(t).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(t).uuid), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(t).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(t).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(t).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(t).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(t).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(t).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(t).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(t).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(t).uuid, n.reflectivity = this.reflectivity, void 0 !== this.combine && (n.combine = this.combine), void 0 !== this.envMapIntensity && (n.envMapIntensity = this.envMapIntensity)), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(t).uuid), void 0 !== this.size && (n.size = this.size), void 0 !== this.sizeAttenuation && (n.sizeAttenuation = this.sizeAttenuation), 1 !== this.blending && (n.blending = this.blending), !0 === this.flatShading && (n.flatShading = this.flatShading), 0 !== this.side && (n.side = this.side), 0 !== this.vertexColors && (n.vertexColors = this.vertexColors), 1 > this.opacity && (n.opacity = this.opacity), !0 === this.transparent && (n.transparent = this.transparent), n.depthFunc = this.depthFunc, n.depthTest = this.depthTest, n.depthWrite = this.depthWrite, 0 !== this.rotation && (n.rotation = this.rotation), !0 === this.polygonOffset && (n.polygonOffset = !0), 0 !== this.polygonOffsetFactor && (n.polygonOffsetFactor = this.polygonOffsetFactor), 0 !== this.polygonOffsetUnits && (n.polygonOffsetUnits = this.polygonOffsetUnits), 1 !== this.linewidth && (n.linewidth = this.linewidth), void 0 !== this.dashSize && (n.dashSize = this.dashSize), void 0 !== this.gapSize && (n.gapSize = this.gapSize), void 0 !== this.scale && (n.scale = this.scale), !0 === this.dithering && (n.dithering = !0), 0 < this.alphaTest && (n.alphaTest = this.alphaTest), !0 === this.premultipliedAlpha && (n.premultipliedAlpha = this.premultipliedAlpha), !0 === this.wireframe && (n.wireframe = this.wireframe), 1 < this.wireframeLinewidth && (n.wireframeLinewidth = this.wireframeLinewidth), "round" !== this.wireframeLinecap && (n.wireframeLinecap = this.wireframeLinecap), "round" !== this.wireframeLinejoin && (n.wireframeLinejoin = this.wireframeLinejoin), !0 === this.morphTargets && (n.morphTargets = !0), !0 === this.skinning && (n.skinning = !0), !1 === this.visible && (n.visible = !1), "{}" !== JSON.stringify(this.userData) && (n.userData = this.userData), i && (i = e(t.textures), t = e(t.images), 0 < i.length && (n.textures = i), 0 < t.length && (n.images = t)), n }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { this.name = t.name, this.fog = t.fog, this.lights = t.lights, this.blending = t.blending, this.side = t.side, this.flatShading = t.flatShading, this.vertexColors = t.vertexColors, this.opacity = t.opacity, this.transparent = t.transparent, this.blendSrc = t.blendSrc, this.blendDst = t.blendDst, this.blendEquation = t.blendEquation, this.blendSrcAlpha = t.blendSrcAlpha, this.blendDstAlpha = t.blendDstAlpha, this.blendEquationAlpha = t.blendEquationAlpha, this.depthFunc = t.depthFunc, this.depthTest = t.depthTest, this.depthWrite = t.depthWrite, this.colorWrite = t.colorWrite, this.precision = t.precision, this.polygonOffset = t.polygonOffset, this.polygonOffsetFactor = t.polygonOffsetFactor, this.polygonOffsetUnits = t.polygonOffsetUnits, this.dithering = t.dithering, this.alphaTest = t.alphaTest, this.premultipliedAlpha = t.premultipliedAlpha, this.visible = t.visible, this.userData = JSON.parse(JSON.stringify(t.userData)), this.clipShadows = t.clipShadows, this.clipIntersection = t.clipIntersection; var e = t.clippingPlanes, i = null; if (null !== e) { var n = e.length; i = Array(n); for (var r = 0; r !== n; ++r)i[r] = e[r].clone() } return this.clippingPlanes = i, this.shadowSide = t.shadowSide, this }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), W.prototype = Object.create(j.prototype), W.prototype.constructor = W, W.prototype.isShaderMaterial = !0, W.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.fragmentShader = t.fragmentShader, this.vertexShader = t.vertexShader, this.uniforms = v(t.uniforms), this.defines = Object.assign({}, t.defines), this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.lights = t.lights, this.clipping = t.clipping, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this.extensions = t.extensions, this }, W.prototype.toJSON = function (t) { var e = j.prototype.toJSON.call(this, t); for (var i in e.uniforms = {}, this.uniforms) { var n = this.uniforms[i].value; e.uniforms[i] = n && n.isTexture ? { type: "t", value: n.toJSON(t).uuid } : n && n.isColor ? { type: "c", value: n.getHex() } : n && n.isVector2 ? { type: "v2", value: n.toArray() } : n && n.isVector3 ? { type: "v3", value: n.toArray() } : n && n.isVector4 ? { type: "v4", value: n.toArray() } : n && n.isMatrix3 ? { type: "m3", value: n.toArray() } : n && n.isMatrix4 ? { type: "m4", value: n.toArray() } : { value: n } } for (var r in 0 < Object.keys(this.defines).length && (e.defines = this.defines), e.vertexShader = this.vertexShader, e.fragmentShader = this.fragmentShader, t = {}, this.extensions) !0 === this.extensions[r] && (t[r] = !0); return 0 < Object.keys(t).length && (e.extensions = t), e }, Object.assign(q.prototype, { set: function (t, e) { return this.origin.copy(t), this.direction.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.origin.copy(t.origin), this.direction.copy(t.direction), this }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Ray: .at() target is now required"), e = new r), e.copy(this.direction).multiplyScalar(t).add(this.origin) }, lookAt: function (t) { return this.direction.copy(t).sub(this.origin).normalize(), this }, recast: function () { var t = new r; return function (e) { return this.origin.copy(this.at(e, t)), this } }(), closestPointToPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Ray: .closestPointToPoint() target is now required"), e = new r), e.subVectors(t, this.origin), 0 > (t = e.dot(this.direction)) ? e.copy(this.origin) : e.copy(this.direction).multiplyScalar(t).add(this.origin) }, distanceToPoint: function (t) { return Math.sqrt(this.distanceSqToPoint(t)) }, distanceSqToPoint: function () { var t = new r; return function (e) { var i = t.subVectors(e, this.origin).dot(this.direction); return 0 > i ? this.origin.distanceToSquared(e) : (t.copy(this.direction).multiplyScalar(i).add(this.origin), t.distanceToSquared(e)) } }(), distanceSqToSegment: function () { var t = new r, e = new r, i = new r; return function (n, r, o, a) { t.copy(n).add(r).multiplyScalar(.5), e.copy(r).sub(n).normalize(), i.copy(this.origin).sub(t); var s = .5 * n.distanceTo(r), c = -this.direction.dot(e), h = i.dot(this.direction), l = -i.dot(e), u = i.lengthSq(), d = Math.abs(1 - c * c); if (0 < d) { r = c * h - l; var p = s * d; 0 <= (n = c * l - h) ? r >= -p ? r <= p ? c = (n *= s = 1 / d) * (n + c * (r *= s) + 2 * h) + r * (c * n + r + 2 * l) + u : (r = s, c = -(n = Math.max(0, -(c * r + h))) * n + r * (r + 2 * l) + u) : (r = -s, c = -(n = Math.max(0, -(c * r + h))) * n + r * (r + 2 * l) + u) : r <= -p ? c = -(n = Math.max(0, -(-c * s + h))) * n + (r = 0 < n ? -s : Math.min(Math.max(-s, -l), s)) * (r + 2 * l) + u : r <= p ? (n = 0, c = (r = Math.min(Math.max(-s, -l), s)) * (r + 2 * l) + u) : c = -(n = Math.max(0, -(c * s + h))) * n + (r = 0 < n ? s : Math.min(Math.max(-s, -l), s)) * (r + 2 * l) + u } else r = 0 < c ? -s : s, c = -(n = Math.max(0, -(c * r + h))) * n + r * (r + 2 * l) + u; return o && o.copy(this.direction).multiplyScalar(n).add(this.origin), a && a.copy(e).multiplyScalar(r).add(t), c } }(), intersectSphere: function () { var t = new r; return function (e, i) { t.subVectors(e.center, this.origin); var n = t.dot(this.direction), r = t.dot(t) - n * n; return r > (e = e.radius * e.radius) ? null : (r = n - (e = Math.sqrt(e - r)), n += e, 0 > r && 0 > n ? null : 0 > r ? this.at(n, i) : this.at(r, i)) } }(), intersectsSphere: function (t) { return this.distanceSqToPoint(t.center) <= t.radius * t.radius }, distanceToPlane: function (t) { var e = t.normal.dot(this.direction); return 0 === e ? 0 === t.distanceToPoint(this.origin) ? 0 : null : 0 <= (t = -(this.origin.dot(t.normal) + t.constant) / e) ? t : null }, intersectPlane: function (t, e) { return null === (t = this.distanceToPlane(t)) ? null : this.at(t, e) }, intersectsPlane: function (t) { var e = t.distanceToPoint(this.origin); return 0 === e || 0 > t.normal.dot(this.direction) * e }, intersectBox: function (t, e) { var i = 1 / this.direction.x, n = 1 / this.direction.y, r = 1 / this.direction.z, o = this.origin; if (0 <= i) { var a = (t.min.x - o.x) * i; i *= t.max.x - o.x } else a = (t.max.x - o.x) * i, i *= t.min.x - o.x; if (0 <= n) { var s = (t.min.y - o.y) * n; n *= t.max.y - o.y } else s = (t.max.y - o.y) * n, n *= t.min.y - o.y; return a > n || s > i ? null : ((s > a || a != a) && (a = s), (n < i || i != i) && (i = n), 0 <= r ? (s = (t.min.z - o.z) * r, t = (t.max.z - o.z) * r) : (s = (t.max.z - o.z) * r, t = (t.min.z - o.z) * r), a > t || s > i ? null : ((s > a || a != a) && (a = s), (t < i || i != i) && (i = t), 0 > i ? null : this.at(0 <= a ? a : i, e))) }, intersectsBox: function () { var t = new r; return function (e) { return null !== this.intersectBox(e, t) } }(), intersectTriangle: function () { var t = new r, e = new r, i = new r, n = new r; return function (r, o, a, s, c) { if (e.subVectors(o, r), i.subVectors(a, r), n.crossVectors(e, i), 0 < (o = this.direction.dot(n))) { if (s) return null; s = 1 } else { if (!(0 > o)) return null; s = -1, o = -o } return t.subVectors(this.origin, r), 0 > (r = s * this.direction.dot(i.crossVectors(t, i))) || 0 > (a = s * this.direction.dot(e.cross(t))) || r + a > o || 0 > (r = -s * t.dot(n)) ? null : this.at(r / o, c) } }(), applyMatrix4: function (t) { return this.origin.applyMatrix4(t), this.direction.transformDirection(t), this }, equals: function (t) { return t.origin.equals(this.origin) && t.direction.equals(this.direction) } }), Object.assign(X, { getNormal: function () { var t = new r; return function (e, i, n, o) { return void 0 === o && (console.warn("THREE.Triangle: .getNormal() target is now required"), o = new r), o.subVectors(n, i), t.subVectors(e, i), o.cross(t), 0 < (e = o.lengthSq()) ? o.multiplyScalar(1 / Math.sqrt(e)) : o.set(0, 0, 0) } }(), getBarycoord: function () { var t = new r, e = new r, i = new r; return function (n, o, a, s, c) { t.subVectors(s, o), e.subVectors(a, o), i.subVectors(n, o), n = t.dot(t), o = t.dot(e), a = t.dot(i); var h = e.dot(e); s = e.dot(i); var l = n * h - o * o; return void 0 === c && (console.warn("THREE.Triangle: .getBarycoord() target is now required"), c = new r), 0 === l ? c.set(-2, -1, -1) : (h = (h * a - o * s) * (l = 1 / l), n = (n * s - o * a) * l, c.set(1 - h - n, n, h)) } }(), containsPoint: function () { var t = new r; return function (e, i, n, r) { return X.getBarycoord(e, i, n, r, t), 0 <= t.x && 0 <= t.y && 1 >= t.x + t.y } }(), getUV: function () { var t = new r; return function (e, i, n, r, o, a, s, c) { return this.getBarycoord(e, i, n, r, t), c.set(0, 0), c.addScaledVector(o, t.x), c.addScaledVector(a, t.y), c.addScaledVector(s, t.z), c } }(), isFrontFacing: function () { var t = new r, e = new r; return function (i, n, r, o) { return t.subVectors(r, n), e.subVectors(i, n), 0 > t.cross(e).dot(o) } }() }), Object.assign(X.prototype, { set: function (t, e, i) { return this.a.copy(t), this.b.copy(e), this.c.copy(i), this }, setFromPointsAndIndices: function (t, e, i, n) { return this.a.copy(t[e]), this.b.copy(t[i]), this.c.copy(t[n]), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.a.copy(t.a), this.b.copy(t.b), this.c.copy(t.c), this }, getArea: function () { var t = new r, e = new r; return function () { return t.subVectors(this.c, this.b), e.subVectors(this.a, this.b), .5 * t.cross(e).length() } }(), getMidpoint: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getMidpoint() target is now required"), t = new r), t.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3) }, getNormal: function (t) { return X.getNormal(this.a, this.b, this.c, t) }, getPlane: function (t) { return void 0 === t && (console.warn("THREE.Triangle: .getPlane() target is now required"), t = new r), t.setFromCoplanarPoints(this.a, this.b, this.c) }, getBarycoord: function (t, e) { return X.getBarycoord(t, this.a, this.b, this.c, e) }, getUV: function (t, e, i, n, r) { return X.getUV(t, this.a, this.b, this.c, e, i, n, r) }, containsPoint: function (t) { return X.containsPoint(t, this.a, this.b, this.c) }, isFrontFacing: function (t) { return X.isFrontFacing(this.a, this.b, this.c, t) }, intersectsBox: function (t) { return t.intersectsTriangle(this) }, closestPointToPoint: function () { var t = new r, e = new r, i = new r, n = new r, o = new r, a = new r; return function (s, c) { void 0 === c && (console.warn("THREE.Triangle: .closestPointToPoint() target is now required"), c = new r); var h = this.a, l = this.b, u = this.c; t.subVectors(l, h), e.subVectors(u, h), n.subVectors(s, h); var d = t.dot(n), p = e.dot(n); if (0 >= d && 0 >= p) return c.copy(h); o.subVectors(s, l); var f = t.dot(o), m = e.dot(o); if (0 <= f && m <= f) return c.copy(l); var g = d * m - f * p; if (0 >= g && 0 <= d && 0 >= f) return l = d / (d - f), c.copy(h).addScaledVector(t, l); a.subVectors(s, u), s = t.dot(a); var v = e.dot(a); return 0 <= v && s <= v ? c.copy(u) : 0 >= (d = s * p - d * v) && 0 <= p && 0 >= v ? (g = p / (p - v), c.copy(h).addScaledVector(e, g)) : 0 >= (p = f * v - s * m) && 0 <= m - f && 0 <= s - v ? (i.subVectors(u, l), g = (m - f) / (m - f + (s - v)), c.copy(l).addScaledVector(i, g)) : (l = d * (u = 1 / (p + d + g)), g *= u, c.copy(h).addScaledVector(t, l).addScaledVector(e, g)) } }(), equals: function (t) { return t.a.equals(this.a) && t.b.equals(this.b) && t.c.equals(this.c) } }), Y.prototype = Object.create(j.prototype), Y.prototype.constructor = Y, Y.prototype.isMeshBasicMaterial = !0, Y.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this }, Z.prototype = Object.assign(Object.create(A.prototype), { constructor: Z, isMesh: !0, setDrawMode: function (t) { this.drawMode = t }, copy: function (t) { return A.prototype.copy.call(this, t), this.drawMode = t.drawMode, void 0 !== t.morphTargetInfluences && (this.morphTargetInfluences = t.morphTargetInfluences.slice()), void 0 !== t.morphTargetDictionary && (this.morphTargetDictionary = Object.assign({}, t.morphTargetDictionary)), this }, updateMorphTargets: function () { var t = this.geometry; if (t.isBufferGeometry) { t = t.morphAttributes; var e = Object.keys(t); if (0 < e.length) { var i = t[e[0]]; if (void 0 !== i) for (this.morphTargetInfluences = [], this.morphTargetDictionary = {}, t = 0, e = i.length; t < e; t++) { var n = i[t].name || String(t); this.morphTargetInfluences.push(0), this.morphTargetDictionary[n] = t } } } else void 0 !== (t = t.morphTargets) && 0 < t.length && console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.") }, raycast: function () { function t(t, e, i, n, r, o, a, s) { return null === (1 === e.side ? n.intersectTriangle(a, o, r, !0, s) : n.intersectTriangle(r, o, a, 2 !== e.side, s)) ? null : (_.copy(s), _.applyMatrix4(t.matrixWorld), (e = i.ray.origin.distanceTo(_)) < i.near || e > i.far ? null : { distance: e, point: _.clone(), object: t }) } function e(e, n, r, o, a, p, g, _, E, A) { if (s.fromBufferAttribute(a, _), c.fromBufferAttribute(a, E), h.fromBufferAttribute(a, A), a = e.morphTargetInfluences, n.morphTargets && p && a) { f.set(0, 0, 0), m.set(0, 0, 0), v.set(0, 0, 0); for (var T = 0, S = p.length; T < S; T++) { var L = a[T], C = p[T]; 0 !== L && (l.fromBufferAttribute(C, _), u.fromBufferAttribute(C, E), d.fromBufferAttribute(C, A), f.addScaledVector(l.sub(s), L), m.addScaledVector(u.sub(c), L), v.addScaledVector(d.sub(h), L)) } s.add(f), c.add(m), h.add(v) } return (e = t(e, n, r, o, s, c, h, w)) && (g && (y.fromBufferAttribute(g, _), x.fromBufferAttribute(g, E), b.fromBufferAttribute(g, A), e.uv = X.getUV(w, s, c, h, y, x, b, new i)), g = new M(_, E, A), X.getNormal(s, c, h, g.normal), e.face = g), e } var n = new g, o = new q, a = new p, s = new r, c = new r, h = new r, l = new r, u = new r, d = new r, f = new r, m = new r, v = new r, y = new i, x = new i, b = new i, w = new r, _ = new r; return function (r, s) { var c = this.geometry, h = this.material, l = this.matrixWorld; if (void 0 !== h && (null === c.boundingSphere && c.computeBoundingSphere(), a.copy(c.boundingSphere), a.applyMatrix4(l), !1 !== r.ray.intersectsSphere(a) && (n.getInverse(l), o.copy(r.ray).applyMatrix4(n), null === c.boundingBox || !1 !== o.intersectsBox(c.boundingBox)))) if (c.isBufferGeometry) { var u = c.index; l = c.attributes.position; var d, p, f = c.morphAttributes.position, m = c.attributes.uv, g = c.groups, v = c.drawRange; if (null !== u) if (Array.isArray(h)) { var M = 0; for (d = g.length; M < d; M++) { var _ = g[M], E = h[_.materialIndex], A = Math.max(_.start, v.start); for (p = c = Math.min(_.start + _.count, v.start + v.count); A < p; A += 3) { c = u.getX(A); var T = u.getX(A + 1), S = u.getX(A + 2); (c = e(this, E, r, o, l, f, m, c, T, S)) && (c.faceIndex = Math.floor(A / 3), c.face.materialIndex = _.materialIndex, s.push(c)) } } } else for (M = A = Math.max(0, v.start), d = c = Math.min(u.count, v.start + v.count); M < d; M += 3)c = u.getX(M), T = u.getX(M + 1), S = u.getX(M + 2), (c = e(this, h, r, o, l, f, m, c, T, S)) && (c.faceIndex = Math.floor(M / 3), s.push(c)); else if (void 0 !== l) if (Array.isArray(h)) for (M = 0, d = g.length; M < d; M++)for (E = h[(_ = g[M]).materialIndex], A = Math.max(_.start, v.start), p = c = Math.min(_.start + _.count, v.start + v.count); A < p; A += 3)(c = e(this, E, r, o, l, f, m, c = A, T = A + 1, S = A + 2)) && (c.faceIndex = Math.floor(A / 3), c.face.materialIndex = _.materialIndex, s.push(c)); else for (M = A = Math.max(0, v.start), d = c = Math.min(l.count, v.start + v.count); M < d; M += 3)(c = e(this, h, r, o, l, f, m, c = M, T = M + 1, S = M + 2)) && (c.faceIndex = Math.floor(M / 3), s.push(c)) } else if (c.isGeometry) for (l = Array.isArray(h), f = c.vertices, m = c.faces, 0 < (c = c.faceVertexUvs[0]).length && (u = c), d = 0, _ = m.length; d < _; d++)E = m[d], void 0 !== (c = l ? h[E.materialIndex] : h) && (g = f[E.a], v = f[E.b], M = f[E.c], c = t(this, c, r, o, g, v, M, w)) && (u && u[d] && (A = u[d], y.copy(A[0]), x.copy(A[1]), b.copy(A[2]), c.uv = X.getUV(w, g, v, M, y, x, b, new i)), c.face = E, c.faceIndex = d, s.push(c)) } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), st.prototype = Object.create(a.prototype), st.prototype.constructor = st, st.prototype.isCubeTexture = !0, Object.defineProperty(st.prototype, "images", { get: function () { return this.image }, set: function (t) { this.image = t } }), ct.prototype = Object.create(a.prototype), ct.prototype.constructor = ct, ct.prototype.isDataTexture2DArray = !0, ht.prototype = Object.create(a.prototype), ht.prototype.constructor = ht, ht.prototype.isDataTexture3D = !0; var So = new a, Lo = new ct, Co = new ht, Ro = new st, Po = [], Io = [], Oo = new Float32Array(16), Do = new Float32Array(9), No = new Float32Array(4); Vt.prototype.updateCache = function (t) { var e = this.cache; t instanceof Float32Array && e.length !== t.length && (this.cache = new Float32Array(t.length)), dt(e, t) }, jt.prototype.setValue = function (t, e, i) { for (var n = this.seq, r = 0, o = n.length; r !== o; ++r) { var a = n[r]; a.setValue(t, e[a.id], i) } }; var Bo = /([\w\d_]+)(\])?(\[|\.)?/g; Wt.prototype.setValue = function (t, e, i, n) { void 0 !== (e = this.map[e]) && e.setValue(t, i, n) }, Wt.prototype.setOptional = function (t, e, i) { void 0 !== (e = e[i]) && this.setValue(t, i, e) }, Wt.upload = function (t, e, i, n) { for (var r = 0, o = e.length; r !== o; ++r) { var a = e[r], s = i[a.id]; !1 !== s.needsUpdate && a.setValue(t, s.value, n) } }, Wt.seqWithValue = function (t, e) { for (var i = [], n = 0, r = t.length; n !== r; ++n) { var o = t[n]; o.id in e && i.push(o) } return i }; var zo = 0, Uo = 0; pe.prototype = Object.create(j.prototype), pe.prototype.constructor = pe, pe.prototype.isMeshDepthMaterial = !0, pe.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.depthPacking = t.depthPacking, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this }, fe.prototype = Object.create(j.prototype), fe.prototype.constructor = fe, fe.prototype.isMeshDistanceMaterial = !0, fe.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.referencePosition.copy(t.referencePosition), this.nearDistance = t.nearDistance, this.farDistance = t.farDistance, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.map = t.map, this.alphaMap = t.alphaMap, this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this }, xe.prototype = Object.assign(Object.create(A.prototype), { constructor: xe, isGroup: !0 }), be.prototype = Object.assign(Object.create(A.prototype), { constructor: be, isCamera: !0, copy: function (t, e) { return A.prototype.copy.call(this, t, e), this.matrixWorldInverse.copy(t.matrixWorldInverse), this.projectionMatrix.copy(t.projectionMatrix), this.projectionMatrixInverse.copy(t.projectionMatrixInverse), this }, getWorldDirection: function (t) { void 0 === t && (console.warn("THREE.Camera: .getWorldDirection() target is now required"), t = new r), this.updateMatrixWorld(!0); var e = this.matrixWorld.elements; return t.set(-e[8], -e[9], -e[10]).normalize() }, updateMatrixWorld: function (t) { A.prototype.updateMatrixWorld.call(this, t), this.matrixWorldInverse.getInverse(this.matrixWorld) }, clone: function () { return (new this.constructor).copy(this) } }), we.prototype = Object.assign(Object.create(be.prototype), { constructor: we, isPerspectiveCamera: !0, copy: function (t, e) { return be.prototype.copy.call(this, t, e), this.fov = t.fov, this.zoom = t.zoom, this.near = t.near, this.far = t.far, this.focus = t.focus, this.aspect = t.aspect, this.view = null === t.view ? null : Object.assign({}, t.view), this.filmGauge = t.filmGauge, this.filmOffset = t.filmOffset, this }, setFocalLength: function (t) { t = .5 * this.getFilmHeight() / t, this.fov = 2 * fo.RAD2DEG * Math.atan(t), this.updateProjectionMatrix() }, getFocalLength: function () { var t = Math.tan(.5 * fo.DEG2RAD * this.fov); return .5 * this.getFilmHeight() / t }, getEffectiveFOV: function () { return 2 * fo.RAD2DEG * Math.atan(Math.tan(.5 * fo.DEG2RAD * this.fov) / this.zoom) }, getFilmWidth: function () { return this.filmGauge * Math.min(this.aspect, 1) }, getFilmHeight: function () { return this.filmGauge / Math.max(this.aspect, 1) }, setViewOffset: function (t, e, i, n, r, o) { this.aspect = t / e, null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t = this.near, e = t * Math.tan(.5 * fo.DEG2RAD * this.fov) / this.zoom, i = 2 * e, n = this.aspect * i, r = -.5 * n, o = this.view; if (null !== this.view && this.view.enabled) { var a = o.fullWidth, s = o.fullHeight; r += o.offsetX * n / a, e -= o.offsetY * i / s, n *= o.width / a, i *= o.height / s } 0 !== (o = this.filmOffset) && (r += t * o / this.getFilmWidth()), this.projectionMatrix.makePerspective(r, r + n, e, e - i, t, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { return (t = A.prototype.toJSON.call(this, t)).object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, null !== this.view && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t } }), Me.prototype = Object.assign(Object.create(we.prototype), { constructor: Me, isArrayCamera: !0 }); var Fo, Go = new r, Ho = new r; Object.assign(Se.prototype, { isFogExp2: !0, clone: function () { return new Se(this.color, this.density) }, toJSON: function () { return { type: "FogExp2", color: this.color.getHex(), density: this.density } } }), Object.assign(Le.prototype, { isFog: !0, clone: function () { return new Le(this.color, this.near, this.far) }, toJSON: function () { return { type: "Fog", color: this.color.getHex(), near: this.near, far: this.far } } }), Ce.prototype = Object.assign(Object.create(A.prototype), { constructor: Ce, isScene: !0, copy: function (t, e) { return A.prototype.copy.call(this, t, e), null !== t.background && (this.background = t.background.clone()), null !== t.fog && (this.fog = t.fog.clone()), null !== t.overrideMaterial && (this.overrideMaterial = t.overrideMaterial.clone()), this.autoUpdate = t.autoUpdate, this.matrixAutoUpdate = t.matrixAutoUpdate, this }, toJSON: function (t) { var e = A.prototype.toJSON.call(this, t); return null !== this.background && (e.object.background = this.background.toJSON(t)), null !== this.fog && (e.object.fog = this.fog.toJSON()), e }, dispose: function () { this.dispatchEvent({ type: "dispose" }) } }), Object.defineProperty(Re.prototype, "needsUpdate", { set: function (t) { !0 === t && this.version++ } }), Object.assign(Re.prototype, { isInterleavedBuffer: !0, onUploadCallback: function () { }, setArray: function (t) { if (Array.isArray(t)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array."); return this.count = void 0 !== t ? t.length / this.stride : 0, this.array = t, this }, setDynamic: function (t) { return this.dynamic = t, this }, copy: function (t) { return this.array = new t.array.constructor(t.array), this.count = t.count, this.stride = t.stride, this.dynamic = t.dynamic, this }, copyAt: function (t, e, i) { t *= this.stride, i *= e.stride; for (var n = 0, r = this.stride; n < r; n++)this.array[t + n] = e.array[i + n]; return this }, set: function (t, e) { return void 0 === e && (e = 0), this.array.set(t, e), this }, clone: function () { return (new this.constructor).copy(this) }, onUpload: function (t) { return this.onUploadCallback = t, this } }), Object.defineProperties(Pe.prototype, { count: { get: function () { return this.data.count } }, array: { get: function () { return this.data.array } } }), Object.assign(Pe.prototype, { isInterleavedBufferAttribute: !0, setX: function (t, e) { return this.data.array[t * this.data.stride + this.offset] = e, this }, setY: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 1] = e, this }, setZ: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 2] = e, this }, setW: function (t, e) { return this.data.array[t * this.data.stride + this.offset + 3] = e, this }, getX: function (t) { return this.data.array[t * this.data.stride + this.offset] }, getY: function (t) { return this.data.array[t * this.data.stride + this.offset + 1] }, getZ: function (t) { return this.data.array[t * this.data.stride + this.offset + 2] }, getW: function (t) { return this.data.array[t * this.data.stride + this.offset + 3] }, setXY: function (t, e, i) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this }, setXYZ: function (t, e, i, n) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this }, setXYZW: function (t, e, i, n, r) { return t = t * this.data.stride + this.offset, this.data.array[t + 0] = e, this.data.array[t + 1] = i, this.data.array[t + 2] = n, this.data.array[t + 3] = r, this } }), Ie.prototype = Object.create(j.prototype), Ie.prototype.constructor = Ie, Ie.prototype.isSpriteMaterial = !0, Ie.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.rotation = t.rotation, this.sizeAttenuation = t.sizeAttenuation, this }, Oe.prototype = Object.assign(Object.create(A.prototype), { constructor: Oe, isSprite: !0, raycast: function () { function t(t, e, i, n, r, o) { a.subVectors(t, i).addScalar(.5).multiply(n), void 0 !== r ? (s.x = o * a.x - r * a.y, s.y = r * a.x + o * a.y) : s.copy(a), t.copy(e), t.x += s.x, t.y += s.y, t.applyMatrix4(c) } var e = new r, n = new r, o = new r, a = new i, s = new i, c = new g, h = new r, l = new r, u = new r, d = new i, p = new i, f = new i; return function (r, a) { n.setFromMatrixScale(this.matrixWorld), c.getInverse(this.modelViewMatrix).premultiply(this.matrixWorld), o.setFromMatrixPosition(this.modelViewMatrix); var s = this.material.rotation; if (0 !== s) var m = Math.cos(s), g = Math.sin(s); s = this.center, t(h.set(-.5, -.5, 0), o, s, n, g, m), t(l.set(.5, -.5, 0), o, s, n, g, m), t(u.set(.5, .5, 0), o, s, n, g, m), d.set(0, 0), p.set(1, 0), f.set(1, 1); var v = r.ray.intersectTriangle(h, l, u, !1, e); null === v && (t(l.set(-.5, .5, 0), o, s, n, g, m), p.set(0, 1), null === (v = r.ray.intersectTriangle(h, u, l, !1, e))) || (g = r.ray.origin.distanceTo(e)) < r.near || g > r.far || a.push({ distance: g, point: e.clone(), uv: X.getUV(e, h, l, u, d, p, f, new i), face: null, object: this }) } }(), clone: function () { return new this.constructor(this.material).copy(this) }, copy: function (t) { return A.prototype.copy.call(this, t), void 0 !== t.center && this.center.copy(t.center), this } }), De.prototype = Object.assign(Object.create(A.prototype), { constructor: De, isLOD: !0, copy: function (t) { A.prototype.copy.call(this, t, !1); for (var e = 0, i = (t = t.levels).length; e < i; e++) { var n = t[e]; this.addLevel(n.object.clone(), n.distance) } return this }, addLevel: function (t, e) { void 0 === e && (e = 0), e = Math.abs(e); for (var i = this.levels, n = 0; n < i.length && !(e < i[n].distance); n++); return i.splice(n, 0, { distance: e, object: t }), this.add(t), this }, getObjectForDistance: function (t) { for (var e = this.levels, i = 1, n = e.length; i < n && !(t < e[i].distance); i++); return e[i - 1].object }, raycast: function () { var t = new r; return function (e, i) { t.setFromMatrixPosition(this.matrixWorld); var n = e.ray.origin.distanceTo(t); this.getObjectForDistance(n).raycast(e, i) } }(), update: function () { var t = new r, e = new r; return function (i) { var n = this.levels; if (1 < n.length) { t.setFromMatrixPosition(i.matrixWorld), e.setFromMatrixPosition(this.matrixWorld), i = t.distanceTo(e), n[0].object.visible = !0; for (var r = 1, o = n.length; r < o && i >= n[r].distance; r++)n[r - 1].object.visible = !1, n[r].object.visible = !0; for (; r < o; r++)n[r].object.visible = !1 } } }(), toJSON: function (t) { (t = A.prototype.toJSON.call(this, t)).object.levels = []; for (var e = this.levels, i = 0, n = e.length; i < n; i++) { var r = e[i]; t.object.levels.push({ object: r.object.uuid, distance: r.distance }) } return t } }), Ne.prototype = Object.assign(Object.create(Z.prototype), { constructor: Ne, isSkinnedMesh: !0, bind: function (t, e) { this.skeleton = t, void 0 === e && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), e = this.matrixWorld), this.bindMatrix.copy(e), this.bindMatrixInverse.getInverse(e) }, pose: function () { this.skeleton.pose() }, normalizeSkinWeights: function () { for (var t = new s, e = this.geometry.attributes.skinWeight, i = 0, n = e.count; i < n; i++) { t.x = e.getX(i), t.y = e.getY(i), t.z = e.getZ(i), t.w = e.getW(i); var r = 1 / t.manhattanLength(); 1 / 0 !== r ? t.multiplyScalar(r) : t.set(1, 0, 0, 0), e.setXYZW(i, t.x, t.y, t.z, t.w) } }, updateMatrixWorld: function (t) { Z.prototype.updateMatrixWorld.call(this, t), "attached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.matrixWorld) : "detached" === this.bindMode ? this.bindMatrixInverse.getInverse(this.bindMatrix) : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode) }, clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), Object.assign(Be.prototype, { calculateInverses: function () { this.boneInverses = []; for (var t = 0, e = this.bones.length; t < e; t++) { var i = new g; this.bones[t] && i.getInverse(this.bones[t].matrixWorld), this.boneInverses.push(i) } }, pose: function () { var t, e, i = 0; for (e = this.bones.length; i < e; i++)(t = this.bones[i]) && t.matrixWorld.getInverse(this.boneInverses[i]); for (i = 0, e = this.bones.length; i < e; i++)(t = this.bones[i]) && (t.parent && t.parent.isBone ? (t.matrix.getInverse(t.parent.matrixWorld), t.matrix.multiply(t.matrixWorld)) : t.matrix.copy(t.matrixWorld), t.matrix.decompose(t.position, t.quaternion, t.scale)) }, update: function () { var t = new g, e = new g; return function () { for (var i = this.bones, n = this.boneInverses, r = this.boneMatrices, o = this.boneTexture, a = 0, s = i.length; a < s; a++)t.multiplyMatrices(i[a] ? i[a].matrixWorld : e, n[a]), t.toArray(r, 16 * a); void 0 !== o && (o.needsUpdate = !0) } }(), clone: function () { return new Be(this.bones, this.boneInverses) }, getBoneByName: function (t) { for (var e = 0, i = this.bones.length; e < i; e++) { var n = this.bones[e]; if (n.name === t) return n } } }), ze.prototype = Object.assign(Object.create(A.prototype), { constructor: ze, isBone: !0 }), Ue.prototype = Object.create(j.prototype), Ue.prototype.constructor = Ue, Ue.prototype.isLineBasicMaterial = !0, Ue.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.color.copy(t.color), this.linewidth = t.linewidth, this.linecap = t.linecap, this.linejoin = t.linejoin, this }, Fe.prototype = Object.assign(Object.create(A.prototype), { constructor: Fe, isLine: !0, computeLineDistances: function () { var t = new r, e = new r; return function () { var i = this.geometry; if (i.isBufferGeometry) if (null === i.index) { for (var n = i.attributes.position, r = [0], o = 1, a = n.count; o < a; o++)t.fromBufferAttribute(n, o - 1), e.fromBufferAttribute(n, o), r[o] = r[o - 1], r[o] += t.distanceTo(e); i.addAttribute("lineDistance", new N(r, 1)) } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (i.isGeometry) for (n = i.vertices, (r = i.lineDistances)[0] = 0, o = 1, a = n.length; o < a; o++)r[o] = r[o - 1], r[o] += n[o - 1].distanceTo(n[o]); return this } }(), raycast: function () { var t = new g, e = new q, i = new p; return function (n, o) { var a = n.linePrecision, s = this.geometry, c = this.matrixWorld; if (null === s.boundingSphere && s.computeBoundingSphere(), i.copy(s.boundingSphere), i.applyMatrix4(c), i.radius += a, !1 !== n.ray.intersectsSphere(i)) { t.getInverse(c), e.copy(n.ray).applyMatrix4(t), a /= (this.scale.x + this.scale.y + this.scale.z) / 3, a *= a; var h = new r, l = new r; c = new r; var u = new r, d = this && this.isLineSegments ? 2 : 1; if (s.isBufferGeometry) { var p = s.index, f = s.attributes.position.array; if (null !== p) { s = 0; for (var m = (p = p.array).length - 1; s < m; s += d) { var g = p[s + 1]; h.fromArray(f, 3 * p[s]), l.fromArray(f, 3 * g), (g = e.distanceSqToSegment(h, l, u, c)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({ distance: g, point: c.clone().applyMatrix4(this.matrixWorld), index: s, face: null, faceIndex: null, object: this })) } } else for (s = 0, m = f.length / 3 - 1; s < m; s += d)h.fromArray(f, 3 * s), l.fromArray(f, 3 * s + 3), (g = e.distanceSqToSegment(h, l, u, c)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({ distance: g, point: c.clone().applyMatrix4(this.matrixWorld), index: s, face: null, faceIndex: null, object: this })) } else if (s.isGeometry) for (l = (h = s.vertices).length, s = 0; s < l - 1; s += d)(g = e.distanceSqToSegment(h[s], h[s + 1], u, c)) > a || (u.applyMatrix4(this.matrixWorld), (g = n.ray.origin.distanceTo(u)) < n.near || g > n.far || o.push({ distance: g, point: c.clone().applyMatrix4(this.matrixWorld), index: s, face: null, faceIndex: null, object: this })) } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), Ge.prototype = Object.assign(Object.create(Fe.prototype), { constructor: Ge, isLineSegments: !0, computeLineDistances: function () { var t = new r, e = new r; return function () { var i = this.geometry; if (i.isBufferGeometry) if (null === i.index) { for (var n = i.attributes.position, r = [], o = 0, a = n.count; o < a; o += 2)t.fromBufferAttribute(n, o), e.fromBufferAttribute(n, o + 1), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e); i.addAttribute("lineDistance", new N(r, 1)) } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."); else if (i.isGeometry) for (n = i.vertices, r = i.lineDistances, o = 0, a = n.length; o < a; o += 2)t.copy(n[o]), e.copy(n[o + 1]), r[o] = 0 === o ? 0 : r[o - 1], r[o + 1] = r[o] + t.distanceTo(e); return this } }() }), He.prototype = Object.assign(Object.create(Fe.prototype), { constructor: He, isLineLoop: !0 }), ke.prototype = Object.create(j.prototype), ke.prototype.constructor = ke, ke.prototype.isPointsMaterial = !0, ke.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.size = t.size, this.sizeAttenuation = t.sizeAttenuation, this.morphTargets = t.morphTargets, this }, Ve.prototype = Object.assign(Object.create(A.prototype), { constructor: Ve, isPoints: !0, raycast: function () { var t = new g, e = new q, i = new p; return function (n, o) { function a(t, i) { var r = e.distanceSqToPoint(t); r < u && (e.closestPointToPoint(t, d), d.applyMatrix4(h), (t = n.ray.origin.distanceTo(d)) < n.near || t > n.far || o.push({ distance: t, distanceToRay: Math.sqrt(r), point: d.clone(), index: i, face: null, object: s })) } var s = this, c = this.geometry, h = this.matrixWorld, l = n.params.Points.threshold; if (null === c.boundingSphere && c.computeBoundingSphere(), i.copy(c.boundingSphere), i.applyMatrix4(h), i.radius += l, !1 !== n.ray.intersectsSphere(i)) { t.getInverse(h), e.copy(n.ray).applyMatrix4(t); var u = (l /= (this.scale.x + this.scale.y + this.scale.z) / 3) * l; l = new r; var d = new r; if (c.isBufferGeometry) { var p = c.index; if (c = c.attributes.position.array, null !== p) { var f = p.array; p = 0; for (var m = f.length; p < m; p++) { var g = f[p]; l.fromArray(c, 3 * g), a(l, g) } } else for (p = 0, f = c.length / 3; p < f; p++)l.fromArray(c, 3 * p), a(l, p) } else for (p = 0, f = (l = c.vertices).length; p < f; p++)a(l[p], p) } } }(), clone: function () { return new this.constructor(this.geometry, this.material).copy(this) } }), je.prototype = Object.assign(Object.create(a.prototype), { constructor: je, isVideoTexture: !0, update: function () { var t = this.image; t.readyState >= t.HAVE_CURRENT_DATA && (this.needsUpdate = !0) } }), We.prototype = Object.create(a.prototype), We.prototype.constructor = We, We.prototype.isCompressedTexture = !0, qe.prototype = Object.create(a.prototype), qe.prototype.constructor = qe, qe.prototype.isCanvasTexture = !0, Xe.prototype = Object.create(a.prototype), Xe.prototype.constructor = Xe, Xe.prototype.isDepthTexture = !0, Ye.prototype = Object.create(F.prototype), Ye.prototype.constructor = Ye, Ze.prototype = Object.create(T.prototype), Ze.prototype.constructor = Ze, Je.prototype = Object.create(F.prototype), Je.prototype.constructor = Je, Qe.prototype = Object.create(T.prototype), Qe.prototype.constructor = Qe, Ke.prototype = Object.create(F.prototype), Ke.prototype.constructor = Ke, $e.prototype = Object.create(T.prototype), $e.prototype.constructor = $e, ti.prototype = Object.create(Ke.prototype), ti.prototype.constructor = ti, ei.prototype = Object.create(T.prototype), ei.prototype.constructor = ei, ii.prototype = Object.create(Ke.prototype), ii.prototype.constructor = ii, ni.prototype = Object.create(T.prototype), ni.prototype.constructor = ni, ri.prototype = Object.create(Ke.prototype), ri.prototype.constructor = ri, oi.prototype = Object.create(T.prototype), oi.prototype.constructor = oi, ai.prototype = Object.create(Ke.prototype), ai.prototype.constructor = ai, si.prototype = Object.create(T.prototype), si.prototype.constructor = si, ci.prototype = Object.create(F.prototype), ci.prototype.constructor = ci, ci.prototype.toJSON = function () { var t = F.prototype.toJSON.call(this); return t.path = this.parameters.path.toJSON(), t }, hi.prototype = Object.create(T.prototype), hi.prototype.constructor = hi, li.prototype = Object.create(F.prototype), li.prototype.constructor = li, ui.prototype = Object.create(T.prototype), ui.prototype.constructor = ui, di.prototype = Object.create(F.prototype), di.prototype.constructor = di; var ko = function (t, e, i) { i = i || 2; var n, r = e && e.length, o = r ? e[0] * i : t.length, a = pi(t, 0, o, i, !0), s = []; if (!a) return s; if (r) { var c, h = i; r = []; var l = 0; for (c = e.length; l < c; l++) { var u = e[l] * h; (u = pi(t, u, l < c - 1 ? e[l + 1] * h : t.length, h, !1)) === u.next && (u.steiner = !0), r.push(xi(u)) } for (r.sort(gi), l = 0; l < r.length; l++)(h = vi(e = r[l], h = a)) && fi(e = Ai(h, e), e.next), a = fi(a, a.next) } if (t.length > 80 * i) { var d = n = t[0], p = r = t[1]; for (h = i; h < o; h += i)(l = t[h]) < d && (d = l), (e = t[h + 1]) < p && (p = e), l > n && (n = l), e > r && (r = e); n = 0 !== (n = Math.max(n - d, r - p)) ? 1 / n : 0 } return mi(a, s, i, d, p, n), s }, Vo = { area: function (t) { for (var e = t.length, i = 0, n = e - 1, r = 0; r < e; n = r++)i += t[n].x * t[r].y - t[r].x * t[n].y; return .5 * i }, isClockWise: function (t) { return 0 > Vo.area(t) }, triangulateShape: function (t, e) { var i = [], n = [], r = []; Ci(t), Ri(i, t); var o = t.length; for (e.forEach(Ci), t = 0; t < e.length; t++)n.push(o), o += e[t].length, Ri(i, e[t]); for (e = ko(i, n), t = 0; t < e.length; t += 3)r.push(e.slice(t, t + 3)); return r } }; Pi.prototype = Object.create(T.prototype), Pi.prototype.constructor = Pi, Pi.prototype.toJSON = function () { var t = T.prototype.toJSON.call(this); return Oi(this.parameters.shapes, this.parameters.options, t) }, Ii.prototype = Object.create(F.prototype), Ii.prototype.constructor = Ii, Ii.prototype.toJSON = function () { var t = F.prototype.toJSON.call(this); return Oi(this.parameters.shapes, this.parameters.options, t) }; var jo = { generateTopUV: function (t, e, n, r, o) { t = e[3 * r], r = e[3 * r + 1]; var a = e[3 * o]; return o = e[3 * o + 1], [new i(e[3 * n], e[3 * n + 1]), new i(t, r), new i(a, o)] }, generateSideWallUV: function (t, e, n, r, o, a) { t = e[3 * n]; var s = e[3 * n + 1]; n = e[3 * n + 2]; var c = e[3 * r], h = e[3 * r + 1]; r = e[3 * r + 2]; var l = e[3 * o], u = e[3 * o + 1]; o = e[3 * o + 2]; var d = e[3 * a], p = e[3 * a + 1]; return e = e[3 * a + 2], .01 > Math.abs(s - h) ? [new i(t, 1 - n), new i(c, 1 - r), new i(l, 1 - o), new i(d, 1 - e)] : [new i(s, 1 - n), new i(h, 1 - r), new i(u, 1 - o), new i(p, 1 - e)] } }; Di.prototype = Object.create(T.prototype), Di.prototype.constructor = Di, Ni.prototype = Object.create(Ii.prototype), Ni.prototype.constructor = Ni, Bi.prototype = Object.create(T.prototype), Bi.prototype.constructor = Bi, zi.prototype = Object.create(F.prototype), zi.prototype.constructor = zi, Ui.prototype = Object.create(T.prototype), Ui.prototype.constructor = Ui, Fi.prototype = Object.create(F.prototype), Fi.prototype.constructor = Fi, Gi.prototype = Object.create(T.prototype), Gi.prototype.constructor = Gi, Hi.prototype = Object.create(F.prototype), Hi.prototype.constructor = Hi, ki.prototype = Object.create(T.prototype), ki.prototype.constructor = ki, ki.prototype.toJSON = function () { var t = T.prototype.toJSON.call(this); return ji(this.parameters.shapes, t) }, Vi.prototype = Object.create(F.prototype), Vi.prototype.constructor = Vi, Vi.prototype.toJSON = function () { var t = F.prototype.toJSON.call(this); return ji(this.parameters.shapes, t) }, Wi.prototype = Object.create(F.prototype), Wi.prototype.constructor = Wi, qi.prototype = Object.create(T.prototype), qi.prototype.constructor = qi, Xi.prototype = Object.create(F.prototype), Xi.prototype.constructor = Xi, Yi.prototype = Object.create(qi.prototype), Yi.prototype.constructor = Yi, Zi.prototype = Object.create(Xi.prototype), Zi.prototype.constructor = Zi, Ji.prototype = Object.create(T.prototype), Ji.prototype.constructor = Ji, Qi.prototype = Object.create(F.prototype), Qi.prototype.constructor = Qi; var Wo = Object.freeze({ WireframeGeometry: Ye, ParametricGeometry: Ze, ParametricBufferGeometry: Je, TetrahedronGeometry: $e, TetrahedronBufferGeometry: ti, OctahedronGeometry: ei, OctahedronBufferGeometry: ii, IcosahedronGeometry: ni, IcosahedronBufferGeometry: ri, DodecahedronGeometry: oi, DodecahedronBufferGeometry: ai, PolyhedronGeometry: Qe, PolyhedronBufferGeometry: Ke, TubeGeometry: si, TubeBufferGeometry: ci, TorusKnotGeometry: hi, TorusKnotBufferGeometry: li, TorusGeometry: ui, TorusBufferGeometry: di, TextGeometry: Di, TextBufferGeometry: Ni, SphereGeometry: Bi, SphereBufferGeometry: zi, RingGeometry: Ui, RingBufferGeometry: Fi, PlaneGeometry: k, PlaneBufferGeometry: V, LatheGeometry: Gi, LatheBufferGeometry: Hi, ShapeGeometry: ki, ShapeBufferGeometry: Vi, ExtrudeGeometry: Pi, ExtrudeBufferGeometry: Ii, EdgesGeometry: Wi, ConeGeometry: Yi, ConeBufferGeometry: Zi, CylinderGeometry: qi, CylinderBufferGeometry: Xi, CircleGeometry: Ji, CircleBufferGeometry: Qi, BoxGeometry: G, BoxBufferGeometry: H }); Ki.prototype = Object.create(j.prototype), Ki.prototype.constructor = Ki, Ki.prototype.isShadowMaterial = !0, Ki.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.color.copy(t.color), this }, $i.prototype = Object.create(W.prototype), $i.prototype.constructor = $i, $i.prototype.isRawShaderMaterial = !0, tn.prototype = Object.create(j.prototype), tn.prototype.constructor = tn, tn.prototype.isMeshStandardMaterial = !0, tn.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.defines = { STANDARD: "" }, this.color.copy(t.color), this.roughness = t.roughness, this.metalness = t.metalness, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.roughnessMap = t.roughnessMap, this.metalnessMap = t.metalnessMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.envMapIntensity = t.envMapIntensity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, en.prototype = Object.create(tn.prototype), en.prototype.constructor = en, en.prototype.isMeshPhysicalMaterial = !0, en.prototype.copy = function (t) { return tn.prototype.copy.call(this, t), this.defines = { PHYSICAL: "" }, this.reflectivity = t.reflectivity, this.clearCoat = t.clearCoat, this.clearCoatRoughness = t.clearCoatRoughness, this }, nn.prototype = Object.create(j.prototype), nn.prototype.constructor = nn, nn.prototype.isMeshPhongMaterial = !0, nn.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.color.copy(t.color), this.specular.copy(t.specular), this.shininess = t.shininess, this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, rn.prototype = Object.create(nn.prototype), rn.prototype.constructor = rn, rn.prototype.isMeshToonMaterial = !0, rn.prototype.copy = function (t) { return nn.prototype.copy.call(this, t), this.gradientMap = t.gradientMap, this }, on.prototype = Object.create(j.prototype), on.prototype.constructor = on, on.prototype.isMeshNormalMaterial = !0, on.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, an.prototype = Object.create(j.prototype), an.prototype.constructor = an, an.prototype.isMeshLambertMaterial = !0, an.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.color.copy(t.color), this.map = t.map, this.lightMap = t.lightMap, this.lightMapIntensity = t.lightMapIntensity, this.aoMap = t.aoMap, this.aoMapIntensity = t.aoMapIntensity, this.emissive.copy(t.emissive), this.emissiveMap = t.emissiveMap, this.emissiveIntensity = t.emissiveIntensity, this.specularMap = t.specularMap, this.alphaMap = t.alphaMap, this.envMap = t.envMap, this.combine = t.combine, this.reflectivity = t.reflectivity, this.refractionRatio = t.refractionRatio, this.wireframe = t.wireframe, this.wireframeLinewidth = t.wireframeLinewidth, this.wireframeLinecap = t.wireframeLinecap, this.wireframeLinejoin = t.wireframeLinejoin, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, sn.prototype = Object.create(j.prototype), sn.prototype.constructor = sn, sn.prototype.isMeshMatcapMaterial = !0, sn.prototype.copy = function (t) { return j.prototype.copy.call(this, t), this.defines = { MATCAP: "" }, this.color.copy(t.color), this.matcap = t.matcap, this.map = t.map, this.bumpMap = t.bumpMap, this.bumpScale = t.bumpScale, this.normalMap = t.normalMap, this.normalMapType = t.normalMapType, this.normalScale.copy(t.normalScale), this.displacementMap = t.displacementMap, this.displacementScale = t.displacementScale, this.displacementBias = t.displacementBias, this.alphaMap = t.alphaMap, this.skinning = t.skinning, this.morphTargets = t.morphTargets, this.morphNormals = t.morphNormals, this }, cn.prototype = Object.create(Ue.prototype), cn.prototype.constructor = cn, cn.prototype.isLineDashedMaterial = !0, cn.prototype.copy = function (t) { return Ue.prototype.copy.call(this, t), this.scale = t.scale, this.dashSize = t.dashSize, this.gapSize = t.gapSize, this }; var qo = Object.freeze({ ShadowMaterial: Ki, SpriteMaterial: Ie, RawShaderMaterial: $i, ShaderMaterial: W, PointsMaterial: ke, MeshPhysicalMaterial: en, MeshStandardMaterial: tn, MeshPhongMaterial: nn, MeshToonMaterial: rn, MeshNormalMaterial: on, MeshLambertMaterial: an, MeshDepthMaterial: pe, MeshDistanceMaterial: fe, MeshBasicMaterial: Y, MeshMatcapMaterial: sn, LineDashedMaterial: cn, LineBasicMaterial: Ue, Material: j }), Xo = { arraySlice: function (t, e, i) { return Xo.isTypedArray(t) ? new t.constructor(t.subarray(e, void 0 !== i ? i : t.length)) : t.slice(e, i) }, convertArray: function (t, e, i) { return !t || !i && t.constructor === e ? t : "number" == typeof e.BYTES_PER_ELEMENT ? new e(t) : Array.prototype.slice.call(t) }, isTypedArray: function (t) { return ArrayBuffer.isView(t) && !(t instanceof DataView) }, getKeyframeOrder: function (t) { for (var e = t.length, i = Array(e), n = 0; n !== e; ++n)i[n] = n; return i.sort((function (e, i) { return t[e] - t[i] })), i }, sortedArray: function (t, e, i) { for (var n = t.length, r = new t.constructor(n), o = 0, a = 0; a !== n; ++o)for (var s = i[o] * e, c = 0; c !== e; ++c)r[a++] = t[s + c]; return r }, flattenJSON: function (t, e, i, n) { for (var r = 1, o = t[0]; void 0 !== o && void 0 === o[n];)o = t[r++]; if (void 0 !== o) { var a = o[n]; if (void 0 !== a) if (Array.isArray(a)) do { void 0 !== (a = o[n]) && (e.push(o.time), i.push.apply(i, a)), o = t[r++] } while (void 0 !== o); else if (void 0 !== a.toArray) do { void 0 !== (a = o[n]) && (e.push(o.time), a.toArray(i, i.length)), o = t[r++] } while (void 0 !== o); else do { void 0 !== (a = o[n]) && (e.push(o.time), i.push(a)), o = t[r++] } while (void 0 !== o) } } }; Object.assign(hn.prototype, { evaluate: function (t) { var e = this.parameterPositions, i = this._cachedIndex, n = e[i], r = e[i - 1]; t: { e: { i: { n: if (!(t < n)) { for (var o = i + 2; ;) { if (void 0 === n) { if (t < r) break n; return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, t, r) } if (i === o) break; if (r = n, t < (n = e[++i])) break e } n = e.length; break i } if (t >= r) break t; for (t < (o = e[1]) && (i = 2, r = o), o = i - 2; ;) { if (void 0 === r) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (i === o) break; if (n = r, t >= (r = e[--i - 1])) break e } n = i, i = 0 } for (; i < n;)t < e[r = i + n >>> 1] ? n = r : i = r + 1; if (n = e[i], void 0 === (r = e[i - 1])) return this._cachedIndex = 0, this.beforeStart_(0, t, n); if (void 0 === n) return this._cachedIndex = i = e.length, this.afterEnd_(i - 1, r, t) } this._cachedIndex = i, this.intervalChanged_(i, r, n) } return this.interpolate_(i, r, t, n) }, settings: null, DefaultSettings_: {}, getSettings_: function () { return this.settings || this.DefaultSettings_ }, copySampleValue_: function (t) { var e = this.resultBuffer, i = this.sampleValues, n = this.valueSize; t *= n; for (var r = 0; r !== n; ++r)e[r] = i[t + r]; return e }, interpolate_: function () { throw Error("call to abstract method") }, intervalChanged_: function () { } }), Object.assign(hn.prototype, { beforeStart_: hn.prototype.copySampleValue_, afterEnd_: hn.prototype.copySampleValue_ }), ln.prototype = Object.assign(Object.create(hn.prototype), { constructor: ln, DefaultSettings_: { endingStart: 2400, endingEnd: 2400 }, intervalChanged_: function (t, e, i) { var n = this.parameterPositions, r = t - 2, o = t + 1, a = n[r], s = n[o]; if (void 0 === a) switch (this.getSettings_().endingStart) { case 2401: r = t, a = 2 * e - i; break; case 2402: a = e + n[r = n.length - 2] - n[r + 1]; break; default: r = t, a = i }if (void 0 === s) switch (this.getSettings_().endingEnd) { case 2401: o = t, s = 2 * i - e; break; case 2402: o = 1, s = i + n[1] - n[0]; break; default: o = t - 1, s = e }t = .5 * (i - e), n = this.valueSize, this._weightPrev = t / (e - a), this._weightNext = t / (s - i), this._offsetPrev = r * n, this._offsetNext = o * n }, interpolate_: function (t, e, i, n) { var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = (t *= a) - a, c = this._offsetPrev, h = this._offsetNext, l = this._weightPrev, u = this._weightNext, d = (i - e) / (n - e); for (e = -l * (n = (i = d * d) * d) + 2 * l * i - l * d, l = (1 + l) * n + (-1.5 - 2 * l) * i + (-.5 + l) * d + 1, d = (-1 - u) * n + (1.5 + u) * i + .5 * d, u = u * n - u * i, i = 0; i !== a; ++i)r[i] = e * o[c + i] + l * o[s + i] + d * o[t + i] + u * o[h + i]; return r } }), un.prototype = Object.assign(Object.create(hn.prototype), { constructor: un, interpolate_: function (t, e, i, n) { var r = this.resultBuffer, o = this.sampleValues, a = this.valueSize, s = (t *= a) - a; for (i = 1 - (e = (i - e) / (n - e)), n = 0; n !== a; ++n)r[n] = o[s + n] * i + o[t + n] * e; return r } }), dn.prototype = Object.assign(Object.create(hn.prototype), { constructor: dn, interpolate_: function (t) { return this.copySampleValue_(t - 1) } }), Object.assign(pn, { toJSON: function (t) { var e = t.constructor; if (void 0 !== e.toJSON) e = e.toJSON(t); else { e = { name: t.name, times: Xo.convertArray(t.times, Array), values: Xo.convertArray(t.values, Array) }; var i = t.getInterpolation(); i !== t.DefaultInterpolation && (e.interpolation = i) } return e.type = t.ValueTypeName, e } }), Object.assign(pn.prototype, { constructor: pn, TimeBufferType: Float32Array, ValueBufferType: Float32Array, DefaultInterpolation: 2301, InterpolantFactoryMethodDiscrete: function (t) { return new dn(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodLinear: function (t) { return new un(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: function (t) { return new ln(this.times, this.values, this.getValueSize(), t) }, setInterpolation: function (t) { switch (t) { case 2300: var e = this.InterpolantFactoryMethodDiscrete; break; case 2301: e = this.InterpolantFactoryMethodLinear; break; case 2302: e = this.InterpolantFactoryMethodSmooth }if (void 0 === e) { if (e = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name, void 0 === this.createInterpolant) { if (t === this.DefaultInterpolation) throw Error(e); this.setInterpolation(this.DefaultInterpolation) } return console.warn("THREE.KeyframeTrack:", e), this } return this.createInterpolant = e, this }, getInterpolation: function () { switch (this.createInterpolant) { case this.InterpolantFactoryMethodDiscrete: return 2300; case this.InterpolantFactoryMethodLinear: return 2301; case this.InterpolantFactoryMethodSmooth: return 2302 } }, getValueSize: function () { return this.values.length / this.times.length }, shift: function (t) { if (0 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i)e[i] += t; return this }, scale: function (t) { if (1 !== t) for (var e = this.times, i = 0, n = e.length; i !== n; ++i)e[i] *= t; return this }, trim: function (t, e) { for (var i = this.times, n = i.length, r = 0, o = n - 1; r !== n && i[r] < t;)++r; for (; -1 !== o && i[o] > e;)--o; return ++o, 0 === r && o === n || (r >= o && (r = (o = Math.max(o, 1)) - 1), t = this.getValueSize(), this.times = Xo.arraySlice(i, r, o), this.values = Xo.arraySlice(this.values, r * t, o * t)), this }, validate: function () { var t = !0, e = this.getValueSize(); 0 != e - Math.floor(e) && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), t = !1); var i = this.times; e = this.values; var n = i.length; 0 === n && (console.error("THREE.KeyframeTrack: Track is empty.", this), t = !1); for (var r = null, o = 0; o !== n; o++) { var a = i[o]; if ("number" == typeof a && isNaN(a)) { console.error("THREE.KeyframeTrack: Time is not a valid number.", this, o, a), t = !1; break } if (null !== r && r > a) { console.error("THREE.KeyframeTrack: Out of order keys.", this, o, a, r), t = !1; break } r = a } if (void 0 !== e && Xo.isTypedArray(e)) for (o = 0, i = e.length; o !== i; ++o)if (n = e[o], isNaN(n)) { console.error("THREE.KeyframeTrack: Value is not a valid number.", this, o, n), t = !1; break } return t }, optimize: function () { for (var t = this.times, e = this.values, i = this.getValueSize(), n = 2302 === this.getInterpolation(), r = 1, o = t.length - 1, a = 1; a < o; ++a) { var s = !1, c = t[a]; if (c !== t[a + 1] && (1 !== a || c !== c[0])) if (n) s = !0; else { var h = a * i, l = h - i, u = h + i; for (c = 0; c !== i; ++c) { var d = e[h + c]; if (d !== e[l + c] || d !== e[u + c]) { s = !0; break } } } if (s) { if (a !== r) for (t[r] = t[a], s = a * i, h = r * i, c = 0; c !== i; ++c)e[h + c] = e[s + c]; ++r } } if (0 < o) { for (t[r] = t[o], s = o * i, h = r * i, c = 0; c !== i; ++c)e[h + c] = e[s + c]; ++r } return r !== t.length && (this.times = Xo.arraySlice(t, 0, r), this.values = Xo.arraySlice(e, 0, r * i)), this }, clone: function () { var t = Xo.arraySlice(this.times, 0), e = Xo.arraySlice(this.values, 0); return (t = new this.constructor(this.name, t, e)).createInterpolant = this.createInterpolant, t } }), fn.prototype = Object.assign(Object.create(pn.prototype), { constructor: fn, ValueTypeName: "bool", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), mn.prototype = Object.assign(Object.create(pn.prototype), { constructor: mn, ValueTypeName: "color" }), gn.prototype = Object.assign(Object.create(pn.prototype), { constructor: gn, ValueTypeName: "number" }), vn.prototype = Object.assign(Object.create(hn.prototype), { constructor: vn, interpolate_: function (t, e, i, r) { var o = this.resultBuffer, a = this.sampleValues, s = this.valueSize; for (e = (i - e) / (r - e), i = (t *= s) + s; t !== i; t += 4)n.slerpFlat(o, 0, a, t - s, a, t, e); return o } }), yn.prototype = Object.assign(Object.create(pn.prototype), { constructor: yn, ValueTypeName: "quaternion", DefaultInterpolation: 2301, InterpolantFactoryMethodLinear: function (t) { return new vn(this.times, this.values, this.getValueSize(), t) }, InterpolantFactoryMethodSmooth: void 0 }), xn.prototype = Object.assign(Object.create(pn.prototype), { constructor: xn, ValueTypeName: "string", ValueBufferType: Array, DefaultInterpolation: 2300, InterpolantFactoryMethodLinear: void 0, InterpolantFactoryMethodSmooth: void 0 }), bn.prototype = Object.assign(Object.create(pn.prototype), { constructor: bn, ValueTypeName: "vector" }), Object.assign(wn, { parse: function (t) { for (var e = [], i = t.tracks, n = 1 / (t.fps || 1), r = 0, o = i.length; r !== o; ++r)e.push(Mn(i[r]).scale(n)); return new wn(t.name, t.duration, e) }, toJSON: function (t) { var e = [], i = t.tracks; t = { name: t.name, duration: t.duration, tracks: e, uuid: t.uuid }; for (var n = 0, r = i.length; n !== r; ++n)e.push(pn.toJSON(i[n])); return t }, CreateFromMorphTargetSequence: function (t, e, i, n) { for (var r = e.length, o = [], a = 0; a < r; a++) { var s = [], c = []; s.push((a + r - 1) % r, a, (a + 1) % r), c.push(0, 1, 0); var h = Xo.getKeyframeOrder(s); s = Xo.sortedArray(s, 1, h), c = Xo.sortedArray(c, 1, h), n || 0 !== s[0] || (s.push(r), c.push(c[0])), o.push(new gn(".morphTargetInfluences[" + e[a].name + "]", s, c).scale(1 / i)) } return new wn(t, -1, o) }, findByName: function (t, e) { var i = t; for (Array.isArray(t) || (i = t.geometry && t.geometry.animations || t.animations), t = 0; t < i.length; t++)if (i[t].name === e) return i[t]; return null }, CreateClipsFromMorphTargetSequences: function (t, e, i) { for (var n = {}, r = /^([\w-]*?)([\d]+)$/, o = 0, a = t.length; o < a; o++) { var s = t[o], c = s.name.match(r); if (c && 1 < c.length) { var h = c[1]; (c = n[h]) || (n[h] = c = []), c.push(s) } } for (h in t = [], n) t.push(wn.CreateFromMorphTargetSequence(h, n[h], e, i)); return t }, parseAnimation: function (t, e) { if (!t) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null; var i = function (t, e, i, n, r) { if (0 !== i.length) { var o = [], a = []; Xo.flattenJSON(i, o, a, n), 0 !== o.length && r.push(new t(e, o, a)) } }, n = [], r = t.name || "default", o = t.length || -1, a = t.fps || 30; t = t.hierarchy || []; for (var s = 0; s < t.length; s++) { var c = t[s].keys; if (c && 0 !== c.length) if (c[0].morphTargets) { o = {}; for (var h = 0; h < c.length; h++)if (c[h].morphTargets) for (var l = 0; l < c[h].morphTargets.length; l++)o[c[h].morphTargets[l]] = -1; for (var u in o) { var d = [], p = []; for (l = 0; l !== c[h].morphTargets.length; ++l) { var f = c[h]; d.push(f.time), p.push(f.morphTarget === u ? 1 : 0) } n.push(new gn(".morphTargetInfluence[" + u + "]", d, p)) } o = o.length * (a || 1) } else i(bn, (h = ".bones[" + e[s].name + "]") + ".position", c, "pos", n), i(yn, h + ".quaternion", c, "rot", n), i(bn, h + ".scale", c, "scl", n) } return 0 === n.length ? null : new wn(r, o, n) } }), Object.assign(wn.prototype, { resetDuration: function () { for (var t = 0, e = 0, i = this.tracks.length; e !== i; ++e) { var n = this.tracks[e]; t = Math.max(t, n.times[n.times.length - 1]) } return this.duration = t, this }, trim: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].trim(0, this.duration); return this }, validate: function () { for (var t = !0, e = 0; e < this.tracks.length; e++)t = t && this.tracks[e].validate(); return t }, optimize: function () { for (var t = 0; t < this.tracks.length; t++)this.tracks[t].optimize(); return this }, clone: function () { for (var t = [], e = 0; e < this.tracks.length; e++)t.push(this.tracks[e].clone()); return new wn(this.name, this.duration, t) } }); var Yo = { enabled: !1, files: {}, add: function (t, e) { !1 !== this.enabled && (this.files[t] = e) }, get: function (t) { if (!1 !== this.enabled) return this.files[t] }, remove: function (t) { delete this.files[t] }, clear: function () { this.files = {} } }, Zo = new _n, Jo = {}; Object.assign(En.prototype, { load: function (t, e, i, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var r = this, o = Yo.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () { e && e(o), r.manager.itemEnd(t) }), 0), o; if (void 0 === Jo[t]) { var a = t.match(/^data:(.*?)(;base64)?,(.*)$/); if (a) { i = a[1]; var s = !!a[2]; a = a[3], a = decodeURIComponent(a), s && (a = atob(a)); try { var c = (this.responseType || "").toLowerCase(); switch (c) { case "arraybuffer": case "blob": var h = new Uint8Array(a.length); for (s = 0; s < a.length; s++)h[s] = a.charCodeAt(s); var l = "blob" === c ? new Blob([h.buffer], { type: i }) : h.buffer; break; case "document": l = (new DOMParser).parseFromString(a, i); break; case "json": l = JSON.parse(a); break; default: l = a }setTimeout((function () { e && e(l), r.manager.itemEnd(t) }), 0) } catch (e) { setTimeout((function () { n && n(e), r.manager.itemError(t), r.manager.itemEnd(t) }), 0) } } else { Jo[t] = [], Jo[t].push({ onLoad: e, onProgress: i, onError: n }); var u = new XMLHttpRequest; for (s in u.open("GET", t, !0), u.addEventListener("load", (function (e) { var i = this.response; Yo.add(t, i); var n = Jo[t]; if (delete Jo[t], 200 === this.status || 0 === this.status) { 0 === this.status && console.warn("THREE.FileLoader: HTTP Status 0 received."); for (var o = 0, a = n.length; o < a; o++) { var s = n[o]; s.onLoad && s.onLoad(i) } } else { for (o = 0, a = n.length; o < a; o++)(s = n[o]).onError && s.onError(e); r.manager.itemError(t) } r.manager.itemEnd(t) }), !1), u.addEventListener("progress", (function (e) { for (var i = Jo[t], n = 0, r = i.length; n < r; n++) { var o = i[n]; o.onProgress && o.onProgress(e) } }), !1), u.addEventListener("error", (function (e) { var i = Jo[t]; delete Jo[t]; for (var n = 0, o = i.length; n < o; n++) { var a = i[n]; a.onError && a.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }), !1), u.addEventListener("abort", (function (e) { var i = Jo[t]; delete Jo[t]; for (var n = 0, o = i.length; n < o; n++) { var a = i[n]; a.onError && a.onError(e) } r.manager.itemError(t), r.manager.itemEnd(t) }), !1), void 0 !== this.responseType && (u.responseType = this.responseType), void 0 !== this.withCredentials && (u.withCredentials = this.withCredentials), u.overrideMimeType && u.overrideMimeType(void 0 !== this.mimeType ? this.mimeType : "text/plain"), this.requestHeader) u.setRequestHeader(s, this.requestHeader[s]); u.send(null) } return r.manager.itemStart(t), u } Jo[t].push({ onLoad: e, onProgress: i, onError: n }) }, setPath: function (t) { return this.path = t, this }, setResponseType: function (t) { return this.responseType = t, this }, setWithCredentials: function (t) { return this.withCredentials = t, this }, setMimeType: function (t) { return this.mimeType = t, this }, setRequestHeader: function (t) { return this.requestHeader = t, this } }), Object.assign(An.prototype, { load: function (t, e, i, n) { var r = this, o = new En(r.manager); o.setPath(r.path), o.load(t, (function (t) { e(r.parse(JSON.parse(t))) }), i, n) }, parse: function (t) { for (var e = [], i = 0; i < t.length; i++) { var n = wn.parse(t[i]); e.push(n) } return e }, setPath: function (t) { return this.path = t, this } }), Object.assign(Tn.prototype, { load: function (t, e, i, n) { function r(r) { c.load(t[r], (function (t) { t = o._parser(t, !0), a[r] = { width: t.width, height: t.height, format: t.format, mipmaps: t.mipmaps }, 6 === (h += 1) && (1 === t.mipmapCount && (s.minFilter = 1006), s.format = t.format, s.needsUpdate = !0, e && e(s)) }), i, n) } var o = this, a = [], s = new We; s.image = a; var c = new En(this.manager); if (c.setPath(this.path), c.setResponseType("arraybuffer"), Array.isArray(t)) for (var h = 0, l = 0, u = t.length; l < u; ++l)r(l); else c.load(t, (function (t) { if ((t = o._parser(t, !0)).isCubemap) for (var i = t.mipmaps.length / t.mipmapCount, n = 0; n < i; n++) { a[n] = { mipmaps: [] }; for (var r = 0; r < t.mipmapCount; r++)a[n].mipmaps.push(t.mipmaps[n * t.mipmapCount + r]), a[n].format = t.format, a[n].width = t.width, a[n].height = t.height } else s.image.width = t.width, s.image.height = t.height, s.mipmaps = t.mipmaps; 1 === t.mipmapCount && (s.minFilter = 1006), s.format = t.format, s.needsUpdate = !0, e && e(s) }), i, n); return s }, setPath: function (t) { return this.path = t, this } }), Object.assign(Sn.prototype, { load: function (t, e, i, n) { var r = this, o = new u, a = new En(this.manager); return a.setResponseType("arraybuffer"), a.setPath(this.path), a.load(t, (function (t) { (t = r._parser(t)) && (void 0 !== t.image ? o.image = t.image : void 0 !== t.data && (o.image.width = t.width, o.image.height = t.height, o.image.data = t.data), o.wrapS = void 0 !== t.wrapS ? t.wrapS : 1001, o.wrapT = void 0 !== t.wrapT ? t.wrapT : 1001, o.magFilter = void 0 !== t.magFilter ? t.magFilter : 1006, o.minFilter = void 0 !== t.minFilter ? t.minFilter : 1008, o.anisotropy = void 0 !== t.anisotropy ? t.anisotropy : 1, void 0 !== t.format && (o.format = t.format), void 0 !== t.type && (o.type = t.type), void 0 !== t.mipmaps && (o.mipmaps = t.mipmaps), 1 === t.mipmapCount && (o.minFilter = 1006), o.needsUpdate = !0, e && e(o, t)) }), i, n), o }, setPath: function (t) { return this.path = t, this } }), Object.assign(Ln.prototype, { crossOrigin: "anonymous", load: function (t, e, i, n) { function r() { c.removeEventListener("load", r, !1), c.removeEventListener("error", o, !1), Yo.add(t, this), e && e(this), a.manager.itemEnd(t) } function o(e) { c.removeEventListener("load", r, !1), c.removeEventListener("error", o, !1), n && n(e), a.manager.itemError(t), a.manager.itemEnd(t) } void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var a = this, s = Yo.get(t); if (void 0 !== s) return a.manager.itemStart(t), setTimeout((function () { e && e(s), a.manager.itemEnd(t) }), 0), s; var c = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); return c.addEventListener("load", r, !1), c.addEventListener("error", o, !1), "data:" !== t.substr(0, 5) && void 0 !== this.crossOrigin && (c.crossOrigin = this.crossOrigin), a.manager.itemStart(t), c.src = t, c }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Cn.prototype, { crossOrigin: "anonymous", load: function (t, e, i, n) { function r(i) { a.load(t[i], (function (t) { o.images[i] = t, 6 === ++s && (o.needsUpdate = !0, e && e(o)) }), void 0, n) } var o = new st, a = new Ln(this.manager); a.setCrossOrigin(this.crossOrigin), a.setPath(this.path); var s = 0; for (i = 0; i < t.length; ++i)r(i); return o }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Rn.prototype, { crossOrigin: "anonymous", load: function (t, e, i, n) { var r = new a, o = new Ln(this.manager); return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(t, (function (i) { r.image = i, i = 0 < t.search(/\.jpe?g($|\?)/i) || 0 === t.search(/^data:image\/jpeg/), r.format = i ? 1022 : 1023, r.needsUpdate = !0, void 0 !== e && e(r) }), i, n), r }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, setPath: function (t) { return this.path = t, this } }), Object.assign(Pn.prototype, { getPoint: function () { return console.warn("THREE.Curve: .getPoint() not implemented."), null }, getPointAt: function (t, e) { return t = this.getUtoTmapping(t), this.getPoint(t, e) }, getPoints: function (t) { void 0 === t && (t = 5); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return e }, getSpacedPoints: function (t) { void 0 === t && (t = 5); for (var e = [], i = 0; i <= t; i++)e.push(this.getPointAt(i / t)); return e }, getLength: function () { var t = this.getLengths(); return t[t.length - 1] }, getLengths: function (t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths && this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; var e, i = [], n = this.getPoint(0), r = 0; for (i.push(0), e = 1; e <= t; e++) { var o = this.getPoint(e / t); r += o.distanceTo(n), i.push(r), n = o } return this.cacheArcLengths = i }, updateArcLengths: function () { this.needsUpdate = !0, this.getLengths() }, getUtoTmapping: function (t, e) { var i = this.getLengths(), n = i.length; e = e || t * i[n - 1]; for (var r, o = 0, a = n - 1; o <= a;)if (0 > (r = i[t = Math.floor(o + (a - o) / 2)] - e)) o = t + 1; else { if (!(0 < r)) { a = t; break } a = t - 1 } return i[t = a] === e ? t / (n - 1) : (t + (e - (o = i[t])) / (i[t + 1] - o)) / (n - 1) }, getTangent: function (t) { var e = t - 1e-4; return 0 > e && (e = 0), 1 < (t += 1e-4) && (t = 1), e = this.getPoint(e), this.getPoint(t).clone().sub(e).normalize() }, getTangentAt: function (t) { return t = this.getUtoTmapping(t), this.getTangent(t) }, computeFrenetFrames: function (t, e) { var i, n = new r, o = [], a = [], s = [], c = new r, h = new g; for (i = 0; i <= t; i++) { var l = i / t; o[i] = this.getTangentAt(l), o[i].normalize() } a[0] = new r, s[0] = new r, i = Number.MAX_VALUE, l = Math.abs(o[0].x); var u = Math.abs(o[0].y), d = Math.abs(o[0].z); for (l <= i && (i = l, n.set(1, 0, 0)), u <= i && (i = u, n.set(0, 1, 0)), d <= i && n.set(0, 0, 1), c.crossVectors(o[0], n).normalize(), a[0].crossVectors(o[0], c), s[0].crossVectors(o[0], a[0]), i = 1; i <= t; i++)a[i] = a[i - 1].clone(), s[i] = s[i - 1].clone(), c.crossVectors(o[i - 1], o[i]), c.length() > Number.EPSILON && (c.normalize(), n = Math.acos(fo.clamp(o[i - 1].dot(o[i]), -1, 1)), a[i].applyMatrix4(h.makeRotationAxis(c, n))), s[i].crossVectors(o[i], a[i]); if (!0 === e) for (n = Math.acos(fo.clamp(a[0].dot(a[t]), -1, 1)), n /= t, 0 < o[0].dot(c.crossVectors(a[0], a[t])) && (n = -n), i = 1; i <= t; i++)a[i].applyMatrix4(h.makeRotationAxis(o[i], n * i)), s[i].crossVectors(o[i], a[i]); return { tangents: o, normals: a, binormals: s } }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this }, toJSON: function () { var t = { metadata: { version: 4.5, type: "Curve", generator: "Curve.toJSON" } }; return t.arcLengthDivisions = this.arcLengthDivisions, t.type = this.type, t }, fromJSON: function (t) { return this.arcLengthDivisions = t.arcLengthDivisions, this } }), In.prototype = Object.create(Pn.prototype), In.prototype.constructor = In, In.prototype.isEllipseCurve = !0, In.prototype.getPoint = function (t, e) { e = e || new i; for (var n = 2 * Math.PI, r = this.aEndAngle - this.aStartAngle, o = Math.abs(r) < Number.EPSILON; 0 > r;)r += n; for (; r > n;)r -= n; r < Number.EPSILON && (r = o ? 0 : n), !0 !== this.aClockwise || o || (r = r === n ? -n : r - n), n = this.aStartAngle + t * r, t = this.aX + this.xRadius * Math.cos(n); var a = this.aY + this.yRadius * Math.sin(n); return 0 !== this.aRotation && (n = Math.cos(this.aRotation), r = Math.sin(this.aRotation), t = (o = t - this.aX) * n - (a -= this.aY) * r + this.aX, a = o * r + a * n + this.aY), e.set(t, a) }, In.prototype.copy = function (t) { return Pn.prototype.copy.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, In.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); return t.aX = this.aX, t.aY = this.aY, t.xRadius = this.xRadius, t.yRadius = this.yRadius, t.aStartAngle = this.aStartAngle, t.aEndAngle = this.aEndAngle, t.aClockwise = this.aClockwise, t.aRotation = this.aRotation, t }, In.prototype.fromJSON = function (t) { return Pn.prototype.fromJSON.call(this, t), this.aX = t.aX, this.aY = t.aY, this.xRadius = t.xRadius, this.yRadius = t.yRadius, this.aStartAngle = t.aStartAngle, this.aEndAngle = t.aEndAngle, this.aClockwise = t.aClockwise, this.aRotation = t.aRotation, this }, On.prototype = Object.create(In.prototype), On.prototype.constructor = On, On.prototype.isArcCurve = !0; var Qo = new r, Ko = new Dn, $o = new Dn, ta = new Dn; Nn.prototype = Object.create(Pn.prototype), Nn.prototype.constructor = Nn, Nn.prototype.isCatmullRomCurve3 = !0, Nn.prototype.getPoint = function (t, e) { e = e || new r; var i = this.points, n = i.length; t *= n - (this.closed ? 0 : 1); var o = Math.floor(t); if (t -= o, this.closed ? o += 0 < o ? 0 : (Math.floor(Math.abs(o) / n) + 1) * n : 0 === t && o === n - 1 && (o = n - 2, t = 1), this.closed || 0 < o) var a = i[(o - 1) % n]; else Qo.subVectors(i[0], i[1]).add(i[0]), a = Qo; var s = i[o % n], c = i[(o + 1) % n]; if (this.closed || o + 2 < n ? i = i[(o + 2) % n] : (Qo.subVectors(i[n - 1], i[n - 2]).add(i[n - 1]), i = Qo), "centripetal" === this.curveType || "chordal" === this.curveType) { var h = "chordal" === this.curveType ? .5 : .25; n = Math.pow(a.distanceToSquared(s), h), 1e-4 > (o = Math.pow(s.distanceToSquared(c), h)) && (o = 1), 1e-4 > n && (n = o), 1e-4 > (h = Math.pow(c.distanceToSquared(i), h)) && (h = o), Ko.initNonuniformCatmullRom(a.x, s.x, c.x, i.x, n, o, h), $o.initNonuniformCatmullRom(a.y, s.y, c.y, i.y, n, o, h), ta.initNonuniformCatmullRom(a.z, s.z, c.z, i.z, n, o, h) } else "catmullrom" === this.curveType && (Ko.initCatmullRom(a.x, s.x, c.x, i.x, this.tension), $o.initCatmullRom(a.y, s.y, c.y, i.y, this.tension), ta.initCatmullRom(a.z, s.z, c.z, i.z, this.tension)); return e.set(Ko.calc(t), $o.calc(t), ta.calc(t)), e }, Nn.prototype.copy = function (t) { Pn.prototype.copy.call(this, t), this.points = []; for (var e = 0, i = t.points.length; e < i; e++)this.points.push(t.points[e].clone()); return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, Nn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); t.points = []; for (var e = 0, i = this.points.length; e < i; e++)t.points.push(this.points[e].toArray()); return t.closed = this.closed, t.curveType = this.curveType, t.tension = this.tension, t }, Nn.prototype.fromJSON = function (t) { Pn.prototype.fromJSON.call(this, t), this.points = []; for (var e = 0, i = t.points.length; e < i; e++) { var n = t.points[e]; this.points.push((new r).fromArray(n)) } return this.closed = t.closed, this.curveType = t.curveType, this.tension = t.tension, this }, Fn.prototype = Object.create(Pn.prototype), Fn.prototype.constructor = Fn, Fn.prototype.isCubicBezierCurve = !0, Fn.prototype.getPoint = function (t, e) { e = e || new i; var n = this.v0, r = this.v1, o = this.v2, a = this.v3; return e.set(Un(t, n.x, r.x, o.x, a.x), Un(t, n.y, r.y, o.y, a.y)), e }, Fn.prototype.copy = function (t) { return Pn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Fn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Fn.prototype.fromJSON = function (t) { return Pn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, Gn.prototype = Object.create(Pn.prototype), Gn.prototype.constructor = Gn, Gn.prototype.isCubicBezierCurve3 = !0, Gn.prototype.getPoint = function (t, e) { e = e || new r; var i = this.v0, n = this.v1, o = this.v2, a = this.v3; return e.set(Un(t, i.x, n.x, o.x, a.x), Un(t, i.y, n.y, o.y, a.y), Un(t, i.z, n.z, o.z, a.z)), e }, Gn.prototype.copy = function (t) { return Pn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this.v3.copy(t.v3), this }, Gn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t.v3 = this.v3.toArray(), t }, Gn.prototype.fromJSON = function (t) { return Pn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this.v3.fromArray(t.v3), this }, Hn.prototype = Object.create(Pn.prototype), Hn.prototype.constructor = Hn, Hn.prototype.isLineCurve = !0, Hn.prototype.getPoint = function (t, e) { return e = e || new i, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e }, Hn.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, Hn.prototype.getTangent = function () { return this.v2.clone().sub(this.v1).normalize() }, Hn.prototype.copy = function (t) { return Pn.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Hn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Hn.prototype.fromJSON = function (t) { return Pn.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, kn.prototype = Object.create(Pn.prototype), kn.prototype.constructor = kn, kn.prototype.isLineCurve3 = !0, kn.prototype.getPoint = function (t, e) { return e = e || new r, 1 === t ? e.copy(this.v2) : (e.copy(this.v2).sub(this.v1), e.multiplyScalar(t).add(this.v1)), e }, kn.prototype.getPointAt = function (t, e) { return this.getPoint(t, e) }, kn.prototype.copy = function (t) { return Pn.prototype.copy.call(this, t), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, kn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); return t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, kn.prototype.fromJSON = function (t) { return Pn.prototype.fromJSON.call(this, t), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Vn.prototype = Object.create(Pn.prototype), Vn.prototype.constructor = Vn, Vn.prototype.isQuadraticBezierCurve = !0, Vn.prototype.getPoint = function (t, e) { e = e || new i; var n = this.v0, r = this.v1, o = this.v2; return e.set(zn(t, n.x, r.x, o.x), zn(t, n.y, r.y, o.y)), e }, Vn.prototype.copy = function (t) { return Pn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, Vn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, Vn.prototype.fromJSON = function (t) { return Pn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, jn.prototype = Object.create(Pn.prototype), jn.prototype.constructor = jn, jn.prototype.isQuadraticBezierCurve3 = !0, jn.prototype.getPoint = function (t, e) { e = e || new r; var i = this.v0, n = this.v1, o = this.v2; return e.set(zn(t, i.x, n.x, o.x), zn(t, i.y, n.y, o.y), zn(t, i.z, n.z, o.z)), e }, jn.prototype.copy = function (t) { return Pn.prototype.copy.call(this, t), this.v0.copy(t.v0), this.v1.copy(t.v1), this.v2.copy(t.v2), this }, jn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); return t.v0 = this.v0.toArray(), t.v1 = this.v1.toArray(), t.v2 = this.v2.toArray(), t }, jn.prototype.fromJSON = function (t) { return Pn.prototype.fromJSON.call(this, t), this.v0.fromArray(t.v0), this.v1.fromArray(t.v1), this.v2.fromArray(t.v2), this }, Wn.prototype = Object.create(Pn.prototype), Wn.prototype.constructor = Wn, Wn.prototype.isSplineCurve = !0, Wn.prototype.getPoint = function (t, e) { e = e || new i; var n = this.points, r = (n.length - 1) * t; r -= t = Math.floor(r); var o = n[0 === t ? t : t - 1], a = n[t], s = n[t > n.length - 2 ? n.length - 1 : t + 1]; return n = n[t > n.length - 3 ? n.length - 1 : t + 2], e.set(Bn(r, o.x, a.x, s.x, n.x), Bn(r, o.y, a.y, s.y, n.y)), e }, Wn.prototype.copy = function (t) { Pn.prototype.copy.call(this, t), this.points = []; for (var e = 0, i = t.points.length; e < i; e++)this.points.push(t.points[e].clone()); return this }, Wn.prototype.toJSON = function () { var t = Pn.prototype.toJSON.call(this); t.points = []; for (var e = 0, i = this.points.length; e < i; e++)t.points.push(this.points[e].toArray()); return t }, Wn.prototype.fromJSON = function (t) { Pn.prototype.fromJSON.call(this, t), this.points = []; for (var e = 0, n = t.points.length; e < n; e++) { var r = t.points[e]; this.points.push((new i).fromArray(r)) } return this }; var ea = Object.freeze({ ArcCurve: On, CatmullRomCurve3: Nn, CubicBezierCurve: Fn, CubicBezierCurve3: Gn, EllipseCurve: In, LineCurve: Hn, LineCurve3: kn, QuadraticBezierCurve: Vn, QuadraticBezierCurve3: jn, SplineCurve: Wn }); qn.prototype = Object.assign(Object.create(Pn.prototype), { constructor: qn, add: function (t) { this.curves.push(t) }, closePath: function () { var t = this.curves[0].getPoint(0), e = this.curves[this.curves.length - 1].getPoint(1); t.equals(e) || this.curves.push(new Hn(e, t)) }, getPoint: function (t) { var e = t * this.getLength(), i = this.getCurveLengths(); for (t = 0; t < i.length;) { if (i[t] >= e) return e = i[t] - e, i = (t = this.curves[t]).getLength(), t.getPointAt(0 === i ? 0 : 1 - e / i); t++ } return null }, getLength: function () { var t = this.getCurveLengths(); return t[t.length - 1] }, updateArcLengths: function () { this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths() }, getCurveLengths: function () { if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, i = 0, n = this.curves.length; i < n; i++)e += this.curves[i].getLength(), t.push(e); return this.cacheLengths = t }, getSpacedPoints: function (t) { void 0 === t && (t = 40); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return this.autoClose && e.push(e[0]), e }, getPoints: function (t) { t = t || 12; for (var e, i = [], n = 0, r = this.curves; n < r.length; n++) { var o = r[n]; o = o.getPoints(o && o.isEllipseCurve ? 2 * t : o && (o.isLineCurve || o.isLineCurve3) ? 1 : o && o.isSplineCurve ? t * o.points.length : t); for (var a = 0; a < o.length; a++) { var s = o[a]; e && e.equals(s) || (i.push(s), e = s) } } return this.autoClose && 1 < i.length && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i }, copy: function (t) { Pn.prototype.copy.call(this, t), this.curves = []; for (var e = 0, i = t.curves.length; e < i; e++)this.curves.push(t.curves[e].clone()); return this.autoClose = t.autoClose, this }, toJSON: function () { var t = Pn.prototype.toJSON.call(this); t.autoClose = this.autoClose, t.curves = []; for (var e = 0, i = this.curves.length; e < i; e++)t.curves.push(this.curves[e].toJSON()); return t }, fromJSON: function (t) { Pn.prototype.fromJSON.call(this, t), this.autoClose = t.autoClose, this.curves = []; for (var e = 0, i = t.curves.length; e < i; e++) { var n = t.curves[e]; this.curves.push((new ea[n.type]).fromJSON(n)) } return this } }), Xn.prototype = Object.assign(Object.create(qn.prototype), { constructor: Xn, setFromPoints: function (t) { this.moveTo(t[0].x, t[0].y); for (var e = 1, i = t.length; e < i; e++)this.lineTo(t[e].x, t[e].y) }, moveTo: function (t, e) { this.currentPoint.set(t, e) }, lineTo: function (t, e) { var n = new Hn(this.currentPoint.clone(), new i(t, e)); this.curves.push(n), this.currentPoint.set(t, e) }, quadraticCurveTo: function (t, e, n, r) { t = new Vn(this.currentPoint.clone(), new i(t, e), new i(n, r)), this.curves.push(t), this.currentPoint.set(n, r) }, bezierCurveTo: function (t, e, n, r, o, a) { t = new Fn(this.currentPoint.clone(), new i(t, e), new i(n, r), new i(o, a)), this.curves.push(t), this.currentPoint.set(o, a) }, splineThru: function (t) { var e = [this.currentPoint.clone()].concat(t); e = new Wn(e), this.curves.push(e), this.currentPoint.copy(t[t.length - 1]) }, arc: function (t, e, i, n, r, o) { this.absarc(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, o) }, absarc: function (t, e, i, n, r, o) { this.absellipse(t, e, i, i, n, r, o) }, ellipse: function (t, e, i, n, r, o, a, s) { this.absellipse(t + this.currentPoint.x, e + this.currentPoint.y, i, n, r, o, a, s) }, absellipse: function (t, e, i, n, r, o, a, s) { t = new In(t, e, i, n, r, o, a, s), 0 < this.curves.length && ((e = t.getPoint(0)).equals(this.currentPoint) || this.lineTo(e.x, e.y)), this.curves.push(t), t = t.getPoint(1), this.currentPoint.copy(t) }, copy: function (t) { return qn.prototype.copy.call(this, t), this.currentPoint.copy(t.currentPoint), this }, toJSON: function () { var t = qn.prototype.toJSON.call(this); return t.currentPoint = this.currentPoint.toArray(), t }, fromJSON: function (t) { return qn.prototype.fromJSON.call(this, t), this.currentPoint.fromArray(t.currentPoint), this } }), Yn.prototype = Object.assign(Object.create(Xn.prototype), { constructor: Yn, getPointsHoles: function (t) { for (var e = [], i = 0, n = this.holes.length; i < n; i++)e[i] = this.holes[i].getPoints(t); return e }, extractPoints: function (t) { return { shape: this.getPoints(t), holes: this.getPointsHoles(t) } }, copy: function (t) { Xn.prototype.copy.call(this, t), this.holes = []; for (var e = 0, i = t.holes.length; e < i; e++)this.holes.push(t.holes[e].clone()); return this }, toJSON: function () { var t = Xn.prototype.toJSON.call(this); t.uuid = this.uuid, t.holes = []; for (var e = 0, i = this.holes.length; e < i; e++)t.holes.push(this.holes[e].toJSON()); return t }, fromJSON: function (t) { Xn.prototype.fromJSON.call(this, t), this.uuid = t.uuid, this.holes = []; for (var e = 0, i = t.holes.length; e < i; e++) { var n = t.holes[e]; this.holes.push((new Xn).fromJSON(n)) } return this } }), Zn.prototype = Object.assign(Object.create(A.prototype), { constructor: Zn, isLight: !0, copy: function (t) { return A.prototype.copy.call(this, t), this.color.copy(t.color), this.intensity = t.intensity, this }, toJSON: function (t) { return (t = A.prototype.toJSON.call(this, t)).object.color = this.color.getHex(), t.object.intensity = this.intensity, void 0 !== this.groundColor && (t.object.groundColor = this.groundColor.getHex()), void 0 !== this.distance && (t.object.distance = this.distance), void 0 !== this.angle && (t.object.angle = this.angle), void 0 !== this.decay && (t.object.decay = this.decay), void 0 !== this.penumbra && (t.object.penumbra = this.penumbra), void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()), t } }), Jn.prototype = Object.assign(Object.create(Zn.prototype), { constructor: Jn, isHemisphereLight: !0, copy: function (t) { return Zn.prototype.copy.call(this, t), this.groundColor.copy(t.groundColor), this } }), Object.assign(Qn.prototype, { copy: function (t) { return this.camera = t.camera.clone(), this.bias = t.bias, this.radius = t.radius, this.mapSize.copy(t.mapSize), this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var t = {}; return 0 !== this.bias && (t.bias = this.bias), 1 !== this.radius && (t.radius = this.radius), 512 === this.mapSize.x && 512 === this.mapSize.y || (t.mapSize = this.mapSize.toArray()), t.camera = this.camera.toJSON(!1).object, delete t.camera.matrix, t } }), Kn.prototype = Object.assign(Object.create(Qn.prototype), { constructor: Kn, isSpotLightShadow: !0, update: function (t) { var e = this.camera, i = 2 * fo.RAD2DEG * t.angle, n = this.mapSize.width / this.mapSize.height; t = t.distance || e.far, i === e.fov && n === e.aspect && t === e.far || (e.fov = i, e.aspect = n, e.far = t, e.updateProjectionMatrix()) } }), $n.prototype = Object.assign(Object.create(Zn.prototype), { constructor: $n, isSpotLight: !0, copy: function (t) { return Zn.prototype.copy.call(this, t), this.distance = t.distance, this.angle = t.angle, this.penumbra = t.penumbra, this.decay = t.decay, this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), tr.prototype = Object.assign(Object.create(Zn.prototype), { constructor: tr, isPointLight: !0, copy: function (t) { return Zn.prototype.copy.call(this, t), this.distance = t.distance, this.decay = t.decay, this.shadow = t.shadow.clone(), this } }), er.prototype = Object.assign(Object.create(be.prototype), { constructor: er, isOrthographicCamera: !0, copy: function (t, e) { return be.prototype.copy.call(this, t, e), this.left = t.left, this.right = t.right, this.top = t.top, this.bottom = t.bottom, this.near = t.near, this.far = t.far, this.zoom = t.zoom, this.view = null === t.view ? null : Object.assign({}, t.view), this }, setViewOffset: function (t, e, i, n, r, o) { null === this.view && (this.view = { enabled: !0, fullWidth: 1, fullHeight: 1, offsetX: 0, offsetY: 0, width: 1, height: 1 }), this.view.enabled = !0, this.view.fullWidth = t, this.view.fullHeight = e, this.view.offsetX = i, this.view.offsetY = n, this.view.width = r, this.view.height = o, this.updateProjectionMatrix() }, clearViewOffset: function () { null !== this.view && (this.view.enabled = !1), this.updateProjectionMatrix() }, updateProjectionMatrix: function () { var t = (this.right - this.left) / (2 * this.zoom), e = (this.top - this.bottom) / (2 * this.zoom), i = (this.right + this.left) / 2, n = (this.top + this.bottom) / 2, r = i - t; if (i += t, t = n + e, e = n - e, null !== this.view && this.view.enabled) { i = this.zoom / (this.view.width / this.view.fullWidth), e = this.zoom / (this.view.height / this.view.fullHeight); var o = (this.right - this.left) / this.view.width; n = (this.top - this.bottom) / this.view.height, i = (r += this.view.offsetX / i * o) + this.view.width / i * o, e = (t -= this.view.offsetY / e * n) - this.view.height / e * n } this.projectionMatrix.makeOrthographic(r, i, t, e, this.near, this.far), this.projectionMatrixInverse.getInverse(this.projectionMatrix) }, toJSON: function (t) { return (t = A.prototype.toJSON.call(this, t)).object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, null !== this.view && (t.object.view = Object.assign({}, this.view)), t } }), ir.prototype = Object.assign(Object.create(Qn.prototype), { constructor: ir }), nr.prototype = Object.assign(Object.create(Zn.prototype), { constructor: nr, isDirectionalLight: !0, copy: function (t) { return Zn.prototype.copy.call(this, t), this.target = t.target.clone(), this.shadow = t.shadow.clone(), this } }), rr.prototype = Object.assign(Object.create(Zn.prototype), { constructor: rr, isAmbientLight: !0 }), or.prototype = Object.assign(Object.create(Zn.prototype), { constructor: or, isRectAreaLight: !0, copy: function (t) { return Zn.prototype.copy.call(this, t), this.width = t.width, this.height = t.height, this }, toJSON: function (t) { return (t = Zn.prototype.toJSON.call(this, t)).object.width = this.width, t.object.height = this.height, t } }), Object.assign(ar.prototype, { load: function (t, e, i, n) { var r = this, o = new En(r.manager); o.setPath(r.path), o.load(t, (function (t) { e(r.parse(JSON.parse(t))) }), i, n) }, parse: function (t) { function e(t) { return void 0 === n[t] && console.warn("THREE.MaterialLoader: Undefined texture", t), n[t] } var n = this.textures, a = new qo[t.type]; if (void 0 !== t.uuid && (a.uuid = t.uuid), void 0 !== t.name && (a.name = t.name), void 0 !== t.color && a.color.setHex(t.color), void 0 !== t.roughness && (a.roughness = t.roughness), void 0 !== t.metalness && (a.metalness = t.metalness), void 0 !== t.emissive && a.emissive.setHex(t.emissive), void 0 !== t.specular && a.specular.setHex(t.specular), void 0 !== t.shininess && (a.shininess = t.shininess), void 0 !== t.clearCoat && (a.clearCoat = t.clearCoat), void 0 !== t.clearCoatRoughness && (a.clearCoatRoughness = t.clearCoatRoughness), void 0 !== t.vertexColors && (a.vertexColors = t.vertexColors), void 0 !== t.fog && (a.fog = t.fog), void 0 !== t.flatShading && (a.flatShading = t.flatShading), void 0 !== t.blending && (a.blending = t.blending), void 0 !== t.combine && (a.combine = t.combine), void 0 !== t.side && (a.side = t.side), void 0 !== t.opacity && (a.opacity = t.opacity), void 0 !== t.transparent && (a.transparent = t.transparent), void 0 !== t.alphaTest && (a.alphaTest = t.alphaTest), void 0 !== t.depthTest && (a.depthTest = t.depthTest), void 0 !== t.depthWrite && (a.depthWrite = t.depthWrite), void 0 !== t.colorWrite && (a.colorWrite = t.colorWrite), void 0 !== t.wireframe && (a.wireframe = t.wireframe), void 0 !== t.wireframeLinewidth && (a.wireframeLinewidth = t.wireframeLinewidth), void 0 !== t.wireframeLinecap && (a.wireframeLinecap = t.wireframeLinecap), void 0 !== t.wireframeLinejoin && (a.wireframeLinejoin = t.wireframeLinejoin), void 0 !== t.rotation && (a.rotation = t.rotation), 1 !== t.linewidth && (a.linewidth = t.linewidth), void 0 !== t.dashSize && (a.dashSize = t.dashSize), void 0 !== t.gapSize && (a.gapSize = t.gapSize), void 0 !== t.scale && (a.scale = t.scale), void 0 !== t.polygonOffset && (a.polygonOffset = t.polygonOffset), void 0 !== t.polygonOffsetFactor && (a.polygonOffsetFactor = t.polygonOffsetFactor), void 0 !== t.polygonOffsetUnits && (a.polygonOffsetUnits = t.polygonOffsetUnits), void 0 !== t.skinning && (a.skinning = t.skinning), void 0 !== t.morphTargets && (a.morphTargets = t.morphTargets), void 0 !== t.dithering && (a.dithering = t.dithering), void 0 !== t.visible && (a.visible = t.visible), void 0 !== t.userData && (a.userData = t.userData), void 0 !== t.uniforms) for (var c in t.uniforms) { var h = t.uniforms[c]; switch (a.uniforms[c] = {}, h.type) { case "t": a.uniforms[c].value = e(h.value); break; case "c": a.uniforms[c].value = (new x).setHex(h.value); break; case "v2": a.uniforms[c].value = (new i).fromArray(h.value); break; case "v3": a.uniforms[c].value = (new r).fromArray(h.value); break; case "v4": a.uniforms[c].value = (new s).fromArray(h.value); break; case "m3": a.uniforms[c].value = (new o).fromArray(h.value); case "m4": a.uniforms[c].value = (new g).fromArray(h.value); break; default: a.uniforms[c].value = h.value } } if (void 0 !== t.defines && (a.defines = t.defines), void 0 !== t.vertexShader && (a.vertexShader = t.vertexShader), void 0 !== t.fragmentShader && (a.fragmentShader = t.fragmentShader), void 0 !== t.extensions) for (var l in t.extensions) a.extensions[l] = t.extensions[l]; return void 0 !== t.shading && (a.flatShading = 1 === t.shading), void 0 !== t.size && (a.size = t.size), void 0 !== t.sizeAttenuation && (a.sizeAttenuation = t.sizeAttenuation), void 0 !== t.map && (a.map = e(t.map)), void 0 !== t.matcap && (a.matcap = e(t.matcap)), void 0 !== t.alphaMap && (a.alphaMap = e(t.alphaMap), a.transparent = !0), void 0 !== t.bumpMap && (a.bumpMap = e(t.bumpMap)), void 0 !== t.bumpScale && (a.bumpScale = t.bumpScale), void 0 !== t.normalMap && (a.normalMap = e(t.normalMap)), void 0 !== t.normalMapType && (a.normalMapType = t.normalMapType), void 0 !== t.normalScale && (c = t.normalScale, !1 === Array.isArray(c) && (c = [c, c]), a.normalScale = (new i).fromArray(c)), void 0 !== t.displacementMap && (a.displacementMap = e(t.displacementMap)), void 0 !== t.displacementScale && (a.displacementScale = t.displacementScale), void 0 !== t.displacementBias && (a.displacementBias = t.displacementBias), void 0 !== t.roughnessMap && (a.roughnessMap = e(t.roughnessMap)), void 0 !== t.metalnessMap && (a.metalnessMap = e(t.metalnessMap)), void 0 !== t.emissiveMap && (a.emissiveMap = e(t.emissiveMap)), void 0 !== t.emissiveIntensity && (a.emissiveIntensity = t.emissiveIntensity), void 0 !== t.specularMap && (a.specularMap = e(t.specularMap)), void 0 !== t.envMap && (a.envMap = e(t.envMap)), void 0 !== t.envMapIntensity && (a.envMapIntensity = t.envMapIntensity), void 0 !== t.reflectivity && (a.reflectivity = t.reflectivity), void 0 !== t.lightMap && (a.lightMap = e(t.lightMap)), void 0 !== t.lightMapIntensity && (a.lightMapIntensity = t.lightMapIntensity), void 0 !== t.aoMap && (a.aoMap = e(t.aoMap)), void 0 !== t.aoMapIntensity && (a.aoMapIntensity = t.aoMapIntensity), void 0 !== t.gradientMap && (a.gradientMap = e(t.gradientMap)), a }, setPath: function (t) { return this.path = t, this }, setTextures: function (t) { return this.textures = t, this } }); var ia = { decodeText: function (t) { if ("undefined" != typeof TextDecoder) return (new TextDecoder).decode(t); for (var e = "", i = 0, n = t.length; i < n; i++)e += String.fromCharCode(t[i]); try { return decodeURIComponent(escape(e)) } catch (t) { return e } }, extractUrlBase: function (t) { var e = t.lastIndexOf("/"); return -1 === e ? "./" : t.substr(0, e + 1) } }; sr.prototype = Object.assign(Object.create(F.prototype), { constructor: sr, isInstancedBufferGeometry: !0, copy: function (t) { return F.prototype.copy.call(this, t), this.maxInstancedCount = t.maxInstancedCount, this }, clone: function () { return (new this.constructor).copy(this) }, toJSON: function () { var t = F.prototype.toJSON.call(this); return t.maxInstancedCount = this.maxInstancedCount, t.isInstancedBufferGeometry = !0, t } }), cr.prototype = Object.assign(Object.create(S.prototype), { constructor: cr, isInstancedBufferAttribute: !0, copy: function (t) { return S.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this }, toJSON: function () { var t = S.prototype.toJSON.call(this); return t.meshPerAttribute = this.meshPerAttribute, t.isInstancedBufferAttribute = !0, t } }), Object.assign(hr.prototype, { load: function (t, e, i, n) { var r = this, o = new En(r.manager); o.setPath(r.path), o.load(t, (function (t) { e(r.parse(JSON.parse(t))) }), i, n) }, parse: function (t) { var e = t.isInstancedBufferGeometry ? new sr : new F, i = t.data.index; if (void 0 !== i) { var n = new na[i.type](i.array); e.setIndex(new S(n, 1)) } for (var o in i = t.data.attributes) { var a = i[o]; n = new na[a.type](a.array), n = new (a.isInstancedBufferAttribute ? cr : S)(n, a.itemSize, a.normalized), void 0 !== a.name && (n.name = a.name), e.addAttribute(o, n) } var s = t.data.morphAttributes; if (s) for (o in s) { var c = s[o], h = []; i = 0; for (var l = c.length; i < l; i++)a = c[i], n = new S(n = new na[a.type](a.array), a.itemSize, a.normalized), void 0 !== a.name && (n.name = a.name), h.push(n); e.morphAttributes[o] = h } if (void 0 !== (o = t.data.groups || t.data.drawcalls || t.data.offsets)) for (i = 0, a = o.length; i !== a; ++i)n = o[i], e.addGroup(n.start, n.count, n.materialIndex); return void 0 !== (i = t.data.boundingSphere) && (o = new r, void 0 !== i.center && o.fromArray(i.center), e.boundingSphere = new p(o, i.radius)), t.name && (e.name = t.name), t.userData && (e.userData = t.userData), e }, setPath: function (t) { return this.path = t, this } }); var na = { Int8Array: Int8Array, Uint8Array: Uint8Array, Uint8ClampedArray: "undefined" != typeof Uint8ClampedArray ? Uint8ClampedArray : Uint8Array, Int16Array: Int16Array, Uint16Array: Uint16Array, Int32Array: Int32Array, Uint32Array: Uint32Array, Float32Array: Float32Array, Float64Array: Float64Array }; Object.assign(lr.prototype, { crossOrigin: "anonymous", load: function (t, e, i, n) { var r = this, o = void 0 === this.path ? ia.extractUrlBase(t) : this.path; this.resourcePath = this.resourcePath || o, (o = new En(r.manager)).setPath(this.path), o.load(t, (function (i) { var o = null; try { o = JSON.parse(i) } catch (e) { return void 0 !== n && n(e), void console.error("THREE:ObjectLoader: Can't parse " + t + ".", e.message) } void 0 === (i = o.metadata) || void 0 === i.type || "geometry" === i.type.toLowerCase() ? console.error("THREE.ObjectLoader: Can't load " + t) : r.parse(o, e) }), i, n) }, setPath: function (t) { return this.path = t, this }, setResourcePath: function (t) { return this.resourcePath = t, this }, setCrossOrigin: function (t) { return this.crossOrigin = t, this }, parse: function (t, e) { var i = this.parseShape(t.shapes); i = this.parseGeometries(t.geometries, i); var n = this.parseImages(t.images, (function () { void 0 !== e && e(r) })); n = this.parseTextures(t.textures, n), n = this.parseMaterials(t.materials, n); var r = this.parseObject(t.object, i, n); return t.animations && (r.animations = this.parseAnimations(t.animations)), void 0 !== t.images && 0 !== t.images.length || void 0 === e || e(r), r }, parseShape: function (t) { var e = {}; if (void 0 !== t) for (var i = 0, n = t.length; i < n; i++) { var r = (new Yn).fromJSON(t[i]); e[r.uuid] = r } return e }, parseGeometries: function (t, e) { var i = {}; if (void 0 !== t) for (var n = new hr, r = 0, o = t.length; r < o; r++) { var a = t[r]; switch (a.type) { case "PlaneGeometry": case "PlaneBufferGeometry": var s = new Wo[a.type](a.width, a.height, a.widthSegments, a.heightSegments); break; case "BoxGeometry": case "BoxBufferGeometry": case "CubeGeometry": s = new Wo[a.type](a.width, a.height, a.depth, a.widthSegments, a.heightSegments, a.depthSegments); break; case "CircleGeometry": case "CircleBufferGeometry": s = new Wo[a.type](a.radius, a.segments, a.thetaStart, a.thetaLength); break; case "CylinderGeometry": case "CylinderBufferGeometry": s = new Wo[a.type](a.radiusTop, a.radiusBottom, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength); break; case "ConeGeometry": case "ConeBufferGeometry": s = new Wo[a.type](a.radius, a.height, a.radialSegments, a.heightSegments, a.openEnded, a.thetaStart, a.thetaLength); break; case "SphereGeometry": case "SphereBufferGeometry": s = new Wo[a.type](a.radius, a.widthSegments, a.heightSegments, a.phiStart, a.phiLength, a.thetaStart, a.thetaLength); break; case "DodecahedronGeometry": case "DodecahedronBufferGeometry": case "IcosahedronGeometry": case "IcosahedronBufferGeometry": case "OctahedronGeometry": case "OctahedronBufferGeometry": case "TetrahedronGeometry": case "TetrahedronBufferGeometry": s = new Wo[a.type](a.radius, a.detail); break; case "RingGeometry": case "RingBufferGeometry": s = new Wo[a.type](a.innerRadius, a.outerRadius, a.thetaSegments, a.phiSegments, a.thetaStart, a.thetaLength); break; case "TorusGeometry": case "TorusBufferGeometry": s = new Wo[a.type](a.radius, a.tube, a.radialSegments, a.tubularSegments, a.arc); break; case "TorusKnotGeometry": case "TorusKnotBufferGeometry": s = new Wo[a.type](a.radius, a.tube, a.tubularSegments, a.radialSegments, a.p, a.q); break; case "TubeGeometry": case "TubeBufferGeometry": s = new Wo[a.type]((new ea[a.path.type]).fromJSON(a.path), a.tubularSegments, a.radius, a.radialSegments, a.closed); break; case "LatheGeometry": case "LatheBufferGeometry": s = new Wo[a.type](a.points, a.segments, a.phiStart, a.phiLength); break; case "PolyhedronGeometry": case "PolyhedronBufferGeometry": s = new Wo[a.type](a.vertices, a.indices, a.radius, a.details); break; case "ShapeGeometry": case "ShapeBufferGeometry": s = []; for (var c = 0, h = a.shapes.length; c < h; c++) { var l = e[a.shapes[c]]; s.push(l) } s = new Wo[a.type](s, a.curveSegments); break; case "ExtrudeGeometry": case "ExtrudeBufferGeometry": for (s = [], c = 0, h = a.shapes.length; c < h; c++)l = e[a.shapes[c]], s.push(l); void 0 !== (c = a.options.extrudePath) && (a.options.extrudePath = (new ea[c.type]).fromJSON(c)), s = new Wo[a.type](s, a.options); break; case "BufferGeometry": case "InstancedBufferGeometry": s = n.parse(a); break; case "Geometry": "THREE" in window && "LegacyJSONLoader" in THREE ? s = (new THREE.LegacyJSONLoader).parse(a, this.resourcePath).geometry : console.error('THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".'); break; default: console.warn('THREE.ObjectLoader: Unsupported geometry type "' + a.type + '"'); continue }s.uuid = a.uuid, void 0 !== a.name && (s.name = a.name), !0 === s.isBufferGeometry && void 0 !== a.userData && (s.userData = a.userData), i[a.uuid] = s } return i }, parseMaterials: function (t, e) { var i = {}, n = {}; if (void 0 !== t) { var r = new ar; r.setTextures(e), e = 0; for (var o = t.length; e < o; e++) { var a = t[e]; if ("MultiMaterial" === a.type) { for (var s = [], c = 0; c < a.materials.length; c++) { var h = a.materials[c]; void 0 === i[h.uuid] && (i[h.uuid] = r.parse(h)), s.push(i[h.uuid]) } n[a.uuid] = s } else void 0 === i[a.uuid] && (i[a.uuid] = r.parse(a)), n[a.uuid] = i[a.uuid] } } return n }, parseAnimations: function (t) { for (var e = [], i = 0; i < t.length; i++) { var n = t[i], r = wn.parse(n); void 0 !== n.uuid && (r.uuid = n.uuid), e.push(r) } return e }, parseImages: function (t, e) { function i(t) { return n.manager.itemStart(t), o.load(t, (function () { n.manager.itemEnd(t) }), void 0, (function () { n.manager.itemError(t), n.manager.itemEnd(t) })) } var n = this, r = {}; if (void 0 !== t && 0 < t.length) { var o = new Ln(e = new _n(e)); o.setCrossOrigin(this.crossOrigin), e = 0; for (var a = t.length; e < a; e++) { var s = t[e], c = s.url; if (Array.isArray(c)) { r[s.uuid] = []; for (var h = 0, l = c.length; h < l; h++) { var u = c[h]; u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(u) ? u : n.resourcePath + u, r[s.uuid].push(i(u)) } } else u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(s.url) ? s.url : n.resourcePath + s.url, r[s.uuid] = i(u) } } return r }, parseTextures: function (t, e) { function i(t, e) { return "number" == typeof t ? t : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", t), e[t]) } var n = {}; if (void 0 !== t) for (var r = 0, o = t.length; r < o; r++) { var s = t[r]; void 0 === s.image && console.warn('THREE.ObjectLoader: No "image" specified for', s.uuid), void 0 === e[s.image] && console.warn("THREE.ObjectLoader: Undefined image", s.image); var c = Array.isArray(e[s.image]) ? new st(e[s.image]) : new a(e[s.image]); c.needsUpdate = !0, c.uuid = s.uuid, void 0 !== s.name && (c.name = s.name), void 0 !== s.mapping && (c.mapping = i(s.mapping, ra)), void 0 !== s.offset && c.offset.fromArray(s.offset), void 0 !== s.repeat && c.repeat.fromArray(s.repeat), void 0 !== s.center && c.center.fromArray(s.center), void 0 !== s.rotation && (c.rotation = s.rotation), void 0 !== s.wrap && (c.wrapS = i(s.wrap[0], oa), c.wrapT = i(s.wrap[1], oa)), void 0 !== s.format && (c.format = s.format), void 0 !== s.type && (c.type = s.type), void 0 !== s.encoding && (c.encoding = s.encoding), void 0 !== s.minFilter && (c.minFilter = i(s.minFilter, aa)), void 0 !== s.magFilter && (c.magFilter = i(s.magFilter, aa)), void 0 !== s.anisotropy && (c.anisotropy = s.anisotropy), void 0 !== s.flipY && (c.flipY = s.flipY), void 0 !== s.premultiplyAlpha && (c.premultiplyAlpha = s.premultiplyAlpha), void 0 !== s.unpackAlignment && (c.unpackAlignment = s.unpackAlignment), n[s.uuid] = c } return n }, parseObject: function (t, e, i) { function n(t) { return void 0 === e[t] && console.warn("THREE.ObjectLoader: Undefined geometry", t), e[t] } function r(t) { if (void 0 !== t) { if (Array.isArray(t)) { for (var e = [], n = 0, r = t.length; n < r; n++) { var o = t[n]; void 0 === i[o] && console.warn("THREE.ObjectLoader: Undefined material", o), e.push(i[o]) } return e } return void 0 === i[t] && console.warn("THREE.ObjectLoader: Undefined material", t), i[t] } } switch (t.type) { case "Scene": var o = new Ce; void 0 !== t.background && Number.isInteger(t.background) && (o.background = new x(t.background)), void 0 !== t.fog && ("Fog" === t.fog.type ? o.fog = new Le(t.fog.color, t.fog.near, t.fog.far) : "FogExp2" === t.fog.type && (o.fog = new Se(t.fog.color, t.fog.density))); break; case "PerspectiveCamera": o = new we(t.fov, t.aspect, t.near, t.far), void 0 !== t.focus && (o.focus = t.focus), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.filmGauge && (o.filmGauge = t.filmGauge), void 0 !== t.filmOffset && (o.filmOffset = t.filmOffset), void 0 !== t.view && (o.view = Object.assign({}, t.view)); break; case "OrthographicCamera": o = new er(t.left, t.right, t.top, t.bottom, t.near, t.far), void 0 !== t.zoom && (o.zoom = t.zoom), void 0 !== t.view && (o.view = Object.assign({}, t.view)); break; case "AmbientLight": o = new rr(t.color, t.intensity); break; case "DirectionalLight": o = new nr(t.color, t.intensity); break; case "PointLight": o = new tr(t.color, t.intensity, t.distance, t.decay); break; case "RectAreaLight": o = new or(t.color, t.intensity, t.width, t.height); break; case "SpotLight": o = new $n(t.color, t.intensity, t.distance, t.angle, t.penumbra, t.decay); break; case "HemisphereLight": o = new Jn(t.color, t.groundColor, t.intensity); break; case "SkinnedMesh": console.warn("THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet."); case "Mesh": o = n(t.geometry); var a = r(t.material); o = o.bones && 0 < o.bones.length ? new Ne(o, a) : new Z(o, a), void 0 !== t.drawMode && o.setDrawMode(t.drawMode); break; case "LOD": o = new De; break; case "Line": o = new Fe(n(t.geometry), r(t.material), t.mode); break; case "LineLoop": o = new He(n(t.geometry), r(t.material)); break; case "LineSegments": o = new Ge(n(t.geometry), r(t.material)); break; case "PointCloud": case "Points": o = new Ve(n(t.geometry), r(t.material)); break; case "Sprite": o = new Oe(r(t.material)); break; case "Group": o = new xe; break; default: o = new A }if (o.uuid = t.uuid, void 0 !== t.name && (o.name = t.name), void 0 !== t.matrix ? (o.matrix.fromArray(t.matrix), void 0 !== t.matrixAutoUpdate && (o.matrixAutoUpdate = t.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (void 0 !== t.position && o.position.fromArray(t.position), void 0 !== t.rotation && o.rotation.fromArray(t.rotation), void 0 !== t.quaternion && o.quaternion.fromArray(t.quaternion), void 0 !== t.scale && o.scale.fromArray(t.scale)), void 0 !== t.castShadow && (o.castShadow = t.castShadow), void 0 !== t.receiveShadow && (o.receiveShadow = t.receiveShadow), t.shadow && (void 0 !== t.shadow.bias && (o.shadow.bias = t.shadow.bias), void 0 !== t.shadow.radius && (o.shadow.radius = t.shadow.radius), void 0 !== t.shadow.mapSize && o.shadow.mapSize.fromArray(t.shadow.mapSize), void 0 !== t.shadow.camera && (o.shadow.camera = this.parseObject(t.shadow.camera))), void 0 !== t.visible && (o.visible = t.visible), void 0 !== t.frustumCulled && (o.frustumCulled = t.frustumCulled), void 0 !== t.renderOrder && (o.renderOrder = t.renderOrder), void 0 !== t.userData && (o.userData = t.userData), void 0 !== t.layers && (o.layers.mask = t.layers), void 0 !== t.children) { a = t.children; for (var s = 0; s < a.length; s++)o.add(this.parseObject(a[s], e, i)) } if ("LOD" === t.type) for (t = t.levels, a = 0; a < t.length; a++) { s = t[a]; var c = o.getObjectByProperty("uuid", s.object); void 0 !== c && o.addLevel(c, s.distance) } return o } }); var ra = { UVMapping: 300, CubeReflectionMapping: 301, CubeRefractionMapping: 302, EquirectangularReflectionMapping: 303, EquirectangularRefractionMapping: 304, SphericalReflectionMapping: 305, CubeUVReflectionMapping: 306, CubeUVRefractionMapping: 307 }, oa = { RepeatWrapping: 1e3, ClampToEdgeWrapping: 1001, MirroredRepeatWrapping: 1002 }, aa = { NearestFilter: 1003, NearestMipMapNearestFilter: 1004, NearestMipMapLinearFilter: 1005, LinearFilter: 1006, LinearMipMapNearestFilter: 1007, LinearMipMapLinearFilter: 1008 }; ur.prototype = { constructor: ur, setOptions: function (t) { return this.options = t, this }, load: function (t, e, i, n) { void 0 === t && (t = ""), void 0 !== this.path && (t = this.path + t), t = this.manager.resolveURL(t); var r = this, o = Yo.get(t); if (void 0 !== o) return r.manager.itemStart(t), setTimeout((function () { e && e(o), r.manager.itemEnd(t) }), 0), o; fetch(t).then((function (t) { return t.blob() })).then((function (t) { return void 0 === r.options ? createImageBitmap(t) : createImageBitmap(t, r.options) })).then((function (i) { Yo.add(t, i), e && e(i), r.manager.itemEnd(t) })).catch((function (e) { n && n(e), r.manager.itemError(t), r.manager.itemEnd(t) })), r.manager.itemStart(t) }, setCrossOrigin: function () { return this }, setPath: function (t) { return this.path = t, this } }, Object.assign(dr.prototype, { moveTo: function (t, e) { this.currentPath = new Xn, this.subPaths.push(this.currentPath), this.currentPath.moveTo(t, e) }, lineTo: function (t, e) { this.currentPath.lineTo(t, e) }, quadraticCurveTo: function (t, e, i, n) { this.currentPath.quadraticCurveTo(t, e, i, n) }, bezierCurveTo: function (t, e, i, n, r, o) { this.currentPath.bezierCurveTo(t, e, i, n, r, o) }, splineThru: function (t) { this.currentPath.splineThru(t) }, toShapes: function (t, e) { function i(t) { for (var e = [], i = 0, n = t.length; i < n; i++) { var r = t[i], o = new Yn; o.curves = r.curves, e.push(o) } return e } function n(t, e) { for (var i = e.length, n = !1, r = i - 1, o = 0; o < i; r = o++) { var a = e[r], s = e[o], c = s.x - a.x, h = s.y - a.y; if (Math.abs(h) > Number.EPSILON) { if (0 > h && (a = e[o], c = -c, s = e[r], h = -h), !(t.y < a.y || t.y > s.y)) if (t.y === a.y) { if (t.x === a.x) return !0 } else { if (0 === (r = h * (t.x - a.x) - c * (t.y - a.y))) return !0; 0 > r || (n = !n) } } else if (t.y === a.y && (s.x <= t.x && t.x <= a.x || a.x <= t.x && t.x <= s.x)) return !0 } return n } var r = Vo.isClockWise, o = this.subPaths; if (0 === o.length) return []; if (!0 === e) return i(o); if (e = [], 1 === o.length) { var a = o[0], s = new Yn; return s.curves = a.curves, e.push(s), e } var c = !r(o[0].getPoints()); c = t ? !c : c, s = []; var h = [], l = [], u = 0; h[u] = void 0, l[u] = []; for (var d = 0, p = o.length; d < p; d++) { var f = (a = o[d]).getPoints(), m = r(f); (m = t ? !m : m) ? (!c && h[u] && u++, h[u] = { s: new Yn, p: f }, h[u].s.curves = a.curves, c && u++, l[u] = []) : l[u].push({ h: a, p: f[0] }) } if (!h[0]) return i(o); if (1 < h.length) { for (d = !1, t = [], r = 0, o = h.length; r < o; r++)s[r] = []; for (r = 0, o = h.length; r < o; r++)for (a = l[r], m = 0; m < a.length; m++) { for (c = a[m], u = !0, f = 0; f < h.length; f++)n(c.p, h[f].p) && (r !== f && t.push({ froms: r, tos: f, hole: m }), u ? (u = !1, s[f].push(c)) : d = !0); u && s[r].push(c) } 0 < t.length && (d || (l = s)) } for (d = 0, r = h.length; d < r; d++)for (s = h[d].s, e.push(s), o = 0, a = (t = l[d]).length; o < a; o++)s.holes.push(t[o].h); return e } }), Object.assign(pr.prototype, { isFont: !0, generateShapes: function (t, e) { void 0 === e && (e = 100); var i = [], n = e; e = this.data; var r = Array.from ? Array.from(t) : String(t).split(""); n /= e.resolution; var o = (e.boundingBox.yMax - e.boundingBox.yMin + e.underlineThickness) * n; t = []; for (var a = 0, s = 0, c = 0; c < r.length; c++) { var h = r[c]; if ("\n" === h) a = 0, s -= o; else { var l = n, u = a, d = s; if (h = e.glyphs[h] || e.glyphs["?"]) { var p = new dr; if (h.o) for (var f = h._cachedOutline || (h._cachedOutline = h.o.split(" ")), m = 0, g = f.length; m < g;)switch (f[m++]) { case "m": var v = f[m++] * l + u, y = f[m++] * l + d; p.moveTo(v, y); break; case "l": v = f[m++] * l + u, y = f[m++] * l + d, p.lineTo(v, y); break; case "q": var x = f[m++] * l + u, b = f[m++] * l + d, w = f[m++] * l + u, M = f[m++] * l + d; p.quadraticCurveTo(w, M, x, b); break; case "b": x = f[m++] * l + u, b = f[m++] * l + d, w = f[m++] * l + u, M = f[m++] * l + d, v = f[m++] * l + u, y = f[m++] * l + d, p.bezierCurveTo(w, M, v, y, x, b) }l = { offsetX: h.ha * l, path: p } } else l = void 0; a += l.offsetX, t.push(l.path) } } for (e = 0, r = t.length; e < r; e++)Array.prototype.push.apply(i, t[e].toShapes()); return i } }), Object.assign(fr.prototype, { load: function (t, e, i, n) { var r = this, o = new En(this.manager); o.setPath(this.path), o.load(t, (function (t) { try { var i = JSON.parse(t) } catch (e) { console.warn("THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead."), i = JSON.parse(t.substring(65, t.length - 2)) } t = r.parse(i), e && e(t) }), i, n) }, parse: function (t) { return new pr(t) }, setPath: function (t) { return this.path = t, this } }), mr.Handlers = { handlers: [], add: function (t, e) { this.handlers.push(t, e) }, get: function (t) { for (var e = this.handlers, i = 0, n = e.length; i < n; i += 2) { var r = e[i + 1]; if (e[i].test(t)) return r } return null } }, Object.assign(mr.prototype, { crossOrigin: "anonymous", onLoadStart: function () { }, onLoadProgress: function () { }, onLoadComplete: function () { }, initMaterials: function (t, e, i) { for (var n = [], r = 0; r < t.length; ++r)n[r] = this.createMaterial(t[r], e, i); return n }, createMaterial: function () { var t = { NoBlending: 0, NormalBlending: 1, AdditiveBlending: 2, SubtractiveBlending: 3, MultiplyBlending: 4, CustomBlending: 5 }, e = new x, i = new Rn, n = new ar; return function (r, o, a) { function s(t, e, n, r, s) { t = o + t; var c = mr.Handlers.get(t); return null !== c ? t = c.load(t) : (i.setCrossOrigin(a), t = i.load(t)), void 0 !== e && (t.repeat.fromArray(e), 1 !== e[0] && (t.wrapS = 1e3), 1 !== e[1] && (t.wrapT = 1e3)), void 0 !== n && t.offset.fromArray(n), void 0 !== r && ("repeat" === r[0] && (t.wrapS = 1e3), "mirror" === r[0] && (t.wrapS = 1002), "repeat" === r[1] && (t.wrapT = 1e3), "mirror" === r[1] && (t.wrapT = 1002)), void 0 !== s && (t.anisotropy = s), e = fo.generateUUID(), h[e] = t, e } var c, h = {}, l = { uuid: fo.generateUUID(), type: "MeshLambertMaterial" }; for (c in r) { var u = r[c]; switch (c) { case "DbgColor": case "DbgIndex": case "opticalDensity": case "illumination": case "mapDiffuseRepeat": case "mapDiffuseOffset": case "mapDiffuseWrap": case "mapDiffuseAnisotropy": case "mapEmissiveRepeat": case "mapEmissiveOffset": case "mapEmissiveWrap": case "mapEmissiveAnisotropy": case "mapLightRepeat": case "mapLightOffset": case "mapLightWrap": case "mapLightAnisotropy": case "mapAORepeat": case "mapAOOffset": case "mapAOWrap": case "mapAOAnisotropy": case "mapBumpRepeat": case "mapBumpOffset": case "mapBumpWrap": case "mapBumpAnisotropy": case "mapNormalRepeat": case "mapNormalOffset": case "mapNormalWrap": case "mapNormalAnisotropy": case "mapSpecularRepeat": case "mapSpecularOffset": case "mapSpecularWrap": case "mapSpecularAnisotropy": case "mapMetalnessRepeat": case "mapMetalnessOffset": case "mapMetalnessWrap": case "mapMetalnessAnisotropy": case "mapRoughnessRepeat": case "mapRoughnessOffset": case "mapRoughnessWrap": case "mapRoughnessAnisotropy": case "mapAlphaRepeat": case "mapAlphaOffset": case "mapAlphaWrap": case "mapAlphaAnisotropy": break; case "DbgName": l.name = u; break; case "blending": l.blending = t[u]; break; case "colorAmbient": case "mapAmbient": console.warn("THREE.Loader.createMaterial:", c, "is no longer supported."); break; case "colorDiffuse": l.color = e.fromArray(u).getHex(); break; case "colorSpecular": l.specular = e.fromArray(u).getHex(); break; case "colorEmissive": l.emissive = e.fromArray(u).getHex(); break; case "specularCoef": l.shininess = u; break; case "shading": "basic" === u.toLowerCase() && (l.type = "MeshBasicMaterial"), "phong" === u.toLowerCase() && (l.type = "MeshPhongMaterial"), "standard" === u.toLowerCase() && (l.type = "MeshStandardMaterial"); break; case "mapDiffuse": l.map = s(u, r.mapDiffuseRepeat, r.mapDiffuseOffset, r.mapDiffuseWrap, r.mapDiffuseAnisotropy); break; case "mapEmissive": l.emissiveMap = s(u, r.mapEmissiveRepeat, r.mapEmissiveOffset, r.mapEmissiveWrap, r.mapEmissiveAnisotropy); break; case "mapLight": l.lightMap = s(u, r.mapLightRepeat, r.mapLightOffset, r.mapLightWrap, r.mapLightAnisotropy); break; case "mapAO": l.aoMap = s(u, r.mapAORepeat, r.mapAOOffset, r.mapAOWrap, r.mapAOAnisotropy); break; case "mapBump": l.bumpMap = s(u, r.mapBumpRepeat, r.mapBumpOffset, r.mapBumpWrap, r.mapBumpAnisotropy); break; case "mapBumpScale": l.bumpScale = u; break; case "mapNormal": l.normalMap = s(u, r.mapNormalRepeat, r.mapNormalOffset, r.mapNormalWrap, r.mapNormalAnisotropy); break; case "mapNormalFactor": l.normalScale = u; break; case "mapSpecular": l.specularMap = s(u, r.mapSpecularRepeat, r.mapSpecularOffset, r.mapSpecularWrap, r.mapSpecularAnisotropy); break; case "mapMetalness": l.metalnessMap = s(u, r.mapMetalnessRepeat, r.mapMetalnessOffset, r.mapMetalnessWrap, r.mapMetalnessAnisotropy); break; case "mapRoughness": l.roughnessMap = s(u, r.mapRoughnessRepeat, r.mapRoughnessOffset, r.mapRoughnessWrap, r.mapRoughnessAnisotropy); break; case "mapAlpha": l.alphaMap = s(u, r.mapAlphaRepeat, r.mapAlphaOffset, r.mapAlphaWrap, r.mapAlphaAnisotropy); break; case "flipSided": l.side = 1; break; case "doubleSided": l.side = 2; break; case "transparency": console.warn("THREE.Loader.createMaterial: transparency has been renamed to opacity"), l.opacity = u; break; case "depthTest": case "depthWrite": case "colorWrite": case "opacity": case "reflectivity": case "transparent": case "visible": case "wireframe": l[c] = u; break; case "vertexColors": !0 === u && (l.vertexColors = 2), "face" === u && (l.vertexColors = 1); break; default: console.error("THREE.Loader.createMaterial: Unsupported", c, u) } } return "MeshBasicMaterial" === l.type && delete l.emissive, "MeshPhongMaterial" !== l.type && delete l.specular, 1 > l.opacity && (l.transparent = !0), n.setTextures(h), n.parse(l) } }() }); var sa, ca, ha, la = { getContext: function () { return void 0 === sa && (sa = new (window.AudioContext || window.webkitAudioContext)), sa }, setContext: function (t) { sa = t } }; Object.assign(gr.prototype, { load: function (t, e, i, n) { var r = new En(this.manager); r.setResponseType("arraybuffer"), r.setPath(this.path), r.load(t, (function (t) { t = t.slice(0), la.getContext().decodeAudioData(t, (function (t) { e(t) })) }), i, n) }, setPath: function (t) { return this.path = t, this } }), Object.assign(vr.prototype, { isSphericalHarmonics3: !0, set: function (t) { for (var e = 0; 9 > e; e++)this.coefficients[e].copy(t[e]); return this }, zero: function () { for (var t = 0; 9 > t; t++)this.coefficients[t].set(0, 0, 0); return this }, getAt: function (t, e) { var i = t.x, n = t.y; t = t.z; var r = this.coefficients; return e = .282095 * r[0], e += .488603 * r[1] * n, e += .488603 * r[2] * t, e += .488603 * r[3] * i, e += 1.092548 * r[4] * i * n, e += 1.092548 * r[5] * n * t, e += .315392 * r[6] * (3 * t * t - 1), (e += 1.092548 * r[7] * i * t) + .546274 * r[8] * (i * i - n * n) }, getIrradianceAt: function (t, e) { var i = t.x, n = t.y; t = t.z; var r = this.coefficients; return e = .886227 * r[0], e += 1.023328 * r[1] * n, e += 1.023328 * r[2] * t, e += 1.023328 * r[3] * i, e += .858086 * r[4] * i * n, e += .858086 * r[5] * n * t, e += r[6] * (.743125 * t * t - .247708), (e += .858086 * r[7] * i * t) + .429043 * r[8] * (i * i - n * n) }, add: function (t) { for (var e = 0; 9 > e; e++)this.coefficients[e].add(t.coefficients[e]); return this }, scale: function (t) { for (var e = 0; 9 > e; e++)this.coefficients[e].multiplyScalar(t); return this }, lerp: function (t, e) { for (var i = 0; 9 > i; i++)this.coefficients[i].lerp(t.coefficients[i], e); return this }, equals: function (t) { for (var e = 0; 9 > e; e++)if (!this.coefficients[e].equals(t.coefficients[e])) return !1; return !0 }, copy: function (t) { return this.set(t.coefficients) }, clone: function () { return (new this.constructor).copy(this) }, fromArray: function (t) { for (var e = this.coefficients, i = 0; 9 > i; i++)e[i].fromArray(t, 3 * i); return this }, toArray: function () { for (var t = [], e = this.coefficients, i = 0; 9 > i; i++)e[i].toArray(t, 3 * i); return t } }), Object.assign(vr, { getBasisAt: function (t, e) { var i = t.x, n = t.y; t = t.z, e[0] = .282095, e[1] = .488603 * n, e[2] = .488603 * t, e[3] = .488603 * i, e[4] = 1.092548 * i * n, e[5] = 1.092548 * n * t, e[6] = .315392 * (3 * t * t - 1), e[7] = 1.092548 * i * t, e[8] = .546274 * (i * i - n * n) } }), yr.prototype = Object.assign(Object.create(Zn.prototype), { constructor: yr, isLightProbe: !0, copy: function (t) { return Zn.prototype.copy.call(this, t), this.sh.copy(t.sh), this.intensity = t.intensity, this }, toJSON: function (t) { return Zn.prototype.toJSON.call(this, t) } }), xr.prototype = Object.assign(Object.create(yr.prototype), { constructor: xr, isHemisphereLightProbe: !0, copy: function (t) { return yr.prototype.copy.call(this, t), this }, toJSON: function (t) { return yr.prototype.toJSON.call(this, t) } }), br.prototype = Object.assign(Object.create(yr.prototype), { constructor: br, isAmbientLightProbe: !0, copy: function (t) { return yr.prototype.copy.call(this, t), this }, toJSON: function (t) { return yr.prototype.toJSON.call(this, t) } }), Object.assign(wr.prototype, { update: function () { var t, e, i, n, r, o, a, s, c = new g, h = new g; return function (l) { if (t !== this || e !== l.focus || i !== l.fov || n !== l.aspect * this.aspect || r !== l.near || o !== l.far || a !== l.zoom || s !== this.eyeSep) { t = this, e = l.focus, i = l.fov, n = l.aspect * this.aspect, r = l.near, o = l.far, a = l.zoom; var u = l.projectionMatrix.clone(), d = (s = this.eyeSep / 2) * r / e, p = r * Math.tan(fo.DEG2RAD * i * .5) / a; h.elements[12] = -s, c.elements[12] = s; var f = -p * n + d, m = p * n + d; u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraL.projectionMatrix.copy(u), f = -p * n - d, m = p * n - d, u.elements[0] = 2 * r / (m - f), u.elements[8] = (m + f) / (m - f), this.cameraR.projectionMatrix.copy(u) } this.cameraL.matrixWorld.copy(l.matrixWorld).multiply(h), this.cameraR.matrixWorld.copy(l.matrixWorld).multiply(c) } }() }), Mr.prototype = Object.create(A.prototype), Mr.prototype.constructor = Mr, Object.assign(_r.prototype, { start: function () { this.oldTime = this.startTime = ("undefined" == typeof performance ? Date : performance).now(), this.elapsedTime = 0, this.running = !0 }, stop: function () { this.getElapsedTime(), this.autoStart = this.running = !1 }, getElapsedTime: function () { return this.getDelta(), this.elapsedTime }, getDelta: function () { var t = 0; if (this.autoStart && !this.running) return this.start(), 0; if (this.running) { var e = ("undefined" == typeof performance ? Date : performance).now(); t = (e - this.oldTime) / 1e3, this.oldTime = e, this.elapsedTime += t } return t } }), Er.prototype = Object.assign(Object.create(A.prototype), { constructor: Er, getInput: function () { return this.gain }, removeFilter: function () { return null !== this.filter && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this }, getFilter: function () { return this.filter }, setFilter: function (t) { return null !== this.filter ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = t, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this }, getMasterVolume: function () { return this.gain.gain.value }, setMasterVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this }, updateMatrixWorld: function () { var t = new r, e = new n, i = new r, o = new r, a = new _r; return function (n) { A.prototype.updateMatrixWorld.call(this, n), n = this.context.listener; var r = this.up; if (this.timeDelta = a.getDelta(), this.matrixWorld.decompose(t, e, i), o.set(0, 0, -1).applyQuaternion(e), n.positionX) { var s = this.context.currentTime + this.timeDelta; n.positionX.linearRampToValueAtTime(t.x, s), n.positionY.linearRampToValueAtTime(t.y, s), n.positionZ.linearRampToValueAtTime(t.z, s), n.forwardX.linearRampToValueAtTime(o.x, s), n.forwardY.linearRampToValueAtTime(o.y, s), n.forwardZ.linearRampToValueAtTime(o.z, s), n.upX.linearRampToValueAtTime(r.x, s), n.upY.linearRampToValueAtTime(r.y, s), n.upZ.linearRampToValueAtTime(r.z, s) } else n.setPosition(t.x, t.y, t.z), n.setOrientation(o.x, o.y, o.z, r.x, r.y, r.z) } }() }), Ar.prototype = Object.assign(Object.create(A.prototype), { constructor: Ar, getOutput: function () { return this.gain }, setNodeSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = t, this.connect(), this }, setMediaElementSource: function (t) { return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(t), this.connect(), this }, setBuffer: function (t) { return this.buffer = t, this.sourceType = "buffer", this.autoplay && this.play(), this }, play: function () { if (!0 === this.isPlaying) console.warn("THREE.Audio: Audio is already playing."); else { if (!1 !== this.hasPlaybackControl) { var t = this.context.createBufferSource(); return t.buffer = this.buffer, t.loop = this.loop, t.onended = this.onEnded.bind(this), this.startTime = this.context.currentTime, t.start(this.startTime, this.offset), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect() } console.warn("THREE.Audio: this Audio has no playback control.") } }, pause: function () { if (!1 !== this.hasPlaybackControl) return !0 === this.isPlaying && (this.source.stop(), this.source.onended = null, this.offset += (this.context.currentTime - this.startTime) * this.playbackRate, this.isPlaying = !1), this; console.warn("THREE.Audio: this Audio has no playback control.") }, stop: function () { if (!1 !== this.hasPlaybackControl) return this.source.stop(), this.source.onended = null, this.offset = 0, this.isPlaying = !1, this; console.warn("THREE.Audio: this Audio has no playback control.") }, connect: function () { if (0 < this.filters.length) { this.source.connect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].connect(this.filters[t]); this.filters[this.filters.length - 1].connect(this.getOutput()) } else this.source.connect(this.getOutput()); return this }, disconnect: function () { if (0 < this.filters.length) { this.source.disconnect(this.filters[0]); for (var t = 1, e = this.filters.length; t < e; t++)this.filters[t - 1].disconnect(this.filters[t]); this.filters[this.filters.length - 1].disconnect(this.getOutput()) } else this.source.disconnect(this.getOutput()); return this }, getFilters: function () { return this.filters }, setFilters: function (t) { return t || (t = []), !0 === this.isPlaying ? (this.disconnect(), this.filters = t, this.connect()) : this.filters = t, this }, setDetune: function (t) { if (this.detune = t, void 0 !== this.source.detune) return !0 === this.isPlaying && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this }, getDetune: function () { return this.detune }, getFilter: function () { return this.getFilters()[0] }, setFilter: function (t) { return this.setFilters(t ? [t] : []) }, setPlaybackRate: function (t) { if (!1 !== this.hasPlaybackControl) return this.playbackRate = t, !0 === this.isPlaying && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getPlaybackRate: function () { return this.playbackRate }, onEnded: function () { this.isPlaying = !1 }, getLoop: function () { return !1 === this.hasPlaybackControl ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop }, setLoop: function (t) { if (!1 !== this.hasPlaybackControl) return this.loop = t, !0 === this.isPlaying && (this.source.loop = this.loop), this; console.warn("THREE.Audio: this Audio has no playback control.") }, getVolume: function () { return this.gain.gain.value }, setVolume: function (t) { return this.gain.gain.setTargetAtTime(t, this.context.currentTime, .01), this } }), Tr.prototype = Object.assign(Object.create(Ar.prototype), { constructor: Tr, getOutput: function () { return this.panner }, getRefDistance: function () { return this.panner.refDistance }, setRefDistance: function (t) { return this.panner.refDistance = t, this }, getRolloffFactor: function () { return this.panner.rolloffFactor }, setRolloffFactor: function (t) { return this.panner.rolloffFactor = t, this }, getDistanceModel: function () { return this.panner.distanceModel }, setDistanceModel: function (t) { return this.panner.distanceModel = t, this }, getMaxDistance: function () { return this.panner.maxDistance }, setMaxDistance: function (t) { return this.panner.maxDistance = t, this }, setDirectionalCone: function (t, e, i) { return this.panner.coneInnerAngle = t, this.panner.coneOuterAngle = e, this.panner.coneOuterGain = i, this }, updateMatrixWorld: function () { var t = new r, e = new n, i = new r, o = new r; return function (n) { if (A.prototype.updateMatrixWorld.call(this, n), !0 !== this.hasPlaybackControl || !1 !== this.isPlaying) if (this.matrixWorld.decompose(t, e, i), o.set(0, 0, 1).applyQuaternion(e), (n = this.panner).positionX) { var r = this.context.currentTime + this.listener.timeDelta; n.positionX.linearRampToValueAtTime(t.x, r), n.positionY.linearRampToValueAtTime(t.y, r), n.positionZ.linearRampToValueAtTime(t.z, r), n.orientationX.linearRampToValueAtTime(o.x, r), n.orientationY.linearRampToValueAtTime(o.y, r), n.orientationZ.linearRampToValueAtTime(o.z, r) } else n.setPosition(t.x, t.y, t.z), n.setOrientation(o.x, o.y, o.z) } }() }), Object.assign(Sr.prototype, { getFrequencyData: function () { return this.analyser.getByteFrequencyData(this.data), this.data }, getAverageFrequency: function () { for (var t = 0, e = this.getFrequencyData(), i = 0; i < e.length; i++)t += e[i]; return t / e.length } }), Object.assign(Lr.prototype, { accumulate: function (t, e) { var i = this.buffer, n = this.valueSize; t = t * n + n; var r = this.cumulativeWeight; if (0 === r) { for (r = 0; r !== n; ++r)i[t + r] = i[r]; r = e } else r += e, this._mixBufferRegion(i, t, 0, e / r, n); this.cumulativeWeight = r }, apply: function (t) { var e = this.valueSize, i = this.buffer; t = t * e + e; var n = this.cumulativeWeight, r = this.binding; this.cumulativeWeight = 0, 1 > n && this._mixBufferRegion(i, t, 3 * e, 1 - n, e), n = e; for (var o = e + e; n !== o; ++n)if (i[n] !== i[n + e]) { r.setValue(i, t); break } }, saveOriginalState: function () { var t = this.buffer, e = this.valueSize, i = 3 * e; this.binding.getValue(t, i); for (var n = e; n !== i; ++n)t[n] = t[i + n % e]; this.cumulativeWeight = 0 }, restoreOriginalState: function () { this.binding.setValue(this.buffer, 3 * this.valueSize) }, _select: function (t, e, i, n, r) { if (.5 <= n) for (n = 0; n !== r; ++n)t[e + n] = t[i + n] }, _slerp: function (t, e, i, r) { n.slerpFlat(t, e, t, e, t, i, r) }, _lerp: function (t, e, i, n, r) { for (var o = 1 - n, a = 0; a !== r; ++a) { var s = e + a; t[s] = t[s] * o + t[i + a] * n } } }), Object.assign(Cr.prototype, { getValue: function (t, e) { this.bind(); var i = this._bindings[this._targetGroup.nCachedObjects_]; void 0 !== i && i.getValue(t, e) }, setValue: function (t, e) { for (var i = this._bindings, n = this._targetGroup.nCachedObjects_, r = i.length; n !== r; ++n)i[n].setValue(t, e) }, bind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)t[e].bind() }, unbind: function () { for (var t = this._bindings, e = this._targetGroup.nCachedObjects_, i = t.length; e !== i; ++e)t[e].unbind() } }), Object.assign(Rr, { Composite: Cr, create: function (t, e, i) { return t && t.isAnimationObjectGroup ? new Rr.Composite(t, e, i) : new Rr(t, e, i) }, sanitizeNodeName: function () { var t = /[\[\]\.:\/]/g; return function (e) { return e.replace(/\s/g, "_").replace(t, "") } }(), parseTrackName: function () { var t = "[^" + "\\[\\]\\.:\\/".replace("\\.", "") + "]", e = /((?:WC+[\/:])*)/.source.replace("WC", "[^\\[\\]\\.:\\/]"); t = /(WCOD+)?/.source.replace("WCOD", t); var i = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), n = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", "[^\\[\\]\\.:\\/]"), r = new RegExp("^" + e + t + i + n + "$"), o = ["material", "materials", "bones"]; return function (t) { var e = r.exec(t); if (!e) throw Error("PropertyBinding: Cannot parse trackName: " + t); var i = (e = { nodeName: e[2], objectName: e[3], objectIndex: e[4], propertyName: e[5], propertyIndex: e[6] }).nodeName && e.nodeName.lastIndexOf("."); if (void 0 !== i && -1 !== i) { var n = e.nodeName.substring(i + 1); -1 !== o.indexOf(n) && (e.nodeName = e.nodeName.substring(0, i), e.objectName = n) } if (null === e.propertyName || 0 === e.propertyName.length) throw Error("PropertyBinding: can not parse propertyName from trackName: " + t); return e } }(), findNode: function (t, e) { if (!e || "" === e || "root" === e || "." === e || -1 === e || e === t.name || e === t.uuid) return t; if (t.skeleton) { var i = t.skeleton.getBoneByName(e); if (void 0 !== i) return i } if (t.children) { var n = function (t) { for (var i = 0; i < t.length; i++) { var r = t[i]; if (r.name === e || r.uuid === e || (r = n(r.children))) return r } return null }; if (t = n(t.children)) return t } return null } }), Object.assign(Rr.prototype, { _getValue_unavailable: function () { }, _setValue_unavailable: function () { }, BindingType: { Direct: 0, EntireArray: 1, ArrayElement: 2, HasFromToArray: 3 }, Versioning: { None: 0, NeedsUpdate: 1, MatrixWorldNeedsUpdate: 2 }, GetterByBindingType: [function (t, e) { t[e] = this.node[this.propertyName] }, function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)t[e++] = i[n] }, function (t, e) { t[e] = this.resolvedProperty[this.propertyIndex] }, function (t, e) { this.resolvedProperty.toArray(t, e) }], SetterByBindingTypeAndVersioning: [[function (t, e) { this.targetObject[this.propertyName] = t[e] }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.targetObject[this.propertyName] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = t[e++] }, function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = t[e++]; this.targetObject.needsUpdate = !0 }, function (t, e) { for (var i = this.resolvedProperty, n = 0, r = i.length; n !== r; ++n)i[n] = t[e++]; this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e] }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty[this.propertyIndex] = t[e], this.targetObject.matrixWorldNeedsUpdate = !0 }], [function (t, e) { this.resolvedProperty.fromArray(t, e) }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.needsUpdate = !0 }, function (t, e) { this.resolvedProperty.fromArray(t, e), this.targetObject.matrixWorldNeedsUpdate = !0 }]], getValue: function (t, e) { this.bind(), this.getValue(t, e) }, setValue: function (t, e) { this.bind(), this.setValue(t, e) }, bind: function () { var t = this.node, e = this.parsedPath, i = e.objectName, n = e.propertyName, r = e.propertyIndex; if (t || (this.node = t = Rr.findNode(this.rootNode, e.nodeName) || this.rootNode), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, t) { if (i) { var o = e.objectIndex; switch (i) { case "materials": if (!t.material) return void console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this); if (!t.material.materials) return void console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this); t = t.material.materials; break; case "bones": if (!t.skeleton) return void console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this); for (t = t.skeleton.bones, i = 0; i < t.length; i++)if (t[i].name === o) { o = i; break } break; default: if (void 0 === t[i]) return void console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this); t = t[i] }if (void 0 !== o) { if (void 0 === t[o]) return void console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, t); t = t[o] } } if (void 0 === (o = t[n])) console.error("THREE.PropertyBinding: Trying to update property for track: " + e.nodeName + "." + n + " but it wasn't found.", t); else { if (e = this.Versioning.None, this.targetObject = t, void 0 !== t.needsUpdate ? e = this.Versioning.NeedsUpdate : void 0 !== t.matrixWorldNeedsUpdate && (e = this.Versioning.MatrixWorldNeedsUpdate), i = this.BindingType.Direct, void 0 !== r) { if ("morphTargetInfluences" === n) { if (!t.geometry) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this); if (t.geometry.isBufferGeometry) { if (!t.geometry.morphAttributes) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this); for (i = 0; i < this.node.geometry.morphAttributes.position.length; i++)if (t.geometry.morphAttributes.position[i].name === r) { r = i; break } } else { if (!t.geometry.morphTargets) return void console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.", this); for (i = 0; i < this.node.geometry.morphTargets.length; i++)if (t.geometry.morphTargets[i].name === r) { r = i; break } } } i = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = r } else void 0 !== o.fromArray && void 0 !== o.toArray ? (i = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (i = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = n; this.getValue = this.GetterByBindingType[i], this.setValue = this.SetterByBindingTypeAndVersioning[i][e] } } else console.error("THREE.PropertyBinding: Trying to update node for track: " + this.path + " but it wasn't found.") }, unbind: function () { this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound } }), Object.assign(Rr.prototype, { _getValue_unbound: Rr.prototype.getValue, _setValue_unbound: Rr.prototype.setValue }), Object.assign(Pr.prototype, { isAnimationObjectGroup: !0, add: function () { for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._paths, o = this._parsedPaths, a = this._bindings, s = a.length, c = void 0, h = 0, l = arguments.length; h !== l; ++h) { var u = arguments[h], d = u.uuid, p = n[d]; if (void 0 === p) { p = e++, n[d] = p, t.push(u), d = 0; for (var f = s; d !== f; ++d)a[d].push(new Rr(u, r[d], o[d])) } else if (p < i) { c = t[p]; var m = --i; for (n[(f = t[m]).uuid] = p, t[p] = f, n[d] = m, t[m] = u, d = 0, f = s; d !== f; ++d) { var g = a[d], v = g[p]; g[p] = g[m], void 0 === v && (v = new Rr(u, r[d], o[d])), g[m] = v } } else t[p] !== c && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.") } this.nCachedObjects_ = i }, remove: function () { for (var t = this._objects, e = this.nCachedObjects_, i = this._indicesByUUID, n = this._bindings, r = n.length, o = 0, a = arguments.length; o !== a; ++o) { var s = arguments[o], c = s.uuid, h = i[c]; if (void 0 !== h && h >= e) { var l = e++, u = t[l]; for (i[u.uuid] = h, t[h] = u, i[c] = l, t[l] = s, s = 0, c = r; s !== c; ++s) { var d = (u = n[s])[h]; u[h] = u[l], u[l] = d } } } this.nCachedObjects_ = e }, uncache: function () { for (var t = this._objects, e = t.length, i = this.nCachedObjects_, n = this._indicesByUUID, r = this._bindings, o = r.length, a = 0, s = arguments.length; a !== s; ++a) { var c = arguments[a].uuid, h = n[c]; if (void 0 !== h) if (delete n[c], h < i) { var l = t[c = --i], u = --e, d = t[u]; for (n[l.uuid] = h, t[h] = l, n[d.uuid] = c, t[c] = d, t.pop(), l = 0, d = o; l !== d; ++l) { var p = r[l], f = p[u]; p[h] = p[c], p[c] = f, p.pop() } } else for (n[(d = t[u = --e]).uuid] = h, t[h] = d, t.pop(), l = 0, d = o; l !== d; ++l)(p = r[l])[h] = p[u], p.pop() } this.nCachedObjects_ = i }, subscribe_: function (t, e) { var i = this._bindingsIndicesByPath, n = i[t], r = this._bindings; if (void 0 !== n) return r[n]; var o = this._paths, a = this._parsedPaths, s = this._objects, c = this.nCachedObjects_, h = Array(s.length); for (n = r.length, i[t] = n, o.push(t), a.push(e), r.push(h), i = c, n = s.length; i !== n; ++i)h[i] = new Rr(s[i], t, e); return h }, unsubscribe_: function (t) { var e = this._bindingsIndicesByPath, i = e[t]; if (void 0 !== i) { var n = this._paths, r = this._parsedPaths, o = this._bindings, a = o.length - 1, s = o[a]; e[t[a]] = i, o[i] = s, o.pop(), r[i] = r[a], r.pop(), n[i] = n[a], n.pop() } } }), Object.assign(Ir.prototype, { play: function () { return this._mixer._activateAction(this), this }, stop: function () { return this._mixer._deactivateAction(this), this.reset() }, reset: function () { return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping() }, isRunning: function () { return this.enabled && !this.paused && 0 !== this.timeScale && null === this._startTime && this._mixer._isActiveAction(this) }, isScheduled: function () { return this._mixer._isActiveAction(this) }, startAt: function (t) { return this._startTime = t, this }, setLoop: function (t, e) { return this.loop = t, this.repetitions = e, this }, setEffectiveWeight: function (t) { return this.weight = t, this._effectiveWeight = this.enabled ? t : 0, this.stopFading() }, getEffectiveWeight: function () { return this._effectiveWeight }, fadeIn: function (t) { return this._scheduleFading(t, 0, 1) }, fadeOut: function (t) { return this._scheduleFading(t, 1, 0) }, crossFadeFrom: function (t, e, i) { if (t.fadeOut(e), this.fadeIn(e), i) { i = this._clip.duration; var n = t._clip.duration, r = i / n; t.warp(1, n / i, e), this.warp(r, 1, e) } return this }, crossFadeTo: function (t, e, i) { return t.crossFadeFrom(this, e, i) }, stopFading: function () { var t = this._weightInterpolant; return null !== t && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, setEffectiveTimeScale: function (t) { return this.timeScale = t, this._effectiveTimeScale = this.paused ? 0 : t, this.stopWarping() }, getEffectiveTimeScale: function () { return this._effectiveTimeScale }, setDuration: function (t) { return this.timeScale = this._clip.duration / t, this.stopWarping() }, syncWith: function (t) { return this.time = t.time, this.timeScale = t.timeScale, this.stopWarping() }, halt: function (t) { return this.warp(this._effectiveTimeScale, 0, t) }, warp: function (t, e, i) { var n = this._mixer, r = n.time, o = this._timeScaleInterpolant, a = this.timeScale; return null === o && (this._timeScaleInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, n[1] = r + i, o[0] = t / a, o[1] = e / a, this }, stopWarping: function () { var t = this._timeScaleInterpolant; return null !== t && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(t)), this }, getMixer: function () { return this._mixer }, getClip: function () { return this._clip }, getRoot: function () { return this._localRoot || this._mixer._root }, _update: function (t, e, i, n) { if (this.enabled) { var r = this._startTime; if (null !== r) { if (0 > (e = (t - r) * i) || 0 === i) return; this._startTime = null, e *= i } if (e *= this._updateTimeScale(t), i = this._updateTime(e), 0 < (t = this._updateWeight(t))) { e = this._interpolants, r = this._propertyBindings; for (var o = 0, a = e.length; o !== a; ++o)e[o].evaluate(i), r[o].accumulate(n, t) } } else this._updateWeight(t) }, _updateWeight: function (t) { var e = 0; if (this.enabled) { e = this.weight; var i = this._weightInterpolant; if (null !== i) { var n = i.evaluate(t)[0]; e *= n, t > i.parameterPositions[1] && (this.stopFading(), 0 === n && (this.enabled = !1)) } } return this._effectiveWeight = e }, _updateTimeScale: function (t) { var e = 0; if (!this.paused) { e = this.timeScale; var i = this._timeScaleInterpolant; if (null !== i) e *= i.evaluate(t)[0], t > i.parameterPositions[1] && (this.stopWarping(), 0 === e ? this.paused = !0 : this.timeScale = e) } return this._effectiveTimeScale = e }, _updateTime: function (t) { var e = this.time + t, i = this._clip.duration, n = this.loop, r = this._loopCount, o = 2202 === n; if (0 === t) return -1 === r ? e : o && 1 == (1 & r) ? i - e : e; if (2200 === n) t: { if (-1 === r && (this._loopCount = 0, this._setEndings(!0, !0, !1)), e >= i) e = i; else { if (!(0 > e)) { this.time = e; break t } e = 0 } this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = e, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 > t ? -1 : 1 }) } else { if (-1 === r && (0 <= t ? (r = 0, this._setEndings(!0, 0 === this.repetitions, o)) : this._setEndings(0 === this.repetitions, !0, o)), e >= i || 0 > e) { e -= i * (n = Math.floor(e / i)), r += Math.abs(n); var a = this.repetitions - r; 0 >= a ? (this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, this.time = e = 0 < t ? i : 0, this._mixer.dispatchEvent({ type: "finished", action: this, direction: 0 < t ? 1 : -1 })) : (1 === a ? (t = 0 > t, this._setEndings(t, !t, o)) : this._setEndings(!1, !1, o), this._loopCount = r, this.time = e, this._mixer.dispatchEvent({ type: "loop", action: this, loopDelta: n })) } else this.time = e; if (o && 1 == (1 & r)) return i - e } return e }, _setEndings: function (t, e, i) { var n = this._interpolantSettings; i ? (n.endingStart = 2401, n.endingEnd = 2401) : (n.endingStart = t ? this.zeroSlopeAtStart ? 2401 : 2400 : 2402, n.endingEnd = e ? this.zeroSlopeAtEnd ? 2401 : 2400 : 2402) }, _scheduleFading: function (t, e, i) { var n = this._mixer, r = n.time, o = this._weightInterpolant; return null === o && (this._weightInterpolant = o = n._lendControlInterpolant()), n = o.parameterPositions, o = o.sampleValues, n[0] = r, o[0] = e, n[1] = r + t, o[1] = i, this } }), Or.prototype = Object.assign(Object.create(e.prototype), { constructor: Or, _bindAction: function (t, e) { var i = t._localRoot || this._root, n = t._clip.tracks, r = n.length, o = t._propertyBindings; t = t._interpolants; var a = i.uuid, s = this._bindingsByRootAndName, c = s[a]; for (void 0 === c && (c = {}, s[a] = c), s = 0; s !== r; ++s) { var h = n[s], l = h.name, u = c[l]; if (void 0 === u) { if (void 0 !== (u = o[s])) { null === u._cacheIndex && (++u.referenceCount, this._addInactiveBinding(u, a, l)); continue } ++(u = new Lr(Rr.create(i, l, e && e._propertyBindings[s].binding.parsedPath), h.ValueTypeName, h.getValueSize())).referenceCount, this._addInactiveBinding(u, a, l) } o[s] = u, t[s].resultBuffer = u.buffer } }, _activateAction: function (t) { if (!this._isActiveAction(t)) { if (null === t._cacheIndex) { var e = (t._localRoot || this._root).uuid, i = t._clip.uuid, n = this._actionsByClip[i]; this._bindAction(t, n && n.knownActions[0]), this._addInactiveAction(t, i, e) } for (i = 0, n = (e = t._propertyBindings).length; i !== n; ++i) { var r = e[i]; 0 == r.useCount++ && (this._lendBinding(r), r.saveOriginalState()) } this._lendAction(t) } }, _deactivateAction: function (t) { if (this._isActiveAction(t)) { for (var e = t._propertyBindings, i = 0, n = e.length; i !== n; ++i) { var r = e[i]; 0 == --r.useCount && (r.restoreOriginalState(), this._takeBackBinding(r)) } this._takeBackAction(t) } }, _initMemoryManager: function () { this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0; var t = this; this.stats = { actions: { get total() { return t._actions.length }, get inUse() { return t._nActiveActions } }, bindings: { get total() { return t._bindings.length }, get inUse() { return t._nActiveBindings } }, controlInterpolants: { get total() { return t._controlInterpolants.length }, get inUse() { return t._nActiveControlInterpolants } } } }, _isActiveAction: function (t) { return null !== (t = t._cacheIndex) && t < this._nActiveActions }, _addInactiveAction: function (t, e, i) { var n = this._actions, r = this._actionsByClip, o = r[e]; void 0 === o ? (o = { knownActions: [t], actionByRoot: {} }, t._byClipCacheIndex = 0, r[e] = o) : (e = o.knownActions, t._byClipCacheIndex = e.length, e.push(t)), t._cacheIndex = n.length, n.push(t), o.actionByRoot[i] = t }, _removeInactiveAction: function (t) { var e = this._actions, i = e[e.length - 1], n = t._cacheIndex; i._cacheIndex = n, e[n] = i, e.pop(), t._cacheIndex = null, e = t._clip.uuid; var r = (n = (i = this._actionsByClip)[e]).knownActions, o = r[r.length - 1], a = t._byClipCacheIndex; o._byClipCacheIndex = a, r[a] = o, r.pop(), t._byClipCacheIndex = null, delete n.actionByRoot[(t._localRoot || this._root).uuid], 0 === r.length && delete i[e], this._removeInactiveBindingsForAction(t) }, _removeInactiveBindingsForAction: function (t) { for (var e = 0, i = (t = t._propertyBindings).length; e !== i; ++e) { var n = t[e]; 0 == --n.referenceCount && this._removeInactiveBinding(n) } }, _lendAction: function (t) { var e = this._actions, i = t._cacheIndex, n = this._nActiveActions++, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _takeBackAction: function (t) { var e = this._actions, i = t._cacheIndex, n = --this._nActiveActions, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _addInactiveBinding: function (t, e, i) { var n = this._bindingsByRootAndName, r = n[e], o = this._bindings; void 0 === r && (r = {}, n[e] = r), r[i] = t, t._cacheIndex = o.length, o.push(t) }, _removeInactiveBinding: function (t) { var e = this._bindings, i = t.binding, n = i.rootNode.uuid; i = i.path; var r = this._bindingsByRootAndName, o = r[n], a = e[e.length - 1]; t = t._cacheIndex, a._cacheIndex = t, e[t] = a, e.pop(), delete o[i]; t: { for (var s in o) break t; delete r[n] } }, _lendBinding: function (t) { var e = this._bindings, i = t._cacheIndex, n = this._nActiveBindings++, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _takeBackBinding: function (t) { var e = this._bindings, i = t._cacheIndex, n = --this._nActiveBindings, r = e[n]; t._cacheIndex = n, e[n] = t, r._cacheIndex = i, e[i] = r }, _lendControlInterpolant: function () { var t = this._controlInterpolants, e = this._nActiveControlInterpolants++, i = t[e]; return void 0 === i && ((i = new un(new Float32Array(2), new Float32Array(2), 1, this._controlInterpolantsResultBuffer)).__cacheIndex = e, t[e] = i), i }, _takeBackControlInterpolant: function (t) { var e = this._controlInterpolants, i = t.__cacheIndex, n = --this._nActiveControlInterpolants, r = e[n]; t.__cacheIndex = n, e[n] = t, r.__cacheIndex = i, e[i] = r }, _controlInterpolantsResultBuffer: new Float32Array(1), clipAction: function (t, e) { var i = e || this._root, n = i.uuid; t = null !== (i = "string" == typeof t ? wn.findByName(i, t) : t) ? i.uuid : t; var r = this._actionsByClip[t], o = null; if (void 0 !== r) { if (void 0 !== (o = r.actionByRoot[n])) return o; o = r.knownActions[0], null === i && (i = o._clip) } return null === i ? null : (e = new Ir(this, i, e), this._bindAction(e, o), this._addInactiveAction(e, t, n), e) }, existingAction: function (t, e) { var i = e || this._root; return e = i.uuid, i = "string" == typeof t ? wn.findByName(i, t) : t, void 0 !== (t = this._actionsByClip[i ? i.uuid : t]) && t.actionByRoot[e] || null }, stopAllAction: function () { for (var t = this._actions, e = this._nActiveActions, i = this._bindings, n = this._nActiveBindings, r = this._nActiveBindings = this._nActiveActions = 0; r !== e; ++r)t[r].reset(); for (r = 0; r !== n; ++r)i[r].useCount = 0; return this }, update: function (t) { t *= this.timeScale; for (var e = this._actions, i = this._nActiveActions, n = this.time += t, r = Math.sign(t), o = this._accuIndex ^= 1, a = 0; a !== i; ++a)e[a]._update(n, t, r, o); for (t = this._bindings, e = this._nActiveBindings, a = 0; a !== e; ++a)t[a].apply(o); return this }, getRoot: function () { return this._root }, uncacheClip: function (t) { var e = this._actions; t = t.uuid; var i = this._actionsByClip, n = i[t]; if (void 0 !== n) { for (var r = 0, o = (n = n.knownActions).length; r !== o; ++r) { var a = n[r]; this._deactivateAction(a); var s = a._cacheIndex, c = e[e.length - 1]; a._cacheIndex = null, a._byClipCacheIndex = null, c._cacheIndex = s, e[s] = c, e.pop(), this._removeInactiveBindingsForAction(a) } delete i[t] } }, uncacheRoot: function (t) { t = t.uuid; var e = this._actionsByClip; for (n in e) { var i = e[n].actionByRoot[t]; void 0 !== i && (this._deactivateAction(i), this._removeInactiveAction(i)) } var n = this._bindingsByRootAndName[t]; if (void 0 !== n) for (var r in n) (t = n[r]).restoreOriginalState(), this._removeInactiveBinding(t) }, uncacheAction: function (t, e) { null !== (t = this.existingAction(t, e)) && (this._deactivateAction(t), this._removeInactiveAction(t)) } }), Dr.prototype.clone = function () { return new Dr(void 0 === this.value.clone ? this.value : this.value.clone()) }, Nr.prototype = Object.assign(Object.create(Re.prototype), { constructor: Nr, isInstancedInterleavedBuffer: !0, copy: function (t) { return Re.prototype.copy.call(this, t), this.meshPerAttribute = t.meshPerAttribute, this } }), Object.assign(Br.prototype, { linePrecision: 1, set: function (t, e) { this.ray.set(t, e) }, setFromCamera: function (t, e) { e && e.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(t.x, t.y, .5).unproject(e).sub(this.ray.origin).normalize()) : e && e.isOrthographicCamera ? (this.ray.origin.set(t.x, t.y, (e.near + e.far) / (e.near - e.far)).unproject(e), this.ray.direction.set(0, 0, -1).transformDirection(e.matrixWorld)) : console.error("THREE.Raycaster: Unsupported camera type.") }, intersectObject: function (t, e, i) { return Ur(t, this, i = i || [], e), i.sort(zr), i }, intersectObjects: function (t, e, i) { if (i = i || [], !1 === Array.isArray(t)) return console.warn("THREE.Raycaster.intersectObjects: objects is not an Array."), i; for (var n = 0, r = t.length; n < r; n++)Ur(t[n], this, i, e); return i.sort(zr), i } }), Object.assign(Fr.prototype, { set: function (t, e, i) { return this.radius = t, this.phi = e, this.theta = i, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.phi = t.phi, this.theta = t.theta, this }, makeSafe: function () { return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, i) { return this.radius = Math.sqrt(t * t + e * e + i * i), 0 === this.radius ? this.phi = this.theta = 0 : (this.theta = Math.atan2(t, i), this.phi = Math.acos(fo.clamp(e / this.radius, -1, 1))), this } }), Object.assign(Gr.prototype, { set: function (t, e, i) { return this.radius = t, this.theta = e, this.y = i, this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.radius = t.radius, this.theta = t.theta, this.y = t.y, this }, setFromVector3: function (t) { return this.setFromCartesianCoords(t.x, t.y, t.z) }, setFromCartesianCoords: function (t, e, i) { return this.radius = Math.sqrt(t * t + i * i), this.theta = Math.atan2(t, i), this.y = e, this } }), Object.assign(Hr.prototype, { set: function (t, e) { return this.min.copy(t), this.max.copy(e), this }, setFromPoints: function (t) { this.makeEmpty(); for (var e = 0, i = t.length; e < i; e++)this.expandByPoint(t[e]); return this }, setFromCenterAndSize: function () { var t = new i; return function (e, i) { return i = t.copy(i).multiplyScalar(.5), this.min.copy(e).sub(i), this.max.copy(e).add(i), this } }(), clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.min.copy(t.min), this.max.copy(t.max), this }, makeEmpty: function () { return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this }, isEmpty: function () { return this.max.x < this.min.x || this.max.y < this.min.y }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getCenter() target is now required"), t = new i), this.isEmpty() ? t.set(0, 0) : t.addVectors(this.min, this.max).multiplyScalar(.5) }, getSize: function (t) { return void 0 === t && (console.warn("THREE.Box2: .getSize() target is now required"), t = new i), this.isEmpty() ? t.set(0, 0) : t.subVectors(this.max, this.min) }, expandByPoint: function (t) { return this.min.min(t), this.max.max(t), this }, expandByVector: function (t) { return this.min.sub(t), this.max.add(t), this }, expandByScalar: function (t) { return this.min.addScalar(-t), this.max.addScalar(t), this }, containsPoint: function (t) { return !(t.x < this.min.x || t.x > this.max.x || t.y < this.min.y || t.y > this.max.y) }, containsBox: function (t) { return this.min.x <= t.min.x && t.max.x <= this.max.x && this.min.y <= t.min.y && t.max.y <= this.max.y }, getParameter: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .getParameter() target is now required"), e = new i), e.set((t.x - this.min.x) / (this.max.x - this.min.x), (t.y - this.min.y) / (this.max.y - this.min.y)) }, intersectsBox: function (t) { return !(t.max.x < this.min.x || t.min.x > this.max.x || t.max.y < this.min.y || t.min.y > this.max.y) }, clampPoint: function (t, e) { return void 0 === e && (console.warn("THREE.Box2: .clampPoint() target is now required"), e = new i), e.copy(t).clamp(this.min, this.max) }, distanceToPoint: function () { var t = new i; return function (e) { return t.copy(e).clamp(this.min, this.max).sub(e).length() } }(), intersect: function (t) { return this.min.max(t.min), this.max.min(t.max), this }, union: function (t) { return this.min.min(t.min), this.max.max(t.max), this }, translate: function (t) { return this.min.add(t), this.max.add(t), this }, equals: function (t) { return t.min.equals(this.min) && t.max.equals(this.max) } }), Object.assign(kr.prototype, { set: function (t, e) { return this.start.copy(t), this.end.copy(e), this }, clone: function () { return (new this.constructor).copy(this) }, copy: function (t) { return this.start.copy(t.start), this.end.copy(t.end), this }, getCenter: function (t) { return void 0 === t && (console.warn("THREE.Line3: .getCenter() target is now required"), t = new r), t.addVectors(this.start, this.end).multiplyScalar(.5) }, delta: function (t) { return void 0 === t && (console.warn("THREE.Line3: .delta() target is now required"), t = new r), t.subVectors(this.end, this.start) }, distanceSq: function () { return this.start.distanceToSquared(this.end) }, distance: function () { return this.start.distanceTo(this.end) }, at: function (t, e) { return void 0 === e && (console.warn("THREE.Line3: .at() target is now required"), e = new r), this.delta(e).multiplyScalar(t).add(this.start) }, closestPointToPointParameter: function () { var t = new r, e = new r; return function (i, n) { return t.subVectors(i, this.start), e.subVectors(this.end, this.start), i = e.dot(e), i = e.dot(t) / i, n && (i = fo.clamp(i, 0, 1)), i } }(), closestPointToPoint: function (t, e, i) { return t = this.closestPointToPointParameter(t, e), void 0 === i && (console.warn("THREE.Line3: .closestPointToPoint() target is now required"), i = new r), this.delta(i).multiplyScalar(t).add(this.start) }, applyMatrix4: function (t) { return this.start.applyMatrix4(t), this.end.applyMatrix4(t), this }, equals: function (t) { return t.start.equals(this.start) && t.end.equals(this.end) } }), Vr.prototype = Object.create(A.prototype), Vr.prototype.constructor = Vr, Vr.prototype.isImmediateRenderObject = !0, jr.prototype = Object.create(Ge.prototype), jr.prototype.constructor = jr, jr.prototype.update = function () { var t = new r, e = new r, i = new o; return function () { var n = ["a", "b", "c"]; this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld); var r = this.object.matrixWorld, o = this.geometry.attributes.position, a = this.object.geometry; if (a && a.isGeometry) for (var s = a.vertices, c = a.faces, h = a = 0, l = c.length; h < l; h++)for (var u = c[h], d = 0, p = u.vertexNormals.length; d < p; d++) { var f = u.vertexNormals[d]; t.copy(s[u[n[d]]]).applyMatrix4(r), e.copy(f).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(a, t.x, t.y, t.z), a += 1, o.setXYZ(a, e.x, e.y, e.z), a += 1 } else if (a && a.isBufferGeometry) for (n = a.attributes.position, s = a.attributes.normal, d = a = 0, p = n.count; d < p; d++)t.set(n.getX(d), n.getY(d), n.getZ(d)).applyMatrix4(r), e.set(s.getX(d), s.getY(d), s.getZ(d)), e.applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), o.setXYZ(a, t.x, t.y, t.z), a += 1, o.setXYZ(a, e.x, e.y, e.z), a += 1; o.needsUpdate = !0 } }(), Wr.prototype = Object.create(A.prototype), Wr.prototype.constructor = Wr, Wr.prototype.dispose = function () { this.cone.geometry.dispose(), this.cone.material.dispose() }, Wr.prototype.update = function () { var t = new r; return function () { this.light.updateMatrixWorld(); var e = this.light.distance ? this.light.distance : 1e3, i = e * Math.tan(this.light.angle); this.cone.scale.set(i, i, e), t.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(t), void 0 !== this.color ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color) } }(), Xr.prototype = Object.create(Ge.prototype), Xr.prototype.constructor = Xr, Xr.prototype.updateMatrixWorld = function () { var t = new r, e = new g, i = new g; return function (n) { var r = this.bones, o = this.geometry, a = o.getAttribute("position"); i.getInverse(this.root.matrixWorld); for (var s = 0, c = 0; s < r.length; s++) { var h = r[s]; h.parent && h.parent.isBone && (e.multiplyMatrices(i, h.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c, t.x, t.y, t.z), e.multiplyMatrices(i, h.parent.matrixWorld), t.setFromMatrixPosition(e), a.setXYZ(c + 1, t.x, t.y, t.z), c += 2) } o.getAttribute("position").needsUpdate = !0, A.prototype.updateMatrixWorld.call(this, n) } }(), Yr.prototype = Object.create(Z.prototype), Yr.prototype.constructor = Yr, Yr.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Yr.prototype.update = function () { void 0 !== this.color ? this.material.color.set(this.color) : this.material.color.copy(this.light.color) }, Zr.prototype = Object.create(Fe.prototype), Zr.prototype.constructor = Zr, Zr.prototype.update = function () { if (this.scale.set(.5 * this.light.width, .5 * this.light.height, 1), void 0 !== this.color) this.material.color.set(this.color), this.children[0].material.color.set(this.color); else { this.material.color.copy(this.light.color).multiplyScalar(this.light.intensity); var t = this.material.color, e = Math.max(t.r, t.g, t.b); 1 < e && t.multiplyScalar(1 / e), this.children[0].material.color.copy(this.material.color) } }, Zr.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose() }, Jr.prototype = Object.create(A.prototype), Jr.prototype.constructor = Jr, Jr.prototype.dispose = function () { this.children[0].geometry.dispose(), this.children[0].material.dispose() }, Jr.prototype.update = function () { var t = new r, e = new x, i = new x; return function () { var n = this.children[0]; if (void 0 !== this.color) this.material.color.set(this.color); else { var r = n.geometry.getAttribute("color"); e.copy(this.light.color), i.copy(this.light.groundColor); for (var o = 0, a = r.count; o < a; o++) { var s = o < a / 2 ? e : i; r.setXYZ(o, s.r, s.g, s.b) } r.needsUpdate = !0 } n.lookAt(t.setFromMatrixPosition(this.light.matrixWorld).negate()) } }(), Qr.prototype = Object.create(Z.prototype), Qr.prototype.constructor = Qr, Qr.prototype.dispose = function () { this.geometry.dispose(), this.material.dispose() }, Qr.prototype.onBeforeRender = function () { this.position.copy(this.lightProbe.position), this.scale.set(1, 1, 1).multiplyScalar(this.size), this.material.uniforms.intensity.value = this.lightProbe.intensity }, Kr.prototype = Object.assign(Object.create(Ge.prototype), { constructor: Kr, copy: function (t) { return Ge.prototype.copy.call(this, t), this.geometry.copy(t.geometry), this.material.copy(t.material), this }, clone: function () { return (new this.constructor).copy(this) } }), $r.prototype = Object.create(Ge.prototype), $r.prototype.constructor = $r, to.prototype = Object.create(Fe.prototype), to.prototype.constructor = to, to.prototype.update = function () { function t(t, n, o, a) { for (o = (n - t) / o, p.setXYZ(l, 0, 0, 0), u++, e = t; e < n; e += o)i = l + u, p.setXYZ(i, Math.sin(e) * r, 0, Math.cos(e) * r), p.setXYZ(i + 1, Math.sin(Math.min(e + o, n)) * r, 0, Math.cos(Math.min(e + o, n)) * r), p.setXYZ(i + 2, 0, 0, 0), u += 3; d.addGroup(l, u, a), l += u, u = 0 } var e, i, n = this.audio, r = this.range, o = this.divisionsInnerAngle, a = this.divisionsOuterAngle, s = fo.degToRad(n.panner.coneInnerAngle), c = s / 2, h = (n = fo.degToRad(n.panner.coneOuterAngle)) / 2, l = 0, u = 0, d = this.geometry, p = d.attributes.position; d.clearGroups(), t(-h, -c, a, 0), t(-c, c, o, 1), t(c, h, a, 0), p.needsUpdate = !0, s === n && (this.material[0].visible = !1) }, to.prototype.dispose = function () { this.geometry.dispose(), this.material[0].dispose(), this.material[1].dispose() }, eo.prototype = Object.create(Ge.prototype), eo.prototype.constructor = eo, eo.prototype.update = function () { var t = new r, e = new r, i = new o; return function () { this.object.updateMatrixWorld(!0), i.getNormalMatrix(this.object.matrixWorld); for (var n = this.object.matrixWorld, r = this.geometry.attributes.position, o = this.object.geometry, a = o.vertices, s = 0, c = 0, h = (o = o.faces).length; c < h; c++) { var l = o[c], u = l.normal; t.copy(a[l.a]).add(a[l.b]).add(a[l.c]).divideScalar(3).applyMatrix4(n), e.copy(u).applyMatrix3(i).normalize().multiplyScalar(this.size).add(t), r.setXYZ(s, t.x, t.y, t.z), s += 1, r.setXYZ(s, e.x, e.y, e.z), s += 1 } r.needsUpdate = !0 } }(), io.prototype = Object.create(A.prototype), io.prototype.constructor = io, io.prototype.dispose = function () { this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose() }, io.prototype.update = function () { var t = new r, e = new r, i = new r; return function () { t.setFromMatrixPosition(this.light.matrixWorld), e.setFromMatrixPosition(this.light.target.matrixWorld), i.subVectors(e, t), this.lightPlane.lookAt(e), void 0 !== this.color ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(e), this.targetLine.scale.z = i.length() } }(), no.prototype = Object.create(Ge.prototype), no.prototype.constructor = no, no.prototype.update = function () { function t(t, r, a, s) { if (n.set(r, a, s).unproject(o), void 0 !== (t = i[t])) for (r = e.getAttribute("position"), a = 0, s = t.length; a < s; a++)r.setXYZ(t[a], n.x, n.y, n.z) } var e, i, n = new r, o = new be; return function () { e = this.geometry, i = this.pointMap, o.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), t("c", 0, 0, -1), t("t", 0, 0, 1), t("n1", -1, -1, -1), t("n2", 1, -1, -1), t("n3", -1, 1, -1), t("n4", 1, 1, -1), t("f1", -1, -1, 1), t("f2", 1, -1, 1), t("f3", -1, 1, 1), t("f4", 1, 1, 1), t("u1", .7, 1.1, -1), t("u2", -.7, 1.1, -1), t("u3", 0, 2, -1), t("cf1", -1, 0, 1), t("cf2", 1, 0, 1), t("cf3", 0, -1, 1), t("cf4", 0, 1, 1), t("cn1", -1, 0, -1), t("cn2", 1, 0, -1), t("cn3", 0, -1, -1), t("cn4", 0, 1, -1), e.getAttribute("position").needsUpdate = !0 } }(), ro.prototype = Object.create(Ge.prototype), ro.prototype.constructor = ro, ro.prototype.update = function () { var t = new d; return function (e) { if (void 0 !== e && console.warn("THREE.BoxHelper: .update() has no longer arguments."), void 0 !== this.object && t.setFromObject(this.object), !t.isEmpty()) { e = t.min; var i = t.max, n = this.geometry.attributes.position, r = n.array; r[0] = i.x, r[1] = i.y, r[2] = i.z, r[3] = e.x, r[4] = i.y, r[5] = i.z, r[6] = e.x, r[7] = e.y, r[8] = i.z, r[9] = i.x, r[10] = e.y, r[11] = i.z, r[12] = i.x, r[13] = i.y, r[14] = e.z, r[15] = e.x, r[16] = i.y, r[17] = e.z, r[18] = e.x, r[19] = e.y, r[20] = e.z, r[21] = i.x, r[22] = e.y, r[23] = e.z, n.needsUpdate = !0, this.geometry.computeBoundingSphere() } } }(), ro.prototype.setFromObject = function (t) { return this.object = t, this.update(), this }, ro.prototype.copy = function (t) { return Ge.prototype.copy.call(this, t), this.object = t.object, this }, ro.prototype.clone = function () { return (new this.constructor).copy(this) }, oo.prototype = Object.create(Ge.prototype), oo.prototype.constructor = oo, oo.prototype.updateMatrixWorld = function (t) { var e = this.box; e.isEmpty() || (e.getCenter(this.position), e.getSize(this.scale), this.scale.multiplyScalar(.5), A.prototype.updateMatrixWorld.call(this, t)) }, ao.prototype = Object.create(Fe.prototype), ao.prototype.constructor = ao, ao.prototype.updateMatrixWorld = function (t) { var e = -this.plane.constant; 1e-8 > Math.abs(e) && (e = 1e-8), this.scale.set(.5 * this.size, .5 * this.size, e), this.children[0].material.side = 0 > e ? 1 : 0, this.lookAt(this.plane.normal), A.prototype.updateMatrixWorld.call(this, t) }, so.prototype = Object.create(A.prototype), so.prototype.constructor = so, so.prototype.setDirection = function () { var t, e = new r; return function (i) { .99999 < i.y ? this.quaternion.set(0, 0, 0, 1) : -.99999 > i.y ? this.quaternion.set(1, 0, 0, 0) : (e.set(i.z, 0, -i.x).normalize(), t = Math.acos(i.y), this.quaternion.setFromAxisAngle(e, t)) } }(), so.prototype.setLength = function (t, e, i) { void 0 === e && (e = .2 * t), void 0 === i && (i = .2 * e), this.line.scale.set(1, Math.max(0, t - e), 1), this.line.updateMatrix(), this.cone.scale.set(i, e, i), this.cone.position.y = t, this.cone.updateMatrix() }, so.prototype.setColor = function (t) { this.line.material.color.copy(t), this.cone.material.color.copy(t) }, so.prototype.copy = function (t) { return A.prototype.copy.call(this, t, !1), this.line.copy(t.line), this.cone.copy(t.cone), this }, so.prototype.clone = function () { return (new this.constructor).copy(this) }, co.prototype = Object.create(Ge.prototype), co.prototype.constructor = co, Pn.create = function (t, e) { return console.log("THREE.Curve.create() has been deprecated"), t.prototype = Object.create(Pn.prototype), t.prototype.constructor = t, t.prototype.getPoint = e, t }, Object.assign(qn.prototype, { createPointsGeometry: function (t) { return console.warn("THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getPoints(t), this.createGeometry(t) }, createSpacedPointsGeometry: function (t) { return console.warn("THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."), t = this.getSpacedPoints(t), this.createGeometry(t) }, createGeometry: function (t) { console.warn("THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead."); for (var e = new T, i = 0, n = t.length; i < n; i++) { var o = t[i]; e.vertices.push(new r(o.x, o.y, o.z || 0)) } return e } }), Object.assign(Xn.prototype, { fromPoints: function (t) { console.warn("THREE.Path: .fromPoints() has been renamed to .setFromPoints()."), this.setFromPoints(t) } }), ho.prototype = Object.create(Nn.prototype), lo.prototype = Object.create(Nn.prototype), uo.prototype = Object.create(Nn.prototype), Object.assign(uo.prototype, { initFromArray: function () { console.error("THREE.Spline: .initFromArray() has been removed.") }, getControlPointsArray: function () { console.error("THREE.Spline: .getControlPointsArray() has been removed.") }, reparametrizeByArcLength: function () { console.error("THREE.Spline: .reparametrizeByArcLength() has been removed.") } }), Kr.prototype.setColors = function () { console.error("THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.") }, Xr.prototype.update = function () { console.error("THREE.SkeletonHelper: update() no longer needs to be called.") }, Object.assign(mr.prototype, { extractUrlBase: function (t) { return console.warn("THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead."), ia.extractUrlBase(t) } }), Object.assign(lr.prototype, { setTexturePath: function (t) { return console.warn("THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath()."), this.setResourcePath(t) } }), Object.assign(Hr.prototype, { center: function (t) { return console.warn("THREE.Box2: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box2: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, size: function (t) { return console.warn("THREE.Box2: .size() has been renamed to .getSize()."), this.getSize(t) } }), Object.assign(d.prototype, { center: function (t) { return console.warn("THREE.Box3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, empty: function () { return console.warn("THREE.Box3: .empty() has been renamed to .isEmpty()."), this.isEmpty() }, isIntersectionBox: function (t) { return console.warn("THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) }, size: function (t) { return console.warn("THREE.Box3: .size() has been renamed to .getSize()."), this.getSize(t) } }), kr.prototype.center = function (t) { return console.warn("THREE.Line3: .center() has been renamed to .getCenter()."), this.getCenter(t) }, Object.assign(fo, { random16: function () { return console.warn("THREE.Math: .random16() has been deprecated. Use Math.random() instead."), Math.random() }, nearestPowerOfTwo: function (t) { return console.warn("THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo()."), fo.floorPowerOfTwo(t) }, nextPowerOfTwo: function (t) { return console.warn("THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo()."), fo.ceilPowerOfTwo(t) } }), Object.assign(o.prototype, { flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, multiplyVector3: function (t) { return console.warn("THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead."), t.applyMatrix3(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix3: .multiplyVector3Array() has been removed.") }, applyToBuffer: function (t) { return console.warn("THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t) }, applyToVector3Array: function () { console.error("THREE.Matrix3: .applyToVector3Array() has been removed.") } }), Object.assign(g.prototype, { extractPosition: function (t) { return console.warn("THREE.Matrix4: .extractPosition() has been renamed to .copyPosition()."), this.copyPosition(t) }, flattenToArrayOffset: function (t, e) { return console.warn("THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead."), this.toArray(t, e) }, getPosition: function () { var t; return function () { return void 0 === t && (t = new r), console.warn("THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead."), t.setFromMatrixColumn(this, 3) } }(), setRotationFromQuaternion: function (t) { return console.warn("THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion()."), this.makeRotationFromQuaternion(t) }, multiplyToArray: function () { console.warn("THREE.Matrix4: .multiplyToArray() has been removed.") }, multiplyVector3: function (t) { return console.warn("THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector4: function (t) { return console.warn("THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, multiplyVector3Array: function () { console.error("THREE.Matrix4: .multiplyVector3Array() has been removed.") }, rotateAxis: function (t) { console.warn("THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead."), t.transformDirection(this) }, crossVector: function (t) { return console.warn("THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead."), t.applyMatrix4(this) }, translate: function () { console.error("THREE.Matrix4: .translate() has been removed.") }, rotateX: function () { console.error("THREE.Matrix4: .rotateX() has been removed.") }, rotateY: function () { console.error("THREE.Matrix4: .rotateY() has been removed.") }, rotateZ: function () { console.error("THREE.Matrix4: .rotateZ() has been removed.") }, rotateByAxis: function () { console.error("THREE.Matrix4: .rotateByAxis() has been removed.") }, applyToBuffer: function (t) { return console.warn("THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead."), this.applyToBufferAttribute(t) }, applyToVector3Array: function () { console.error("THREE.Matrix4: .applyToVector3Array() has been removed.") }, makeFrustum: function (t, e, i, n, r, o) { return console.warn("THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead."), this.makePerspective(t, e, n, i, r, o) } }), f.prototype.isIntersectionLine = function (t) { return console.warn("THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine()."), this.intersectsLine(t) }, n.prototype.multiplyVector3 = function (t) { return console.warn("THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead."), t.applyQuaternion(this) }, Object.assign(q.prototype, { isIntersectionBox: function (t) { return console.warn("THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox()."), this.intersectsBox(t) }, isIntersectionPlane: function (t) { return console.warn("THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane()."), this.intersectsPlane(t) }, isIntersectionSphere: function (t) { return console.warn("THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere()."), this.intersectsSphere(t) } }), Object.assign(X.prototype, { area: function () { return console.warn("THREE.Triangle: .area() has been renamed to .getArea()."), this.getArea() }, barycoordFromPoint: function (t, e) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), this.getBarycoord(t, e) }, midpoint: function (t) { return console.warn("THREE.Triangle: .midpoint() has been renamed to .getMidpoint()."), this.getMidpoint(t) }, normal: function (t) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), this.getNormal(t) }, plane: function (t) { return console.warn("THREE.Triangle: .plane() has been renamed to .getPlane()."), this.getPlane(t) } }), Object.assign(X, { barycoordFromPoint: function (t, e, i, n, r) { return console.warn("THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord()."), X.getBarycoord(t, e, i, n, r) }, normal: function (t, e, i, n) { return console.warn("THREE.Triangle: .normal() has been renamed to .getNormal()."), X.getNormal(t, e, i, n) } }), Object.assign(Yn.prototype, { extractAllPoints: function (t) { return console.warn("THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead."), this.extractPoints(t) }, extrude: function (t) { return console.warn("THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead."), new Pi(this, t) }, makeGeometry: function (t) { return console.warn("THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead."), new ki(this, t) } }), Object.assign(i.prototype, { fromAttribute: function (t, e, i) { return console.warn("THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(r.prototype, { setEulerFromRotationMatrix: function () { console.error("THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.") }, setEulerFromQuaternion: function () { console.error("THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.") }, getPositionFromMatrix: function (t) { return console.warn("THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition()."), this.setFromMatrixPosition(t) }, getScaleFromMatrix: function (t) { return console.warn("THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale()."), this.setFromMatrixScale(t) }, getColumnFromMatrix: function (t, e) { return console.warn("THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn()."), this.setFromMatrixColumn(e, t) }, applyProjection: function (t) { return console.warn("THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead."), this.applyMatrix4(t) }, fromAttribute: function (t, e, i) { return console.warn("THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i) }, distanceToManhattan: function (t) { return console.warn("THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo()."), this.manhattanDistanceTo(t) }, lengthManhattan: function () { return console.warn("THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(s.prototype, { fromAttribute: function (t, e, i) { return console.warn("THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute()."), this.fromBufferAttribute(t, e, i) }, lengthManhattan: function () { return console.warn("THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength()."), this.manhattanLength() } }), Object.assign(T.prototype, { computeTangents: function () { console.error("THREE.Geometry: .computeTangents() has been removed.") }, computeLineDistances: function () { console.error("THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.") } }), Object.assign(A.prototype, { getChildByName: function (t) { return console.warn("THREE.Object3D: .getChildByName() has been renamed to .getObjectByName()."), this.getObjectByName(t) }, renderDepth: function () { console.warn("THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.") }, translate: function (t, e) { return console.warn("THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead."), this.translateOnAxis(e, t) }, getWorldRotation: function () { console.error("THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.") } }), Object.defineProperties(A.prototype, { eulerOrder: { get: function () { return console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order }, set: function (t) { console.warn("THREE.Object3D: .eulerOrder is now .rotation.order."), this.rotation.order = t } }, useQuaternion: { get: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") }, set: function () { console.warn("THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.") } } }), Object.defineProperties(De.prototype, { objects: { get: function () { return console.warn("THREE.LOD: .objects has been renamed to .levels."), this.levels } } }), Object.defineProperty(Be.prototype, "useVertexTexture", { get: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") }, set: function () { console.warn("THREE.Skeleton: useVertexTexture has been removed.") } }), Ne.prototype.initBones = function () { console.error("THREE.SkinnedMesh: initBones() has been removed.") }, Object.defineProperty(Pn.prototype, "__arcLengthDivisions", { get: function () { return console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions }, set: function (t) { console.warn("THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions."), this.arcLengthDivisions = t } }), we.prototype.setLens = function (t, e) { console.warn("THREE.PerspectiveCamera.setLens is deprecated. Use .setFocalLength and .filmGauge for a photographic setup."), void 0 !== e && (this.filmGauge = e), this.setFocalLength(t) }, Object.defineProperties(Zn.prototype, { onlyShadow: { set: function () { console.warn("THREE.Light: .onlyShadow has been removed.") } }, shadowCameraFov: { set: function (t) { console.warn("THREE.Light: .shadowCameraFov is now .shadow.camera.fov."), this.shadow.camera.fov = t } }, shadowCameraLeft: { set: function (t) { console.warn("THREE.Light: .shadowCameraLeft is now .shadow.camera.left."), this.shadow.camera.left = t } }, shadowCameraRight: { set: function (t) { console.warn("THREE.Light: .shadowCameraRight is now .shadow.camera.right."), this.shadow.camera.right = t } }, shadowCameraTop: { set: function (t) { console.warn("THREE.Light: .shadowCameraTop is now .shadow.camera.top."), this.shadow.camera.top = t } }, shadowCameraBottom: { set: function (t) { console.warn("THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom."), this.shadow.camera.bottom = t } }, shadowCameraNear: { set: function (t) { console.warn("THREE.Light: .shadowCameraNear is now .shadow.camera.near."), this.shadow.camera.near = t } }, shadowCameraFar: { set: function (t) { console.warn("THREE.Light: .shadowCameraFar is now .shadow.camera.far."), this.shadow.camera.far = t } }, shadowCameraVisible: { set: function () { console.warn("THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.") } }, shadowBias: { set: function (t) { console.warn("THREE.Light: .shadowBias is now .shadow.bias."), this.shadow.bias = t } }, shadowDarkness: { set: function () { console.warn("THREE.Light: .shadowDarkness has been removed.") } }, shadowMapWidth: { set: function (t) { console.warn("THREE.Light: .shadowMapWidth is now .shadow.mapSize.width."), this.shadow.mapSize.width = t } }, shadowMapHeight: { set: function (t) { console.warn("THREE.Light: .shadowMapHeight is now .shadow.mapSize.height."), this.shadow.mapSize.height = t } } }), Object.defineProperties(S.prototype, { length: { get: function () { return console.warn("THREE.BufferAttribute: .length has been deprecated. Use .count instead."), this.array.length } }, copyIndicesArray: function () { console.error("THREE.BufferAttribute: .copyIndicesArray() has been removed.") } }), Object.assign(F.prototype, { addIndex: function (t) { console.warn("THREE.BufferGeometry: .addIndex() has been renamed to .setIndex()."), this.setIndex(t) }, addDrawCall: function (t, e, i) { void 0 !== i && console.warn("THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset."), console.warn("THREE.BufferGeometry: .addDrawCall() is now .addGroup()."), this.addGroup(t, e) }, clearDrawCalls: function () { console.warn("THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups()."), this.clearGroups() }, computeTangents: function () { console.warn("THREE.BufferGeometry: .computeTangents() has been removed.") }, computeOffsets: function () { console.warn("THREE.BufferGeometry: .computeOffsets() has been removed.") } }), Object.defineProperties(F.prototype, { drawcalls: { get: function () { return console.error("THREE.BufferGeometry: .drawcalls has been renamed to .groups."), this.groups } }, offsets: { get: function () { return console.warn("THREE.BufferGeometry: .offsets has been renamed to .groups."), this.groups } } }), Object.assign(Ii.prototype, { getArrays: function () { console.error("THREE.ExtrudeBufferGeometry: .getArrays() has been removed.") }, addShapeList: function () { console.error("THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.") }, addShape: function () { console.error("THREE.ExtrudeBufferGeometry: .addShape() has been removed.") } }), Object.defineProperties(Dr.prototype, { dynamic: { set: function () { console.warn("THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.") } }, onUpdate: { value: function () { return console.warn("THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead."), this } } }), Object.defineProperties(j.prototype, { wrapAround: { get: function () { console.warn("THREE.Material: .wrapAround has been removed.") }, set: function () { console.warn("THREE.Material: .wrapAround has been removed.") } }, overdraw: { get: function () { console.warn("THREE.Material: .overdraw has been removed.") }, set: function () { console.warn("THREE.Material: .overdraw has been removed.") } }, wrapRGB: { get: function () { return console.warn("THREE.Material: .wrapRGB has been removed."), new x } }, shading: { get: function () { console.error("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead.") }, set: function (t) { console.warn("THREE." + this.type + ": .shading has been removed. Use the boolean .flatShading instead."), this.flatShading = 1 === t } } }), Object.defineProperties(nn.prototype, { metal: { get: function () { return console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead."), !1 }, set: function () { console.warn("THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead") } } }), Object.defineProperties(W.prototype, { derivatives: { get: function () { return console.warn("THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives }, set: function (t) { console.warn("THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives."), this.extensions.derivatives = t } } }), Object.assign(Te.prototype, { clearTarget: function (t, e, i, n) { console.warn("THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead."), this.setRenderTarget(t), this.clear(e, i, n) }, animate: function (t) { console.warn("THREE.WebGLRenderer: .animate() is now .setAnimationLoop()."), this.setAnimationLoop(t) }, getCurrentRenderTarget: function () { return console.warn("THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget()."), this.getRenderTarget() }, getMaxAnisotropy: function () { return console.warn("THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy()."), this.capabilities.getMaxAnisotropy() }, getPrecision: function () { return console.warn("THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision."), this.capabilities.precision }, resetGLState: function () { return console.warn("THREE.WebGLRenderer: .resetGLState() is now .state.reset()."), this.state.reset() }, supportsFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( 'OES_texture_float' )."), this.extensions.get("OES_texture_float") }, supportsHalfFloatTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( 'OES_texture_half_float' )."), this.extensions.get("OES_texture_half_float") }, supportsStandardDerivatives: function () { return console.warn("THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( 'OES_standard_derivatives' )."), this.extensions.get("OES_standard_derivatives") }, supportsCompressedTextureS3TC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( 'WEBGL_compressed_texture_s3tc' )."), this.extensions.get("WEBGL_compressed_texture_s3tc") }, supportsCompressedTexturePVRTC: function () { return console.warn("THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( 'WEBGL_compressed_texture_pvrtc' )."), this.extensions.get("WEBGL_compressed_texture_pvrtc") }, supportsBlendMinMax: function () { return console.warn("THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( 'EXT_blend_minmax' )."), this.extensions.get("EXT_blend_minmax") }, supportsVertexTextures: function () { return console.warn("THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures."), this.capabilities.vertexTextures }, supportsInstancedArrays: function () { return console.warn("THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( 'ANGLE_instanced_arrays' )."), this.extensions.get("ANGLE_instanced_arrays") }, enableScissorTest: function (t) { console.warn("THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest()."), this.setScissorTest(t) }, initMaterial: function () { console.warn("THREE.WebGLRenderer: .initMaterial() has been removed.") }, addPrePlugin: function () { console.warn("THREE.WebGLRenderer: .addPrePlugin() has been removed.") }, addPostPlugin: function () { console.warn("THREE.WebGLRenderer: .addPostPlugin() has been removed.") }, updateShadowMap: function () { console.warn("THREE.WebGLRenderer: .updateShadowMap() has been removed.") }, setFaceCulling: function () { console.warn("THREE.WebGLRenderer: .setFaceCulling() has been removed.") }, allocTextureUnit: function () { console.warn("THREE.WebGLRenderer: .allocTextureUnit() has been removed.") }, setTexture: function () { console.warn("THREE.WebGLRenderer: .setTexture() has been removed.") }, setTexture2D: function () { console.warn("THREE.WebGLRenderer: .setTexture2D() has been removed.") }, setTextureCube: function () { console.warn("THREE.WebGLRenderer: .setTextureCube() has been removed.") } }), Object.defineProperties(Te.prototype, { shadowMapEnabled: { get: function () { return this.shadowMap.enabled }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled."), this.shadowMap.enabled = t } }, shadowMapType: { get: function () { return this.shadowMap.type }, set: function (t) { console.warn("THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type."), this.shadowMap.type = t } }, shadowMapCullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(me.prototype, { cullFace: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.") } }, renderReverseSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.") } }, renderSingleSided: { get: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") }, set: function () { console.warn("THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.") } } }), Object.defineProperties(l.prototype, { activeCubeFace: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeCubeFace has been removed. It is now the second parameter of WebGLRenderer.setRenderTarget().") } }, activeMipMapLevel: { set: function () { console.warn("THREE.WebGLRenderTargetCube: .activeMipMapLevel has been removed. It is now the third parameter of WebGLRenderer.setRenderTarget().") } } }), Object.defineProperties(c.prototype, { wrapS: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS."), this.texture.wrapS = t } }, wrapT: { get: function () { return console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT."), this.texture.wrapT = t } }, magFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter."), this.texture.magFilter = t } }, minFilter: { get: function () { return console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter."), this.texture.minFilter = t } }, anisotropy: { get: function () { return console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy."), this.texture.anisotropy = t } }, offset: { get: function () { return console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .offset is now .texture.offset."), this.texture.offset = t } }, repeat: { get: function () { return console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .repeat is now .texture.repeat."), this.texture.repeat = t } }, format: { get: function () { return console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .format is now .texture.format."), this.texture.format = t } }, type: { get: function () { return console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .type is now .texture.type."), this.texture.type = t } }, generateMipmaps: { get: function () { return console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps }, set: function (t) { console.warn("THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps."), this.texture.generateMipmaps = t } } }), Object.defineProperties(Ee.prototype, { standing: { set: function () { console.warn("THREE.WebVRManager: .standing has been removed.") } }, userHeight: { set: function () { console.warn("THREE.WebVRManager: .userHeight has been removed.") } } }), Ar.prototype.load = function (t) { console.warn("THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead."); var e = this; return (new gr).load(t, (function (t) { e.setBuffer(t) })), this }, Sr.prototype.getData = function () { return console.warn("THREE.AudioAnalyser: .getData() is now .getFrequencyData()."), this.getFrequencyData() }, Mr.prototype.updateCubeMap = function (t, e) { return console.warn("THREE.CubeCamera: .updateCubeMap() is now .update()."), this.update(t, e) }, go.crossOrigin = void 0, go.loadTexture = function (t, e, i, n) { console.warn("THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead."); var r = new Rn; return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t }, go.loadTextureCube = function (t, e, i, n) { console.warn("THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead."); var r = new Cn; return r.setCrossOrigin(this.crossOrigin), t = r.load(t, i, void 0, n), e && (t.mapping = e), t }, go.loadCompressedTexture = function () { console.error("THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.") }, go.loadCompressedTextureCube = function () { console.error("THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.") }, t.ACESFilmicToneMapping = 5, t.AddEquation = 100, t.AddOperation = 2, t.AdditiveBlending = 2, t.AlphaFormat = 1021, t.AlwaysDepth = 1, t.AmbientLight = rr, t.AmbientLightProbe = br, t.AnimationClip = wn, t.AnimationLoader = An, t.AnimationMixer = Or, t.AnimationObjectGroup = Pr, t.AnimationUtils = Xo, t.ArcCurve = On, t.ArrayCamera = Me, t.ArrowHelper = so, t.Audio = Ar, t.AudioAnalyser = Sr, t.AudioContext = la, t.AudioListener = Er, t.AudioLoader = gr, t.AxesHelper = co, t.AxisHelper = function (t) { return console.warn("THREE.AxisHelper has been renamed to THREE.AxesHelper."), new co(t) }, t.BackSide = 1, t.BasicDepthPacking = 3200, t.BasicShadowMap = 0, t.BinaryTextureLoader = function (t) { return console.warn("THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader."), new Sn(t) }, t.Bone = ze, t.BooleanKeyframeTrack = fn, t.BoundingBoxHelper = function (t, e) { return console.warn("THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead."), new ro(t, e) }, t.Box2 = Hr, t.Box3 = d, t.Box3Helper = oo, t.BoxBufferGeometry = H, t.BoxGeometry = G, t.BoxHelper = ro, t.BufferAttribute = S, t.BufferGeometry = F, t.BufferGeometryLoader = hr, t.ByteType = 1010, t.Cache = Yo, t.Camera = be, t.CameraHelper = no, t.CanvasRenderer = function () { console.error("THREE.CanvasRenderer has been removed") }, t.CanvasTexture = qe, t.CatmullRomCurve3 = Nn, t.CineonToneMapping = 4, t.CircleBufferGeometry = Qi, t.CircleGeometry = Ji, t.ClampToEdgeWrapping = 1001, t.Clock = _r, t.ClosedSplineCurve3 = ho, t.Color = x, t.ColorKeyframeTrack = mn, t.CompressedTexture = We, t.CompressedTextureLoader = Tn, t.ConeBufferGeometry = Zi, t.ConeGeometry = Yi, t.CubeCamera = Mr, t.CubeGeometry = G, t.CubeReflectionMapping = 301, t.CubeRefractionMapping = 302, t.CubeTexture = st, t.CubeTextureLoader = Cn, t.CubeUVReflectionMapping = 306, t.CubeUVRefractionMapping = 307, t.CubicBezierCurve = Fn, t.CubicBezierCurve3 = Gn, t.CubicInterpolant = ln, t.CullFaceBack = 1, t.CullFaceFront = 2, t.CullFaceFrontBack = 3, t.CullFaceNone = 0, t.Curve = Pn, t.CurvePath = qn, t.CustomBlending = 5, t.CylinderBufferGeometry = Xi, t.CylinderGeometry = qi, t.Cylindrical = Gr, t.DataTexture = u, t.DataTexture2DArray = ct, t.DataTexture3D = ht, t.DataTextureLoader = Sn, t.DefaultLoadingManager = Zo, t.DepthFormat = 1026, t.DepthStencilFormat = 1027, t.DepthTexture = Xe, t.DirectionalLight = nr, t.DirectionalLightHelper = io, t.DirectionalLightShadow = ir, t.DiscreteInterpolant = dn, t.DodecahedronBufferGeometry = ai, t.DodecahedronGeometry = oi, t.DoubleSide = 2, t.DstAlphaFactor = 206, t.DstColorFactor = 208, t.DynamicBufferAttribute = function (t, e) { return console.warn("THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead."), new S(t, e).setDynamic(!0) }, t.EdgesGeometry = Wi, t.EdgesHelper = function (t, e) { return console.warn("THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead."), new Ge(new Wi(t.geometry), new Ue({ color: void 0 !== e ? e : 16777215 })) }, t.EllipseCurve = In, t.EqualDepth = 4, t.EquirectangularReflectionMapping = 303, t.EquirectangularRefractionMapping = 304, t.Euler = _, t.EventDispatcher = e, t.ExtrudeBufferGeometry = Ii, t.ExtrudeGeometry = Pi, t.Face3 = M, t.Face4 = function (t, e, i, n, r, o, a) { return console.warn("THREE.Face4 has been removed. A THREE.Face3 will be created instead."), new M(t, e, i, r, o, a) }, t.FaceColors = 1, t.FaceNormalsHelper = eo, t.FileLoader = En, t.FlatShading = 1, t.Float32Attribute = function (t, e) { return console.warn("THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead."), new N(t, e) }, t.Float32BufferAttribute = N, t.Float64Attribute = function (t, e) { return console.warn("THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead."), new B(t, e) }, t.Float64BufferAttribute = B, t.FloatType = 1015, t.Fog = Le, t.FogExp2 = Se, t.Font = pr, t.FontLoader = fr, t.FrontFaceDirectionCCW = 1, t.FrontFaceDirectionCW = 0, t.FrontSide = 0, t.Frustum = m, t.GammaEncoding = 3007, t.Geometry = T, t.GeometryUtils = { merge: function (t, e, i) { if (console.warn("THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead."), e.isMesh) { e.matrixAutoUpdate && e.updateMatrix(); var n = e.matrix; e = e.geometry } t.merge(e, n, i) }, center: function (t) { return console.warn("THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead."), t.center() } }, t.GreaterDepth = 6, t.GreaterEqualDepth = 5, t.GridHelper = Kr, t.Group = xe, t.HalfFloatType = 1016, t.HemisphereLight = Jn, t.HemisphereLightHelper = Jr, t.HemisphereLightProbe = xr, t.IcosahedronBufferGeometry = ri, t.IcosahedronGeometry = ni, t.ImageBitmapLoader = ur, t.ImageLoader = Ln, t.ImageUtils = go, t.ImmediateRenderObject = Vr, t.InstancedBufferAttribute = cr, t.InstancedBufferGeometry = sr, t.InstancedInterleavedBuffer = Nr, t.Int16Attribute = function (t, e) { return console.warn("THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead."), new P(t, e) }, t.Int16BufferAttribute = P, t.Int32Attribute = function (t, e) { return console.warn("THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead."), new O(t, e) }, t.Int32BufferAttribute = O, t.Int8Attribute = function (t, e) { return console.warn("THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead."), new L(t, e) }, t.Int8BufferAttribute = L, t.IntType = 1013, t.InterleavedBuffer = Re, t.InterleavedBufferAttribute = Pe, t.Interpolant = hn, t.InterpolateDiscrete = 2300, t.InterpolateLinear = 2301, t.InterpolateSmooth = 2302, t.JSONLoader = function () { console.error("THREE.JSONLoader has been removed.") }, t.KeyframeTrack = pn, t.LOD = De, t.LatheBufferGeometry = Hi, t.LatheGeometry = Gi, t.Layers = E, t.LensFlare = function () { console.error("THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js") }, t.LessDepth = 2, t.LessEqualDepth = 3, t.Light = Zn, t.LightProbe = yr, t.LightProbeHelper = Qr, t.LightShadow = Qn, t.Line = Fe, t.Line3 = kr, t.LineBasicMaterial = Ue, t.LineCurve = Hn, t.LineCurve3 = kn, t.LineDashedMaterial = cn, t.LineLoop = He, t.LinePieces = 1, t.LineSegments = Ge, t.LineStrip = 0, t.LinearEncoding = 3e3, t.LinearFilter = 1006, t.LinearInterpolant = un, t.LinearMipMapLinearFilter = 1008, t.LinearMipMapNearestFilter = 1007, t.LinearToneMapping = 1, t.Loader = mr, t.LoaderUtils = ia, t.LoadingManager = _n, t.LogLuvEncoding = 3003, t.LoopOnce = 2200, t.LoopPingPong = 2202, t.LoopRepeat = 2201, t.LuminanceAlphaFormat = 1025, t.LuminanceFormat = 1024, t.MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 }, t.Material = j, t.MaterialLoader = ar, t.Math = fo, t.Matrix3 = o, t.Matrix4 = g, t.MaxEquation = 104, t.Mesh = Z, t.MeshBasicMaterial = Y, t.MeshDepthMaterial = pe, t.MeshDistanceMaterial = fe, t.MeshFaceMaterial = function (t) { return console.warn("THREE.MeshFaceMaterial has been removed. Use an Array instead."), t }, t.MeshLambertMaterial = an, t.MeshMatcapMaterial = sn, t.MeshNormalMaterial = on, t.MeshPhongMaterial = nn, t.MeshPhysicalMaterial = en, t.MeshStandardMaterial = tn, t.MeshToonMaterial = rn, t.MinEquation = 103, t.MirroredRepeatWrapping = 1002, t.MixOperation = 1, t.MultiMaterial = function (t) { return void 0 === t && (t = []), console.warn("THREE.MultiMaterial has been removed. Use an Array instead."), t.isMultiMaterial = !0, t.materials = t, t.clone = function () { return t.slice() }, t }, t.MultiplyBlending = 4, t.MultiplyOperation = 0, t.NearestFilter = 1003, t.NearestMipMapLinearFilter = 1005, t.NearestMipMapNearestFilter = 1004, t.NeverDepth = 0, t.NoBlending = 0, t.NoColors = 0, t.NoToneMapping = 0, t.NormalBlending = 1, t.NotEqualDepth = 7, t.NumberKeyframeTrack = gn, t.Object3D = A, t.ObjectLoader = lr, t.ObjectSpaceNormalMap = 1, t.OctahedronBufferGeometry = ii, t.OctahedronGeometry = ei, t.OneFactor = 201, t.OneMinusDstAlphaFactor = 207, t.OneMinusDstColorFactor = 209, t.OneMinusSrcAlphaFactor = 205, t.OneMinusSrcColorFactor = 203, t.OrthographicCamera = er, t.PCFShadowMap = 1, t.PCFSoftShadowMap = 2, t.ParametricBufferGeometry = Je, t.ParametricGeometry = Ze, t.Particle = function (t) { return console.warn("THREE.Particle has been renamed to THREE.Sprite."), new Oe(t) }, t.ParticleBasicMaterial = function (t) { return console.warn("THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial."), new ke(t) }, t.ParticleSystem = function (t, e) { return console.warn("THREE.ParticleSystem has been renamed to THREE.Points."), new Ve(t, e) }, t.ParticleSystemMaterial = function (t) { return console.warn("THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial."), new ke(t) }, t.Path = Xn, t.PerspectiveCamera = we, t.Plane = f, t.PlaneBufferGeometry = V, t.PlaneGeometry = k, t.PlaneHelper = ao, t.PointCloud = function (t, e) { return console.warn("THREE.PointCloud has been renamed to THREE.Points."), new Ve(t, e) }, t.PointCloudMaterial = function (t) { return console.warn("THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial."), new ke(t) }, t.PointLight = tr, t.PointLightHelper = Yr, t.Points = Ve, t.PointsMaterial = ke, t.PolarGridHelper = $r, t.PolyhedronBufferGeometry = Ke, t.PolyhedronGeometry = Qe, t.PositionalAudio = Tr, t.PositionalAudioHelper = to, t.PropertyBinding = Rr, t.PropertyMixer = Lr, t.QuadraticBezierCurve = Vn, t.QuadraticBezierCurve3 = jn, t.Quaternion = n, t.QuaternionKeyframeTrack = yn, t.QuaternionLinearInterpolant = vn, t.REVISION = "105", t.RGBADepthPacking = 3201, t.RGBAFormat = 1023, t.RGBA_ASTC_10x10_Format = 37819, t.RGBA_ASTC_10x5_Format = 37816, t.RGBA_ASTC_10x6_Format = 37817, t.RGBA_ASTC_10x8_Format = 37818, t.RGBA_ASTC_12x10_Format = 37820, t.RGBA_ASTC_12x12_Format = 37821, t.RGBA_ASTC_4x4_Format = 37808, t.RGBA_ASTC_5x4_Format = 37809, t.RGBA_ASTC_5x5_Format = 37810, t.RGBA_ASTC_6x5_Format = 37811, t.RGBA_ASTC_6x6_Format = 37812, t.RGBA_ASTC_8x5_Format = 37813, t.RGBA_ASTC_8x6_Format = 37814, t.RGBA_ASTC_8x8_Format = 37815, t.RGBA_PVRTC_2BPPV1_Format = 35843, t.RGBA_PVRTC_4BPPV1_Format = 35842, t.RGBA_S3TC_DXT1_Format = 33777, t.RGBA_S3TC_DXT3_Format = 33778, t.RGBA_S3TC_DXT5_Format = 33779, t.RGBDEncoding = 3006, t.RGBEEncoding = 3002, t.RGBEFormat = 1023, t.RGBFormat = 1022, t.RGBM16Encoding = 3005, t.RGBM7Encoding = 3004, t.RGB_ETC1_Format = 36196, t.RGB_PVRTC_2BPPV1_Format = 35841, t.RGB_PVRTC_4BPPV1_Format = 35840, t.RGB_S3TC_DXT1_Format = 33776, t.RawShaderMaterial = $i, t.Ray = q, t.Raycaster = Br, t.RectAreaLight = or, t.RectAreaLightHelper = Zr, t.RedFormat = 1028, t.ReinhardToneMapping = 2, t.RepeatWrapping = 1e3, t.ReverseSubtractEquation = 102, t.RingBufferGeometry = Fi, t.RingGeometry = Ui, t.Scene = Ce, t.SceneUtils = { createMultiMaterialObject: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, detach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") }, attach: function () { console.error("THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js") } }, t.ShaderChunk = yo, t.ShaderLib = Mo, t.ShaderMaterial = W, t.ShadowMaterial = Ki, t.Shape = Yn, t.ShapeBufferGeometry = Vi, t.ShapeGeometry = ki, t.ShapePath = dr, t.ShapeUtils = Vo, t.ShortType = 1011, t.Skeleton = Be, t.SkeletonHelper = Xr, t.SkinnedMesh = Ne, t.SmoothShading = 2, t.Sphere = p, t.SphereBufferGeometry = zi, t.SphereGeometry = Bi, t.Spherical = Fr, t.SphericalHarmonics3 = vr, t.SphericalReflectionMapping = 305, t.Spline = uo, t.SplineCurve = Wn, t.SplineCurve3 = lo, t.SpotLight = $n, t.SpotLightHelper = Wr, t.SpotLightShadow = Kn, t.Sprite = Oe, t.SpriteMaterial = Ie, t.SrcAlphaFactor = 204, t.SrcAlphaSaturateFactor = 210, t.SrcColorFactor = 202, t.StereoCamera = wr, t.StringKeyframeTrack = xn, t.SubtractEquation = 101, t.SubtractiveBlending = 3, t.TangentSpaceNormalMap = 0, t.TetrahedronBufferGeometry = ti, t.TetrahedronGeometry = $e, t.TextBufferGeometry = Ni, t.TextGeometry = Di, t.Texture = a, t.TextureLoader = Rn, t.TorusBufferGeometry = di, t.TorusGeometry = ui, t.TorusKnotBufferGeometry = li, t.TorusKnotGeometry = hi, t.Triangle = X, t.TriangleFanDrawMode = 2, t.TriangleStripDrawMode = 1, t.TrianglesDrawMode = 0, t.TubeBufferGeometry = ci, t.TubeGeometry = si, t.UVMapping = 300, t.Uint16Attribute = function (t, e) { return console.warn("THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead."), new I(t, e) }, t.Uint16BufferAttribute = I, t.Uint32Attribute = function (t, e) { return console.warn("THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead."), new D(t, e) }, t.Uint32BufferAttribute = D, t.Uint8Attribute = function (t, e) { return console.warn("THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead."), new C(t, e) }, t.Uint8BufferAttribute = C, t.Uint8ClampedAttribute = function (t, e) { return console.warn("THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead."), new R(t, e) }, t.Uint8ClampedBufferAttribute = R, t.Uncharted2ToneMapping = 3, t.Uniform = Dr, t.UniformsLib = wo, t.UniformsUtils = xo, t.UnsignedByteType = 1009, t.UnsignedInt248Type = 1020, t.UnsignedIntType = 1014, t.UnsignedShort4444Type = 1017, t.UnsignedShort5551Type = 1018, t.UnsignedShort565Type = 1019, t.UnsignedShortType = 1012, t.Vector2 = i, t.Vector3 = r, t.Vector4 = s, t.VectorKeyframeTrack = bn, t.Vertex = function (t, e, i) { return console.warn("THREE.Vertex has been removed. Use THREE.Vector3 instead."), new r(t, e, i) }, t.VertexColors = 2, t.VertexNormalsHelper = jr, t.VideoTexture = je, t.WebGLMultisampleRenderTarget = h, t.WebGLRenderTarget = c, t.WebGLRenderTargetCube = l, t.WebGLRenderer = Te, t.WebGLUtils = ye, t.WireframeGeometry = Ye, t.WireframeHelper = function (t, e) { return console.warn("THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead."), new Ge(new Ye(t.geometry), new Ue({ color: void 0 !== e ? e : 16777215 })) }, t.WrapAroundEnding = 2402, t.XHRLoader = function (t) { return console.warn("THREE.XHRLoader has been renamed to THREE.FileLoader."), new En(t) }, t.ZeroCurvatureEnding = 2400, t.ZeroFactor = 200, t.ZeroSlopeEnding = 2401, t.sRGBEncoding = 3001, Object.defineProperty(t, "__esModule", { value: !0 }) })), function (t, e) { "object" == typeof exports && "undefined" != typeof module ? e(exports, require("three")) : "function" == typeof define && define.amd ? define(["exports", "three"], e) : e((t = t || self).PANOLENS = {}, t.THREE) }(this, (function (t, e) { function i(t) { this.constraints = Object.assign({ video: { width: { ideal: 1920 }, height: { ideal: 1080 }, facingMode: { exact: "environment" } }, audio: !1 }, t), this.element = this.scene = this.container = null, this.devices = [], this.stream = null, this.ratioScalar = 1, this.videoDeviceIndex = 0 } function n(t) { this.format = null, this.eyeSep = void 0 === t ? .064 : t, this.loffset = new e.Vector2, this.roffset = new e.Vector2 } function r(t, i, n) { t = void 0 === t ? 16777215 : t, i = void 0 === i || i, n = void 0 === n ? 1500 : n, this.dpr = window.devicePixelRatio; var r = this.createCanvas(), o = r.canvas; r = r.context; var a = new e.SpriteMaterial({ color: t, map: this.createCanvasTexture(o) }); e.Sprite.call(this, a), this.canvasWidth = o.width, this.canvasHeight = o.height, this.context = r, this.color = t instanceof e.Color ? t : new e.Color(t), this.autoSelect = i, this.dwellTime = n, this.rippleDuration = 500, this.position.z = -10, this.center.set(.5, .5), this.scale.set(.5, .5, 1), this.callback = this.timerId = this.startTimestamp = null, this.frustumCulled = !1, this.updateCanvasArcByProgress(0) } function o(t, i, n) { t = void 0 === t ? 300 : t, i = i || L.Info, e.Sprite.call(this), this.type = "infospot", this.animated = void 0 === n || n, this.frustumCulled = this.isHovering = !1, this.cursorStyle = this.toPanorama = this.element = null, this.mode = T.NORMAL, this.scale.set(t, t, 1), this.rotation.y = Math.PI, this.container = null, this.originalRaycast = this.raycast, this.HANDLER_FOCUS = null, this.material.side = e.DoubleSide, this.material.depthTest = !1, this.material.transparent = !0, this.material.opacity = 0, this.scaleUpAnimation = new O.Tween, this.scaleDownAnimation = new O.Tween, n = function (i) { if (this.material) { var n = i.image.width / i.image.height, r = new e.Vector3; i.image.width = i.image.naturalWidth || 64, i.image.height = i.image.naturalHeight || 64, this.scale.set(n * t, t, 1), r.copy(this.scale), this.scaleUpAnimation = new O.Tween(this.scale).to({ x: 1.3 * r.x, y: 1.3 * r.y }, 500).easing(O.Easing.Elastic.Out), this.scaleDownAnimation = new O.Tween(this.scale).to({ x: r.x, y: r.y }, 500).easing(O.Easing.Elastic.Out), this.material.map = i, this.material.needsUpdate = !0 } }.bind(this), this.showAnimation = new O.Tween(this.material).to({ opacity: 1 }, 500).onStart(this.enableRaycast.bind(this, !0)).easing(O.Easing.Quartic.Out), this.hideAnimation = new O.Tween(this.material).to({ opacity: 0 }, 500).onStart(this.enableRaycast.bind(this, !1)).easing(O.Easing.Quartic.Out), this.addEventListener("click", this.onClick), this.addEventListener("hover", this.onHover), this.addEventListener("hoverenter", this.onHoverStart), this.addEventListener("hoverleave", this.onHoverEnd), this.addEventListener("panolens-dual-eye-effect", this.onDualEyeEffect), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("dismiss", this.onDismiss), this.addEventListener("panolens-infospot-focus", this.setFocusMethod), R.load(i, n) } function a(t) { t || console.warn("PANOLENS.Widget: No container specified"), e.EventDispatcher.call(this), this.DEFAULT_TRANSITION = "all 0.27s ease", this.TOUCH_ENABLED = !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch), this.PREVENT_EVENT_HANDLER = function (t) { t.preventDefault(), t.stopPropagation() }, this.container = t, this.mask = this.activeSubMenu = this.activeMainItem = this.mainMenu = this.settingElement = this.videoElement = this.fullscreenElement = this.barElement = null } function s() { this.edgeLength = 1e4, e.Mesh.call(this, this.createGeometry(this.edgeLength), this.createMaterial()), this.type = "panorama", this.ImageQualityLow = 1, this.ImageQualityFair = 2, this.ImageQualityMedium = 3, this.ImageQualityHigh = 4, this.ImageQualitySuperHigh = 5, this.animationDuration = 1e3, this.defaultInfospotSize = 350, this.container = void 0, this.loaded = !1, this.linkedSpots = [], this.isInfospotVisible = !1, this.linkingImageScale = this.linkingImageURL = void 0, this.renderOrder = -1, this.active = !1, this.infospotAnimation = new O.Tween(this).to({}, this.animationDuration / 2), this.addEventListener("load", this.fadeIn.bind(this)), this.addEventListener("panolens-container", this.setContainer.bind(this)), this.addEventListener("click", this.onClick.bind(this)), this.setupTransitions() } function c(t) { s.call(this), this.src = t, this.type = "image_panorama" } function h() { s.call(this), this.type = "empty_panorama" } function l(t) { t = void 0 === t ? [] : t, s.call(this), this.images = t, this.type = "cube_panorama" } function u() { for (var t = [], e = 0; 6 > e; e++)t.push(L.WhiteTile); l.call(this, t), this.type = "basic_panorama" } function d(t, e) { e = void 0 === e ? {} : e, s.call(this), this.src = t, this.options = Object.assign({ videoElement: document.createElement("video"), loop: !0, muted: !0, autoplay: !1, playsinline: !0, crossOrigin: "anonymous" }, e), this.videoElement = this.options.videoElement, this.videoProgress = 0, this.type = "video_panorama", this.addEventListener("leave", this.pauseVideo.bind(this)), this.addEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.addEventListener("video-toggle", this.toggleVideo.bind(this)), this.addEventListener("video-time", this.setVideoCurrentTime.bind(this)) } function p(t) { var e; this._parameters = t = void 0 === t ? {} : t, this._panoId = this._zoom = null, this._panoClient = new google.maps.StreetViewService, this._total = this._count = 0, this._canvas = [], this._ctx = [], this._hc = this._wc = 0, this.result = null, this.rotation = 0, this.copyright = "", this.onPanoramaLoad = this.onSizeChange = null, this.levelsW = [1, 2, 4, 7, 13, 26], this.levelsH = [1, 1, 2, 4, 7, 13], this.widths = [416, 832, 1664, 3328, 6656, 13312], this.heights = [416, 416, 832, 1664, 3328, 6656], this.maxH = this.maxW = 6656; try { var i = document.createElement("canvas"); (e = i.getContext("experimental-webgl")) || (e = i.getContext("webgl")) } catch (t) { } this.maxW = Math.max(e.getParameter(e.MAX_TEXTURE_SIZE), this.maxW), this.maxH = Math.max(e.getParameter(e.MAX_TEXTURE_SIZE), this.maxH) } function f(t, e) { c.call(this), this.panoId = t, this.gsvLoader = null, this.loadRequested = !1, this.setupGoogleMapAPI(e), this.type = "google_streetview_panorama" } function m(t, i) { "image" === (void 0 === t ? "image" : t) && c.call(this, i), this.EPS = 1e-6, this.frameId = null, this.dragging = !1, this.userMouse = new e.Vector2, this.quatA = new e.Quaternion, this.quatB = new e.Quaternion, this.quatCur = new e.Quaternion, this.quatSlerp = new e.Quaternion, this.vectorX = new e.Vector3(1, 0, 0), this.vectorY = new e.Vector3(0, 1, 0), this.type = "little_planet", this.addEventListener("window-resize", this.onWindowResize) } function g(t) { m.call(this, "image", t), this.type = "image_little_planet" } function v(t) { s.call(this), this.media = new i(t), this.type = "camera_panorama", this.addEventListener("enter", this.start.bind(this)), this.addEventListener("leave", this.stop.bind(this)), this.addEventListener("panolens-container", this.onPanolensContainer.bind(this)), this.addEventListener("panolens-scene", this.onPanolensScene.bind(this)) } function y(t, e) { e = void 0 === e ? new n : e, c.call(this, t), this.stereo = e, this.type = "stereo_image_panorama" } function x(t, e, i) { e = void 0 === e ? {} : e, i = void 0 === i ? new n : i, d.call(this, t, e), this.stereo = i, this.type = "stereo_video_panorama" } function b(t, i) { function n(t) { if (F = !1, z = U = 0, !1 !== v.enabled) { if (t.preventDefault(), t.button === v.mouseButtons.ORBIT) { if (!0 === v.noRotate) return; H = G.ROTATE, y.set(t.clientX, t.clientY) } else if (t.button === v.mouseButtons.ZOOM) { if (!0 === v.noZoom) return; H = G.DOLLY, T.set(t.clientX, t.clientY) } else if (t.button === v.mouseButtons.PAN) { if (!0 === v.noPan) return; H = G.PAN, w.set(t.clientX, t.clientY) } H !== G.NONE && (document.addEventListener("mousemove", r, !1), document.addEventListener("mouseup", o, !1), v.dispatchEvent(W)), v.update() } } function r(t) { if (!1 !== v.enabled) { t.preventDefault(); var e = v.domElement === document ? v.domElement.body : v.domElement; if (H === G.ROTATE) { if (!0 === v.noRotate) return; x.set(t.clientX, t.clientY), b.subVectors(x, y), v.rotateLeft(2 * Math.PI * b.x / e.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * b.y / e.clientHeight * v.rotateSpeed), y.copy(x), d && (z = t.clientX - d.clientX, U = t.clientY - d.clientY), d = t } else if (H === G.DOLLY) { if (!0 === v.noZoom) return; S.set(t.clientX, t.clientY), L.subVectors(S, T), 0 < L.y ? v.dollyIn() : 0 > L.y && v.dollyOut(), T.copy(S) } else if (H === G.PAN) { if (!0 === v.noPan) return; M.set(t.clientX, t.clientY), _.subVectors(M, w), v.pan(_.x, _.y), w.copy(M) } H !== G.NONE && v.update() } } function o() { F = !0, d = void 0, !1 !== v.enabled && (document.removeEventListener("mousemove", r, !1), document.removeEventListener("mouseup", o, !1), v.dispatchEvent(q), H = G.NONE) } function a(t) { if (!1 !== v.enabled && !0 !== v.noZoom && H === G.NONE) { t.preventDefault(), t.stopPropagation(); var e = 0; void 0 !== t.wheelDelta ? e = t.wheelDelta : void 0 !== t.detail && (e = -t.detail), 0 < e ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 > e && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), v.update(), v.dispatchEvent(j), v.dispatchEvent(W), v.dispatchEvent(q) } } function s(t) { switch (t.keyCode) { case v.keys.UP: p = !1; break; case v.keys.BOTTOM: f = !1; break; case v.keys.LEFT: m = !1; break; case v.keys.RIGHT: g = !1 } } function c(t) { if (!1 !== v.enabled && !0 !== v.noKeys && !0 !== v.noRotate) { switch (t.keyCode) { case v.keys.UP: p = !0; break; case v.keys.BOTTOM: f = !0; break; case v.keys.LEFT: m = !0; break; case v.keys.RIGHT: g = !0 }(p || f || m || g) && (F = !0, p && (U = -v.rotateSpeed * v.momentumKeydownFactor), f && (U = v.rotateSpeed * v.momentumKeydownFactor), m && (z = -v.rotateSpeed * v.momentumKeydownFactor), g && (z = v.rotateSpeed * v.momentumKeydownFactor)) } } function h(t) { if (F = !1, z = U = 0, !1 !== v.enabled) { switch (t.touches.length) { case 1: if (!0 === v.noRotate) return; H = G.TOUCH_ROTATE, y.set(t.touches[0].pageX, t.touches[0].pageY); break; case 2: if (!0 === v.noZoom) return; H = G.TOUCH_DOLLY; var e = t.touches[0].pageX - t.touches[1].pageX; t = t.touches[0].pageY - t.touches[1].pageY, T.set(0, Math.sqrt(e * e + t * t)); break; case 3: if (!0 === v.noPan) return; H = G.TOUCH_PAN, w.set(t.touches[0].pageX, t.touches[0].pageY); break; default: H = G.NONE }H !== G.NONE && v.dispatchEvent(W) } } function l(t) { if (!1 !== v.enabled) { t.preventDefault(), t.stopPropagation(); var e = v.domElement === document ? v.domElement.body : v.domElement; switch (t.touches.length) { case 1: if (!0 === v.noRotate) break; if (H !== G.TOUCH_ROTATE) break; x.set(t.touches[0].pageX, t.touches[0].pageY), b.subVectors(x, y), v.rotateLeft(2 * Math.PI * b.x / e.clientWidth * v.rotateSpeed), v.rotateUp(2 * Math.PI * b.y / e.clientHeight * v.rotateSpeed), y.copy(x), d && (z = t.touches[0].pageX - d.pageX, U = t.touches[0].pageY - d.pageY), d = { pageX: t.touches[0].pageX, pageY: t.touches[0].pageY }, v.update(); break; case 2: if (!0 === v.noZoom) break; if (H !== G.TOUCH_DOLLY) break; e = t.touches[0].pageX - t.touches[1].pageX, t = t.touches[0].pageY - t.touches[1].pageY, S.set(0, Math.sqrt(e * e + t * t)), L.subVectors(S, T), 0 > L.y ? (v.object.fov = v.object.fov < v.maxFov ? v.object.fov + 1 : v.maxFov, v.object.updateProjectionMatrix()) : 0 < L.y && (v.object.fov = v.object.fov > v.minFov ? v.object.fov - 1 : v.minFov, v.object.updateProjectionMatrix()), T.copy(S), v.update(), v.dispatchEvent(j); break; case 3: if (!0 === v.noPan) break; if (H !== G.TOUCH_PAN) break; M.set(t.touches[0].pageX, t.touches[0].pageY), _.subVectors(M, w), v.pan(_.x, _.y), w.copy(M), v.update(); break; default: H = G.NONE } } } function u() { F = !0, d = void 0, !1 !== v.enabled && (v.dispatchEvent(q), H = G.NONE) } this.object = t, this.domElement = void 0 !== i ? i : document, this.frameId = null, this.enabled = !0, this.center = this.target = new e.Vector3, this.noZoom = !1, this.zoomSpeed = 1, this.minDistance = 0, this.maxDistance = 1 / 0, this.minZoom = 0, this.maxZoom = 1 / 0, this.noRotate = !1, this.rotateSpeed = -.15, this.noPan = !0, this.keyPanSpeed = 7, this.autoRotate = !1, this.autoRotateSpeed = 2, this.minPolarAngle = 0, this.maxPolarAngle = Math.PI, this.momentumDampingFactor = .9, this.momentumScalingFactor = -.005, this.momentumKeydownFactor = 20, this.minFov = 30, this.maxFov = 120, this.minAzimuthAngle = -1 / 0, this.maxAzimuthAngle = 1 / 0, this.noKeys = !1, this.keys = { LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40 }, this.mouseButtons = { ORBIT: e.MOUSE.LEFT, ZOOM: e.MOUSE.MIDDLE, PAN: e.MOUSE.RIGHT }; var d, p, f, m, g, v = this, y = new e.Vector2, x = new e.Vector2, b = new e.Vector2, w = new e.Vector2, M = new e.Vector2, _ = new e.Vector2, E = new e.Vector3, A = new e.Vector3, T = new e.Vector2, S = new e.Vector2, L = new e.Vector2, C = 0, R = 0, P = 0, I = 0, O = 1, D = new e.Vector3, N = new e.Vector3, B = new e.Quaternion, z = 0, U = 0, F = !1, G = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, TOUCH_ROTATE: 3, TOUCH_DOLLY: 4, TOUCH_PAN: 5 }, H = G.NONE; this.target0 = this.target.clone(), this.position0 = this.object.position.clone(), this.zoom0 = this.object.zoom; var k = (new e.Quaternion).setFromUnitVectors(t.up, new e.Vector3(0, 1, 0)), V = k.clone().inverse(), j = { type: "change" }, W = { type: "start" }, q = { type: "end" }; this.setLastQuaternion = function (t) { B.copy(t), v.object.quaternion.copy(t) }, this.getLastPosition = function () { return N }, this.rotateLeft = function (t) { void 0 === t && (t = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), I -= t }, this.rotateUp = function (t) { void 0 === t && (t = 2 * Math.PI / 60 / 60 * v.autoRotateSpeed), P -= t }, this.panLeft = function (t) { var e = this.object.matrix.elements; E.set(e[0], e[1], e[2]), E.multiplyScalar(-t), D.add(E) }, this.panUp = function (t) { var e = this.object.matrix.elements; E.set(e[4], e[5], e[6]), E.multiplyScalar(t), D.add(E) }, this.pan = function (t, i) { var n = v.domElement === document ? v.domElement.body : v.domElement; if (v.object instanceof e.PerspectiveCamera) { var r = v.object.position.clone().sub(v.target).length(); r *= Math.tan(v.object.fov / 2 * Math.PI / 180), v.panLeft(2 * t * r / n.clientHeight), v.panUp(2 * i * r / n.clientHeight) } else v.object instanceof e.OrthographicCamera ? (v.panLeft(t * (v.object.right - v.object.left) / n.clientWidth), v.panUp(i * (v.object.top - v.object.bottom) / n.clientHeight)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.") }, this.momentum = function () { F && (1e-4 > Math.abs(z) && 1e-4 > Math.abs(U) ? F = !1 : (U *= this.momentumDampingFactor, z *= this.momentumDampingFactor, I -= this.momentumScalingFactor * z, P -= this.momentumScalingFactor * U)) }, this.dollyIn = function (t) { void 0 === t && (t = Math.pow(.95, v.zoomSpeed)), v.object instanceof e.PerspectiveCamera ? O /= t : v.object instanceof e.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom * t)), v.object.updateProjectionMatrix(), v.dispatchEvent(j)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.") }, this.dollyOut = function (t) { void 0 === t && (t = Math.pow(.95, v.zoomSpeed)), v.object instanceof e.PerspectiveCamera ? O *= t : v.object instanceof e.OrthographicCamera ? (v.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / t)), v.object.updateProjectionMatrix(), v.dispatchEvent(j)) : console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.") }, this.update = function (t) { var e = this.object.position; A.copy(e).sub(this.target), A.applyQuaternion(k), C = Math.atan2(A.x, A.z), R = Math.atan2(Math.sqrt(A.x * A.x + A.z * A.z), A.y), this.autoRotate && H === G.NONE && this.rotateLeft(2 * Math.PI / 60 / 60 * v.autoRotateSpeed), this.momentum(), C += I, R += P, C = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, C)), R = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, R)), R = Math.max(1e-7, Math.min(Math.PI - 1e-7, R)); var i = A.length() * O; i = Math.max(this.minDistance, Math.min(this.maxDistance, i)), this.target.add(D), A.x = i * Math.sin(R) * Math.sin(C), A.y = i * Math.cos(R), A.z = i * Math.sin(R) * Math.cos(C), A.applyQuaternion(V), e.copy(this.target).add(A), this.object.lookAt(this.target), P = I = 0, O = 1, D.set(0, 0, 0), (1e-7 < N.distanceToSquared(this.object.position) || 1e-7 < 8 * (1 - B.dot(this.object.quaternion))) && (!0 !== t && this.dispatchEvent(j), N.copy(this.object.position), B.copy(this.object.quaternion)) }, this.reset = function () { H = G.NONE, this.target.copy(this.target0), this.object.position.copy(this.position0), this.object.zoom = this.zoom0, this.object.updateProjectionMatrix(), this.dispatchEvent(j), this.update() }, this.getPolarAngle = function () { return R }, this.getAzimuthalAngle = function () { return C }, this.dispose = function () { this.domElement.removeEventListener("mousedown", n), this.domElement.removeEventListener("mousewheel", a), this.domElement.removeEventListener("DOMMouseScroll", a), this.domElement.removeEventListener("touchstart", h), this.domElement.removeEventListener("touchend", u), this.domElement.removeEventListener("touchmove", l), window.removeEventListener("keyup", s), window.removeEventListener("keydown", c) }, this.domElement.addEventListener("mousedown", n, { passive: !1 }), this.domElement.addEventListener("mousewheel", a, { passive: !1 }), this.domElement.addEventListener("DOMMouseScroll", a, { passive: !1 }), this.domElement.addEventListener("touchstart", h, { passive: !1 }), this.domElement.addEventListener("touchend", u, { passive: !1 }), this.domElement.addEventListener("touchmove", l, { passive: !1 }), window.addEventListener("keyup", s, { passive: !1 }), window.addEventListener("keydown", c, { passive: !1 }), this.update() } function w(t, i) { var n = this, r = { type: "change" }, o = 0, a = 0, s = 0; this.camera = t, this.camera.rotation.reorder("YXZ"), this.domElement = void 0 !== i ? i : document, this.enabled = !0, this.deviceOrientation = null, this.alphaOffsetAngle = this.alpha = this.screenOrientation = 0; var c = function (t) { n.deviceOrientation = t }, h = function () { n.screenOrientation = window.orientation || 0 }, l = function (t) { t.preventDefault(), t.stopPropagation(), a = t.touches[0].pageX, s = t.touches[0].pageY }, u = function (t) { t.preventDefault(), t.stopPropagation(), o += e.Math.degToRad((s - t.touches[0].pageY) / 4), n.rotateLeft(-e.Math.degToRad((t.touches[0].pageX - a) / 4)), a = t.touches[0].pageX, s = t.touches[0].pageY }; this.connect = function () { h(), window.addEventListener("orientationchange", h, { passive: !0 }), window.addEventListener("deviceorientation", c, { passive: !0 }), window.addEventListener("deviceorientation", this.update.bind(this), { passive: !0 }), n.domElement.addEventListener("touchstart", l, { passive: !1 }), n.domElement.addEventListener("touchmove", u, { passive: !1 }), n.enabled = !0 }, this.disconnect = function () { window.removeEventListener("orientationchange", h, !1), window.removeEventListener("deviceorientation", c, !1), window.removeEventListener("deviceorientation", this.update.bind(this), !1), n.domElement.removeEventListener("touchstart", l, !1), n.domElement.removeEventListener("touchmove", u, !1), n.enabled = !1 }, this.update = function (t) { if (!1 !== n.enabled && n.deviceOrientation) { var i = n.deviceOrientation.alpha ? e.Math.degToRad(n.deviceOrientation.alpha) + n.alphaOffsetAngle : 0, a = n.deviceOrientation.beta ? e.Math.degToRad(n.deviceOrientation.beta) : 0, s = n.deviceOrientation.gamma ? e.Math.degToRad(n.deviceOrientation.gamma) : 0, c = n.screenOrientation ? e.Math.degToRad(n.screenOrientation) : 0, h = n.camera.quaternion, l = new e.Vector3(0, 0, 1), u = new e.Euler, d = new e.Quaternion, p = new e.Quaternion(-Math.sqrt(.5), 0, 0, Math.sqrt(.5)), f = new e.Quaternion, m = new e.Quaternion; if (0 == n.screenOrientation) { var g = new e.Vector3(1, 0, 0); f.setFromAxisAngle(g, -o) } else 180 == n.screenOrientation ? (g = new e.Vector3(1, 0, 0), f.setFromAxisAngle(g, o)) : 90 == n.screenOrientation ? (g = new e.Vector3(0, 1, 0), f.setFromAxisAngle(g, o)) : -90 == n.screenOrientation && (g = new e.Vector3(0, 1, 0), f.setFromAxisAngle(g, -o)); p.multiply(f), p.multiply(m), u.set(a, i, -s, "YXZ"), h.setFromEuler(u), h.multiply(p), h.multiply(d.setFromAxisAngle(l, -c)), n.alpha = i, !0 !== t && n.dispatchEvent(r) } }, this.updateAlphaOffsetAngle = function (t) { this.alphaOffsetAngle = t }, this.updateRotX = function (t) { o = t }, this.rotateLeft = function (t) { this.updateAlphaOffsetAngle(this.alphaOffsetAngle - t) }, this.rotateUp = function (t) { this.updateRotX(o + t) }, this.dispose = function () { this.disconnect() }, this.connect() } function M(t) { var i = new e.OrthographicCamera(-1, 1, 1, -1, 0, 1), n = new e.Scene, r = new e.StereoCamera; r.aspect = .5; var o = new e.WebGLRenderTarget(512, 512, { minFilter: e.LinearFilter, magFilter: e.NearestFilter, format: e.RGBAFormat }); o.scissorTest = !0, o.texture.generateMipmaps = !1; var a = new e.Vector2(.441, .156), s = new e.PlaneBufferGeometry(1, 1, 10, 20).removeAttribute("normal").toNonIndexed(), c = s.attributes.position.array, h = s.attributes.uv.array; s.attributes.position.count *= 2, s.attributes.uv.count *= 2; var l = new Float32Array(2 * c.length); l.set(c), l.set(c, c.length); var u = new Float32Array(2 * h.length); u.set(h), u.set(h, h.length), h = new e.Vector2, c = c.length / 3; for (var d = 0, p = l.length / 3; d < p; d++) { h.x = l[3 * d], h.y = l[3 * d + 1]; var f = h.dot(h); f = 1.5 + (a.x + a.y * f) * f; var m = d < c ? 0 : 1; l[3 * d] = h.x / f * 1.5 - .5 + m, l[3 * d + 1] = h.y / f * 3, u[2 * d] = .5 * (u[2 * d] + m) } s.attributes.position.array = l, s.attributes.uv.array = u, a = new e.MeshBasicMaterial({ map: o.texture }), s = new e.Mesh(s, a), n.add(s), this.setEyeSeparation = function (t) { r.eyeSep = t }, this.setSize = function (e, i) { t.setSize(e, i); var n = t.getPixelRatio(); o.setSize(e * n, i * n) }, this.render = function (e, a, s) { var c = s instanceof y || s instanceof x; e.updateMatrixWorld(), c && this.setEyeSeparation(s.stereo.eyeSep), null === a.parent && a.updateMatrixWorld(), r.update(a), a = o.width / 2; var h = o.height; t.autoClear && t.clear(), c && s.updateTextureToLeft(), o.scissor.set(0, 0, a, h), o.viewport.set(0, 0, a, h), t.setRenderTarget(o), t.render(e, r.cameraL), t.clearDepth(), c && s.updateTextureToRight(), o.scissor.set(a, 0, a, h), o.viewport.set(a, 0, a, h), t.setRenderTarget(o), t.render(e, r.cameraR), t.clearDepth(), t.setRenderTarget(null), t.render(n, i) } } function _(t) { t = void 0 === t ? {} : t; var i = this.options = Object.assign({ container: this.setupContainer(t.container), controlBar: !0, controlButtons: ["fullscreen", "setting", "video"], autoHideControlBar: !1, autoHideInfospot: !0, horizontalView: !1, clickTolerance: 10, cameraFov: 60, reverseDragging: !1, enableReticle: !1, dwellTime: 1500, autoReticleSelect: !0, viewIndicator: !1, indicatorSize: 30, output: null, autoRotate: !1, autoRotateSpeed: 2, autoRotateActivationDuration: 5e3, initialLookAt: new e.Vector3(0, 0, -Number.MAX_SAFE_INTEGER) }, t); t = i.container; var n = i.cameraFov, r = i.controlBar, o = i.controlButtons, a = i.viewIndicator, s = i.indicatorSize, c = i.enableReticle, h = i.reverseDragging, l = i.output, u = i.scene, d = i.camera; i = i.renderer; var p = t.clientWidth, f = t.clientHeight; this.container = t, this.scene = this.setupScene(u), this.sceneReticle = new e.Scene, this.camera = this.setupCamera(n, p / f, d), this.renderer = this.setupRenderer(i, t), this.reticle = this.addReticle(this.camera, this.sceneReticle), this.control = this.setupControls(this.camera, t), this.effect = this.setupEffects(this.renderer, t), this.mode = T.NORMAL, this.pressObject = this.pressEntityObject = this.infospot = this.hoverObject = this.widget = this.panorama = null, this.raycaster = new e.Raycaster, this.raycasterPoint = new e.Vector2, this.userMouse = new e.Vector2, this.updateCallbacks = [], this.requestAnimationId = null, this.cameraFrustum = new e.Frustum, this.cameraViewProjectionMatrix = new e.Matrix4, this.outputDivElement = this.autoRotateRequestId = null, this.touchSupported = "ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch, this.tweenLeftAnimation = new O.Tween, this.tweenUpAnimation = new O.Tween, this.outputEnabled = !1, this.viewIndicatorSize = s, this.tempEnableReticle = c, this.handlerMouseUp = this.onMouseUp.bind(this), this.handlerMouseDown = this.onMouseDown.bind(this), this.handlerMouseMove = this.onMouseMove.bind(this), this.handlerWindowResize = this.onWindowResize.bind(this), this.handlerKeyDown = this.onKeyDown.bind(this), this.handlerKeyUp = this.onKeyUp.bind(this), this.handlerTap = this.onTap.bind(this, { clientX: p / 2, clientY: f / 2 }), r && this.addDefaultControlBar(o), a && this.addViewIndicator(), h && this.reverseDraggingDirection(), c ? this.enableReticleControl() : this.registerMouseAndTouchEvents(), "overlay" === l && this.addOutputElement(), this.registerEventListeners(), this.animate.call(this) } var E = "^0.105.2".replace(/[^0-9.]/g, ""), A = { ORBIT: 0, DEVICEORIENTATION: 1 }, T = { UNKNOWN: 0, NORMAL: 1, CARDBOARD: 2, STEREO: 3 }, S = { TAB: 0, SBS: 1 }, L = { Info: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADBklEQVR42u2bP08UQRiHnzFaSYCI/xoksdBIqGwIiYWRUBISExpCQ0ej38FWOmlIKKhoMPEbaCxsrrHiYrQgOSlQEaICrT+LHSPZzNzt3s3c3Hn7lHvLzvv82L2dm30XKioqKgYY062BJF0HpoA7wARwBbhsPz4DjoEG8AnYNcZ8Sx1Op8IXJM1KWpdUV3nq9m9nJV1I7VNGfEzSM0mNNqR9NOwxx1L7NRMflbQm6SSgeJ4TO8Zoat+8/LKkg4jieQ4kLaf2RtKwpJ0uiufZkTScSn5S0l5C+b/sSZrstvyMpKPU5uc4kjTTjkvpeYCkaeA1/+7hvcIZMGuMqUULQNIU8Aa4ltrWwyHwyBizGzwASSPAe+B2assW7AH3jTE/i+xcZoa12Qfy2Bo3i+5cKABl99zF1GYlWFTBeULLS0DZrOsDcDNggTXgc27bLWA64BhfgHvGmB8dHUXZ1DM0S45xliKMs9bKr+klIOkqsBrwv9JtVq1DewEAT4Ch1BYdMGQdygeg7Df4SmqDAKyoyXpCszPgITCeuvoAjFuX0gE8jljUdv7bCtiOOJ7XpdUZ8L/gdXHOA5QtYH5NXXVgbrgWWn1nwFTqaiPgdPIFcDd1tRFwOl307DwRuZgXwLvctgfA04hjOp18AcReZ6sZY16e3yDpUuQxnU6+S2AkcjEpcDr1zxOXSPgCKLSa0mc4nXwB/EpdbQScTr4AGqmrjYDTyRfAx9TVRsDp5Aug8LJyH+F0cgZg58z11BUHpO5ruGh2G3ybuuqAeF2aBfAqddUB8bq0OgP2U1cegH3aOQOMMb+BrdTVB2DLupQLwLIOnKY26IBT6+ClaQDGmO/ARmqLDtiwDn7HVkcY+EdjNoTlCI+tYhO2iUppm6HKslPUq2qQKHpUe8AFsjaUXuUQWCgqXyoAG8IuME/WkNRrnAHzZfqDSgdgQ6gBc2Td3b3CMTBXtkOsIzTIjZLnQhjcVtlcEIPZLJ0LoVvt8s/Va+3yuSAG84UJRxB98cpM9dJURUVFxSDzBxKde4Lk3/h2AAAAAElFTkSuQmCC", Arrow: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADPklEQVR42u2bMUscQRiG30/SRaJEI1ZKUiRErNIELRUbQYSAnX8hpVUgkDYp0wgWVjYW+QcJaQzYpLojJIXhtDDEKBpj65ti58ixmdmb2ZvZ7+T2AUHudmfmeXf2bnb3O6CmpqZmgJGqOiI5AWAWwEMA0wDuArht3r4CcAagBeAbgIaI/NQOp1fhIZKLJN+SbDKcptl3keSQtk+I+BjJVyRbJaRdtEybY9p+ReKjJN+QvIwonufS9DGq7ZuXXyd5nFA8zzHJdW1vkLxDcrdC8Ty7JO9oyc+QPFCUb3NAcqZq+TmSp9rmHZySnCvjErwOIPkUwHv8+w7vF64ALIrIfrIASM4C+ADgnratgxMACyLSiB4AyREAnwE80LbswgGAJyJy4bNxyApr6wbIw4xxy3djrwCYfeeuaZsFsEbPdULXU4DZqusLgMkEA21P05EEbf8A8FhEzos28pkBLxLKL5s/r/M1kEkz9vKQHGeatf05yfmOfubNa7G5JDle5NhtBjwHMBz5yFwAWBaRT+0XzP8pZsKwcQiH2fX8Ycojb+kzxUw4ZJn7CSQXqpRPHMKCq7+iZJ71Mvdy/DftXSQ6HcJdSDaqPPKW/mPOBO+lcbvzCU35RCFM2PpwnQKzZQfdgfe0dxH5dLA6uQJ4pC2fIASrkyuA6X6QjxyC1ckVQNn7bNHlI4ZgdXIFUObiJJl8pBCsTjGfuIwA2Cv4FN7xbYjkjqsRAHuIePXoCiDF1Zk2VidXAL+1R5sAq5MrgJb2aBNgdXIF8FV7tAmwOrkCCFs73wysTtYATHFCU3vEEWm6Ci6KvgY/ao86Ik6XogDeaY86Ik6XbjPgSHvkEThCwQy45XpDRK5JbgN4GWkgUyR9H65MRQxgW0SunZ5FezK7pfwd8e8MV8UfAPdF5Jdrg8JrAbPjprZFD2wWyQP6j8ZSEufRmGlgQ9umBBvd5IOgbjFUKLu+XnWBhG+rpsFVZGUo/coJgFVf+aAATAgNACvICpL6jSsAKyH1QcEBmBD2ASwhq+7uF84ALIVWiPUEB7lQsiOEwS2VzQUxmMXSuRCqKpd/zX4rl88FMZg/mLAEcSN+MlP/aKqmpqZmkPkL0hSjwOpNKxwAAAAASUVORK5CYII=", FullscreenEnter: "data:image/svg+xml;base64,PHN2ZyBmaWxsPSIjRkZGRkZGIiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiIHdpZHRoPSIyNCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiLz4KICAgIDxwYXRoIGQ9Ik03IDE0SDV2NWg1di0ySDd2LTN6bS0yLTRoMlY3aDNWNUg1djV6bTEyIDdoLTN2Mmg1di01aC0ydjN6TTE0IDV2MmgzdjNoMlY1aC01eiIvPgo8L3N2Zz4=", FullscreenLeave: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE0SDE5VjE2SDE2VjE5SDE0VjE0TTUsMTRIMTBWMTlIOFYxNkg1VjE0TTgsNUgxMFYxMEg1VjhIOFY1TTE5LDhWMTBIMTRWNUgxNlY4SDE5WiIgLz48L3N2Zz4=", VideoPlay: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTgsNS4xNFYxOS4xNEwxOSwxMi4xNEw4LDUuMTRaIiAvPjwvc3ZnPg==", VideoPause: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggc3R5bGU9ImZpbGw6I2ZmZiIgZD0iTTE0LDE5LjE0SDE4VjUuMTRIMTRNNiwxOS4xNEgxMFY1LjE0SDZWMTkuMTRaIiAvPjwvc3ZnPg==", WhiteTile: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIABAMAAAAGVsnJAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAAB1WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iWE1QIENvcmUgNS40LjAiPgogICA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPgogICAgICA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIgogICAgICAgICAgICB4bWxuczp0aWZmPSJodHRwOi8vbnMuYWRvYmUuY29tL3RpZmYvMS4wLyI+CiAgICAgICAgIDx0aWZmOkNvbXByZXNzaW9uPjE8L3RpZmY6Q29tcHJlc3Npb24+CiAgICAgICAgIDx0aWZmOk9yaWVudGF0aW9uPjE8L3RpZmY6T3JpZW50YXRpb24+CiAgICAgICAgIDx0aWZmOlBob3RvbWV0cmljSW50ZXJwcmV0YXRpb24+MjwvdGlmZjpQaG90b21ldHJpY0ludGVycHJldGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KAtiABQAAACRQTFRFAAAAAAAABgYGBwcHHh4eKysrx8fHy8vLzMzM7OzsAAAABgYG+q7SZgAAAAp0Uk5TAP7+/v7+/v7+/iJx/a8AAAOwSURBVHja7d0hbsNAEAVQo6SFI6XEcALDcgNLvUBvEBQVhpkWVYWlhSsVFS7t5QIshRt695lEASZP+8c7a1kzDL1fz+/zyuvzp6FbvoddrL6uDd1yGZ5eXldeb18N3fIx7A+58prmhm65DfvDcd0952lu6JabFbD/zVprZj1lzcys+fj9z8xTZtbT8rv8yWlu6BYAIgAAAAAAAAAAAABAM6QXEAEAAAAAAAAAgJ2gnaAIiIA3Q2qAGgAAAAAAAAAAAAAAAAAAAAAAAAAAQJsADkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBVlfAcZ3aeZobusUKMGBhV6KUElHGKBERJR6/fxExRkQZl9/lT8S1oVsuhqyYMmPKjCkzvfcCpsxohrwY0Q06EAEAAAAAAAAAAACgGdILiAAAAAAAAAAAwE7QTlAERMCbITVADQAAAAAAAAAAAAAAAAAAAAAAAAAAwKmwQ1ERAAAAAACPQY9BERABERABERABERABERABAAAAAAAAAICdoJ2gCIiAT2bUADVADRABEQAAQBFUBEVABERgEyvAlJm+V4ApM6bMmDJjyowpM6bMdN0LmDKjGfJiRDfoQAQAAAAAAAAAAACAZkgvIAIAAAAAAAAAADtBO0EREAFvhtQANQAAAAAAAAAAAAAAAAAAAAAAAAAAAKfCDkVFAAAAAAA8Bj0GRUAEREAEREAEREAEREAEAAAAAAAAAAB2gnaCIiACPplRA9QANUAERAAAAEVQERQBERCBTawAU2b6XgGmzJgyY8qMKTOmzJgy03UvYMqMZsiLEd2gAxEAAAAAAAAAAAAAmiG9gAgAAAAAAAAAAOwE7QRFQAS8GVID1AAAAAAAAAAAAAAAAAAAAAAAAAAAAJwKOxQVAQAAAADwGPQYFAEREAEREAEREAEREAERAAAAAAAAAADYCdoJioAI+GRGDVAD1AAREAEAABRBRVAEREAENrECTJnpewWYMmPKjCkzpsyYMmPKTNe9gCkzmiEvRnSDDkQAAAAAAAAAAAAAaIb0AiIAAAAAAAAAALATtBMUARHwZkgNUAMAAAAAAAAAAAAAAAAAAAAAAAAAAHAq7FBUBAAAAADAY9BjUAREQAREQAREQAREQAREAAAAAAAAAABgJ2gnKAIi4JMZNUANUANEQAQAAFAEFUEREAER2MQKMGWm7xVgyowpM50PWen9ugNGXz1XaocAFgAAAABJRU5ErkJggg==", Setting: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABmJLR0QAAAAAAAD5Q7t/AAAACXBIWXMAAABIAAAASABGyWs+AAAACXZwQWcAAABAAAAAQADq8/hgAAADn0lEQVR42u2bzUsVURjGnyO6CPzAMnTjppAo3LTwH1CqTfaxbeOiRS37A0wXtROFVi1aRBs3LWohSIGbQAQXViBGRhG0UIRKUCpK7q/FnOB2uc6cOXNmRnGe3eW+H8/7zLln3vNxpQoVKlQ4wjBFJAFOSRqX1O7osivpvjHmU1nChBZglvSYLYJbS0EanCvIJzWK+gnsyH34/8OuMaYjb265jwCgz6N4SWq3vodbAEmnS/KtBDgoAgyU5BteAOAkMAPcBroc7PskDWfgN+wyDwBdltMMcDI3tYBnde/pHeARMNTErgd4APzweP834oeN1dMkz5DlsFNn/yyv4kdiSK4At4AO4CqwGaDwRmza2B0210qM7YhrXU59ANAq6bWkwQTTn5KO5fIE0uVYlXTeGLOXFMx1DrjlULwKKN41x6DlnIjEEQCckPRe0okCiguJr5LOGGO+xhm5jICJQ1i8LOeJJKPYEQAMKvrtt5ZdjSf2FM0Fq/sZJI2A6UNcvCz36TiDfUcAcE1SPu/U6Mm8k/TFfu6XdFb5iX3dGPM8lQfwNod3+TowBnQ3yddtv1vPIe+b1JIBiwEJ1IAJ208k5W21trWA+V/5CHAcmAtU/A2P/DcCiTAHHE8tgCVhgLvAXgYCk17Jo/yTGfLuWe7Zd72AC8CWB4n3OAz7mLytNkZabAEXMhfeQKYfWEpJZCxA3rGUOZeA/qDF15FpAz47EvlNk9neI2e3jeWCz0BbmvipNkSMMX8kuSZYM8Z8zyqAjbHmaN5mOeYjgIXrU93MWrxHrNQjrqiDkQMLHwG+OdqF3NN3jeXKzU8AoF1SzdH8XKhJUO7HZDXLMbwAwICkJUULFxe0SbqSVQAbw3Xi7Ze0ZLmGAzAKbHs0JGU1QtvAaIjCW4B7ZOvJy2qFa5a730RPtBiaz0CgnkiZi6F5fBZDVMvho7EhcuS3xJJ2hV9IupgTqaLw0hhzab8vq23xOG/r+LDsKjLgYVzxUnU0ltwK2wDezUyJmEwqXgp/PL4rvxthaeCSI+zxuA10J8ZkWdJNSb2SLkvayKHwDRu71+ZajrG941J8agALDQ3GU/a/IvMkYCPzmCbtLNEVmacNtgs5iP9fYVNEV1Q6Hez7yNZSL+J2SarTcpqiyV2iUkG0IvPFvbz5FbEn+KEk3wMjwMeSfCsBXFBdly9CAPk9ydyffpECuB5tZfVJjaKWueOSfinln6YK4lahQoUKRxd/AcRPGTcQCAUQAAAAAElFTkSuQmCC", ChevronRight: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTguNTksMTYuNThMMTMuMTcsMTJMOC41OSw3LjQxTDEwLDZMMTYsMTJMMTAsMThMOC41OSwxNi41OFoiIC8+PC9zdmc+", Check: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTIxLDdMOSwxOUwzLjUsMTMuNUw0LjkxLDEyLjA5TDksMTYuMTdMMTkuNTksNS41OUwyMSw3WiIgLz48L3N2Zz4=", ViewIndicator: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiBpZD0idmlldy1pbmRpY2F0b3IiIGhlaWdodD0iMzAiIHdpZHRoPSIzMCIgdmlld0JveD0iLTIuNSAtMSAzMCAzMCI+Cgk8c3R5bGUgdHlwZT0idGV4dC9jc3MiPi5zdDB7c3Ryb2tlLXdpZHRoOjI7c3Ryb2tlLW1pdGVybGltaXQ6MTA7ZmlsbDpub25lO30uc3Qxe3N0cm9rZS13aWR0aDo2O3N0cm9rZS1taXRlcmxpbWl0OjEwO30KCTwvc3R5bGU+Cgk8Zz4KCQk8cGF0aCBjbGFzcz0ic3QwIiBkPSJNIDEyLjUgMCBBIDEyLjUgMTIuNSAwIDAgMCAtMTIuNSAwIEEgMTIuNSAxMi41IDAgMCAwIDEyLjUgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDIiIGQ9Ik0gMTMgMCBMIDEwIDIgTCAxNiAyIFoiPjwvcGF0aD4KCQk8cGF0aCBjbGFzcz0ic3QyIiBkPSJNIDIgMCBBIDIgMiAwIDAgMCAtMiAwIEEgMiAyIDAgMCAwIDIgMCIgdHJhbnNmb3JtPSJtYXRyaXgoMSwwLDAsMSwxMywxNS41KSI+PC9wYXRoPgoJCTxwYXRoIGNsYXNzPSJzdDEiIGlkPSJpbmRpY2F0b3IiIHRyYW5zZm9ybT0ibWF0cml4KDEsMCwwLDEsMTMsMTUuNSkiPjwvcGF0aD4KCTwvZz4KPC9zdmc+" }, C = { load: function (t, i, n, r) { var o, a, s, c; for (c in i = void 0 === i ? function () { } : i, n = void 0 === n ? function () { } : n, r = void 0 === r ? function () { } : r, e.Cache.enabled = !0, L) L.hasOwnProperty(c) && t === L[c] && (o = c); var h = e.Cache.get(o || t); if (void 0 !== h) return i && setTimeout((function () { n({ loaded: 1, total: 1 }), i(h) }), 0), h; var l = window.URL || window.webkitURL, u = document.createElementNS("http://www.w3.org/1999/xhtml", "img"); e.Cache.add(o || t, u); var d = function () { l.revokeObjectURL(u.src), i(u) }; if (0 === t.indexOf("data:")) return u.addEventListener("load", d, !1), u.src = t, u; u.crossOrigin = void 0 !== this.crossOrigin ? this.crossOrigin : "", (o = new window.XMLHttpRequest).open("GET", t, !0), o.responseType = "arraybuffer", o.addEventListener("error", r), o.addEventListener("progress", (function (t) { if (t) { var e = t.loaded, i = t.total; t.lengthComputable && n({ loaded: e, total: i }) } })), o.addEventListener("loadend", (function (t) { t && (a = new Uint8Array(t.currentTarget.response), s = new window.Blob([a]), u.addEventListener("load", d, !1), u.src = l.createObjectURL(s)) })), o.send(null) } }, R = { load: function (t, i, n, r) { i = void 0 === i ? function () { } : i; var o = new e.Texture; return C.load(t, (function (n) { o.image = n, n = 0 < t.search(/\.(jpg|jpeg)$/) || 0 === t.search(/^data:image\/jpeg/), o.format = n ? e.RGBFormat : e.RGBAFormat, o.needsUpdate = !0, i(o) }), n, r), o } }, P = { load: function (t, i, n, r) { var o; i = void 0 === i ? function () { } : i, n = void 0 === n ? function () { } : n; var a = new e.CubeTexture([]), s = 0, c = {}, h = {}; return t.map((function (t, e) { C.load(t, (function (t) { a.images[e] = t, 6 === ++s && (a.needsUpdate = !0, i(a)) }), (function (t) { for (var i in c[e] = { loaded: t.loaded, total: t.total }, h.loaded = 0, o = h.total = 0, c) o++, h.loaded += c[i].loaded, h.total += c[i].total; 6 > o && (h.total = h.total / o * 6), n(h) }), r) })), a } }; i.prototype = Object.assign(Object.create(e.EventDispatcher.prototype), { setContainer: function (t) { this.container = t }, setScene: function (t) { this.scene = t }, enumerateDevices: function () { var t = this.devices, e = new Promise((function (e) { e(t) })); return 0 < t.length ? e : window.navigator.mediaDevices.enumerateDevices() }, switchNextVideoDevice: function () { var t = this.stop.bind(this), e = this.start.bind(this), i = this.setVideDeviceIndex.bind(this), n = this.videoDeviceIndex; this.getDevices("video").then((function (r) { t(), ++n >= r.length ? (i(0), n--) : i(n), e(r[n]) })) }, getDevices: function (t) { t = void 0 === t ? "video" : t; var e = this.devices; return this.enumerateDevices().then((function (t) { return t.map((function (t) { return e.includes(t) || e.push(t), t })) })).then((function (e) { var i = new RegExp(t, "i"); return e.filter((function (t) { return i.test(t.kind) })) })) }, getUserMedia: function (t) { var e = this.setMediaStream.bind(this), i = this.playVideo.bind(this); return window.navigator.mediaDevices.getUserMedia(t).then(e).then(i).catch((function (t) { console.warn("PANOLENS.Media: " + t) })) }, setVideDeviceIndex: function (t) { this.videoDeviceIndex = t }, start: function (t) { var e = this.constraints, i = this.getUserMedia.bind(this); return this.element = this.createVideoElement(), this.getDevices().then((function (n) { if (!n || 0 === n.length) throw Error("no video device found"); return e.video.deviceId = (t || n[0]).deviceId, i(e) })) }, stop: function () { var t = this.stream; t && t.active && (t.getTracks()[0].stop(), window.removeEventListener("resize", this.onWindowResize.bind(this)), this.stream = this.element = null) }, setMediaStream: function (t) { this.stream = t, this.element.srcObject = t, this.scene && (this.scene.background = this.createVideoTexture()), window.addEventListener("resize", this.onWindowResize.bind(this)) }, playVideo: function () { var t = this.element; t && (t.play(), this.dispatchEvent({ type: "play" })) }, pauseVideo: function () { var t = this.element; t && (t.pause(), this.dispatchEvent({ type: "pause" })) }, createVideoTexture: function () { var t = this.element, i = new e.VideoTexture(t); return i.generateMipmaps = !1, i.minFilter = e.LinearFilter, i.magFilter = e.LinearFilter, i.format = e.RGBFormat, i.center.set(.5, .5), t.addEventListener("canplay", this.onWindowResize.bind(this)), i }, createVideoElement: function () { var t = this.dispatchEvent.bind(this), e = document.createElement("video"); return e.setAttribute("autoplay", ""), e.setAttribute("muted", ""), e.setAttribute("playsinline", ""), e.style.position = "absolute", e.style.top = "0", e.style.left = "0", e.style.width = "100%", e.style.height = "100%", e.style.objectPosition = "center", e.style.objectFit = "cover", e.style.display = this.scene ? "none" : "", e.addEventListener("canplay", (function () { return t({ type: "canplay" }) })), e }, onWindowResize: function () { if (this.element && this.element.videoWidth && this.element.videoHeight && this.scene) { var t = this.container, e = t.clientWidth; t = t.clientHeight; var i = this.scene.background, n = this.element; n = n.videoHeight / n.videoWidth * (this.container ? e / t : 1) * this.ratioScalar, e > t ? i.repeat.set(n, 1) : i.repeat.set(1, 1 / n) } } }), Object.assign(n.prototype, { constructor: n, updateUniformByFormat: function (t, e) { this.format = t; var i = e.repeat.value; e = e.offset.value; var n = this.loffset, r = this.roffset; switch (t) { case S.TAB: i.set(1, .5), e.set(0, .5), n.set(0, .5), r.set(0, 0); break; case S.SBS: i.set(.5, 1), e.set(0, 0), n.set(0, 0), r.set(.5, 0) } }, updateTextureToLeft: function (t) { t.copy(this.loffset) }, updateTextureToRight: function (t) { t.copy(this.roffset) } }), r.prototype = Object.assign(Object.create(e.Sprite.prototype), { constructor: r, setColor: function (t) { this.material.color.copy(t instanceof e.Color ? t : new e.Color(t)) }, createCanvasTexture: function (t) { return (t = new e.CanvasTexture(t)).minFilter = e.LinearFilter, t.magFilter = e.LinearFilter, t.generateMipmaps = !1, t }, createCanvas: function () { var t = document.createElement("canvas"), e = t.getContext("2d"), i = this.dpr; return t.width = 32 * i, t.height = 32 * i, e.scale(i, i), e.shadowBlur = 5, e.shadowColor = "rgba(200,200,200,0.9)", { canvas: t, context: e } }, updateCanvasArcByProgress: function (t) { var e = this.context, i = this.canvasWidth, n = this.canvasHeight, r = this.material, o = this.dpr, a = t * Math.PI * 2, s = this.color.getStyle(), c = .5 * i / o; o = .5 * n / o, e.clearRect(0, 0, i, n), e.beginPath(), 0 === t ? (e.arc(c, o, i / 16, 0, 2 * Math.PI), e.fillStyle = s, e.fill()) : (e.arc(c, o, i / 4 - 3, -Math.PI / 2, -Math.PI / 2 + a), e.strokeStyle = s, e.lineWidth = 3, e.stroke()), e.closePath(), r.map.needsUpdate = !0 }, ripple: function () { var t = this, e = this.context, i = this.canvasWidth, n = this.canvasHeight, r = this.material, o = this.rippleDuration, a = performance.now(), s = this.color, c = this.dpr, h = .5 * i / c, l = .5 * n / c, u = function () { var d = window.requestAnimationFrame(u), p = (performance.now() - a) / o, f = 0 < 1 - p ? 1 - p : 0, m = p * i * .5 / c; e.clearRect(0, 0, i, n), e.beginPath(), e.arc(h, l, m, 0, 2 * Math.PI), e.fillStyle = "rgba(" + 255 * s.r + ", " + 255 * s.g + ", " + 255 * s.b + ", " + f + ")", e.fill(), e.closePath(), 1 <= p && (window.cancelAnimationFrame(d), t.updateCanvasArcByProgress(0), t.dispatchEvent({ type: "reticle-ripple-end" })), r.map.needsUpdate = !0 }; this.dispatchEvent({ type: "reticle-ripple-start" }), u() }, show: function () { this.visible = !0 }, hide: function () { this.visible = !1 }, start: function (t) { this.autoSelect && (this.dispatchEvent({ type: "reticle-start" }), this.startTimestamp = performance.now(), this.callback = t, this.update()) }, end: function () { this.startTimestamp && (window.cancelAnimationFrame(this.timerId), this.updateCanvasArcByProgress(0), this.startTimestamp = this.timerId = this.callback = null, this.dispatchEvent({ type: "reticle-end" })) }, update: function () { this.timerId = window.requestAnimationFrame(this.update.bind(this)); var t = (performance.now() - this.startTimestamp) / this.dwellTime; this.updateCanvasArcByProgress(t), this.dispatchEvent({ type: "reticle-update", progress: t }), 1 <= t && (window.cancelAnimationFrame(this.timerId), this.callback && this.callback(), this.end(), this.ripple()) } }); var I, O = (function (t, e) { (e = function () { this._tweens = {}, this._tweensAddedDuringUpdate = {} }).prototype = { getAll: function () { return Object.keys(this._tweens).map(function (t) { return this._tweens[t] }.bind(this)) }, removeAll: function () { this._tweens = {} }, add: function (t) { this._tweens[t.getId()] = t, this._tweensAddedDuringUpdate[t.getId()] = t }, remove: function (t) { delete this._tweens[t.getId()], delete this._tweensAddedDuringUpdate[t.getId()] }, update: function (t, e) { var n = Object.keys(this._tweens); if (0 === n.length) return !1; for (t = void 0 !== t ? t : i.now(); 0 < n.length;) { this._tweensAddedDuringUpdate = {}; for (var r = 0; r < n.length; r++) { var o = this._tweens[n[r]]; o && !1 === o.update(t) && (o._isPlaying = !1, e || delete this._tweens[n[r]]) } n = Object.keys(this._tweensAddedDuringUpdate) } return !0 } }; var i = new e; i.Group = e, i._nextId = 0, i.nextId = function () { return i._nextId++ }, i.now = "undefined" == typeof self && "undefined" != typeof process && process.hrtime ? function () { var t = process.hrtime(); return 1e3 * t[0] + t[1] / 1e6 } : "undefined" != typeof self && void 0 !== self.performance && void 0 !== self.performance.now ? self.performance.now.bind(self.performance) : void 0 !== Date.now ? Date.now : function () { return (new Date).getTime() }, i.Tween = function (t, e) { this._object = t, this._valuesStart = {}, this._valuesEnd = {}, this._valuesStartRepeat = {}, this._duration = 1e3, this._repeat = 0, this._repeatDelayTime = void 0, this._reversed = this._isPlaying = this._yoyo = !1, this._delayTime = 0, this._startTime = null, this._easingFunction = i.Easing.Linear.None, this._interpolationFunction = i.Interpolation.Linear, this._chainedTweens = [], this._onStartCallback = null, this._onStartCallbackFired = !1, this._onStopCallback = this._onCompleteCallback = this._onRepeatCallback = this._onUpdateCallback = null, this._group = e || i, this._id = i.nextId() }, i.Tween.prototype = { getId: function () { return this._id }, isPlaying: function () { return this._isPlaying }, to: function (t, e) { return this._valuesEnd = Object.create(t), void 0 !== e && (this._duration = e), this }, duration: function (t) { return this._duration = t, this }, start: function (t) { for (var e in this._group.add(this), this._isPlaying = !0, this._onStartCallbackFired = !1, this._startTime = void 0 !== t ? "string" == typeof t ? i.now() + parseFloat(t) : t : i.now(), this._startTime += this._delayTime, this._valuesEnd) { if (this._valuesEnd[e] instanceof Array) { if (0 === this._valuesEnd[e].length) continue; this._valuesEnd[e] = [this._object[e]].concat(this._valuesEnd[e]) } void 0 !== this._object[e] && (this._valuesStart[e] = this._object[e], 0 == this._valuesStart[e] instanceof Array && (this._valuesStart[e] *= 1), this._valuesStartRepeat[e] = this._valuesStart[e] || 0) } return this }, stop: function () { return this._isPlaying ? (this._group.remove(this), this._isPlaying = !1, null !== this._onStopCallback && this._onStopCallback(this._object), this.stopChainedTweens(), this) : this }, end: function () { return this.update(1 / 0), this }, stopChainedTweens: function () { for (var t = 0, e = this._chainedTweens.length; t < e; t++)this._chainedTweens[t].stop() }, group: function (t) { return this._group = t, this }, delay: function (t) { return this._delayTime = t, this }, repeat: function (t) { return this._repeat = t, this }, repeatDelay: function (t) { return this._repeatDelayTime = t, this }, yoyo: function (t) { return this._yoyo = t, this }, easing: function (t) { return this._easingFunction = t, this }, interpolation: function (t) { return this._interpolationFunction = t, this }, chain: function () { return this._chainedTweens = arguments, this }, onStart: function (t) { return this._onStartCallback = t, this }, onUpdate: function (t) { return this._onUpdateCallback = t, this }, onRepeat: function (t) { return this._onRepeatCallback = t, this }, onComplete: function (t) { return this._onCompleteCallback = t, this }, onStop: function (t) { return this._onStopCallback = t, this }, update: function (t) { var e; if (t < this._startTime) return !0; !1 === this._onStartCallbackFired && (null !== this._onStartCallback && this._onStartCallback(this._object), this._onStartCallbackFired = !0); var i = (t - this._startTime) / this._duration; i = 0 === this._duration || 1 < i ? 1 : i; var n = this._easingFunction(i); for (e in this._valuesEnd) if (void 0 !== this._valuesStart[e]) { var r = this._valuesStart[e] || 0, o = this._valuesEnd[e]; o instanceof Array ? this._object[e] = this._interpolationFunction(o, n) : ("string" == typeof o && (o = "+" === o.charAt(0) || "-" === o.charAt(0) ? r + parseFloat(o) : parseFloat(o)), "number" == typeof o && (this._object[e] = r + (o - r) * n)) } if (null !== this._onUpdateCallback && this._onUpdateCallback(this._object, i), 1 === i) { if (!(0 < this._repeat)) { for (null !== this._onCompleteCallback && this._onCompleteCallback(this._object), t = 0, e = this._chainedTweens.length; t < e; t++)this._chainedTweens[t].start(this._startTime + this._duration); return !1 } for (e in isFinite(this._repeat) && this._repeat--, this._valuesStartRepeat) "string" == typeof this._valuesEnd[e] && (this._valuesStartRepeat[e] += parseFloat(this._valuesEnd[e])), this._yoyo && (i = this._valuesStartRepeat[e], this._valuesStartRepeat[e] = this._valuesEnd[e], this._valuesEnd[e] = i), this._valuesStart[e] = this._valuesStartRepeat[e]; this._yoyo && (this._reversed = !this._reversed), this._startTime = void 0 !== this._repeatDelayTime ? t + this._repeatDelayTime : t + this._delayTime, null !== this._onRepeatCallback && this._onRepeatCallback(this._object) } return !0 } }, i.Easing = { Linear: { None: function (t) { return t } }, Quadratic: { In: function (t) { return t * t }, Out: function (t) { return t * (2 - t) }, InOut: function (t) { return 1 > (t *= 2) ? .5 * t * t : -.5 * (--t * (t - 2) - 1) } }, Cubic: { In: function (t) { return t * t * t }, Out: function (t) { return --t * t * t + 1 }, InOut: function (t) { return 1 > (t *= 2) ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2) } }, Quartic: { In: function (t) { return t * t * t * t }, Out: function (t) { return 1 - --t * t * t * t }, InOut: function (t) { return 1 > (t *= 2) ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2) } }, Quintic: { In: function (t) { return t * t * t * t * t }, Out: function (t) { return --t * t * t * t * t + 1 }, InOut: function (t) { return 1 > (t *= 2) ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2) } }, Sinusoidal: { In: function (t) { return 1 - Math.cos(t * Math.PI / 2) }, Out: function (t) { return Math.sin(t * Math.PI / 2) }, InOut: function (t) { return .5 * (1 - Math.cos(Math.PI * t)) } }, Exponential: { In: function (t) { return 0 === t ? 0 : Math.pow(1024, t - 1) }, Out: function (t) { return 1 === t ? 1 : 1 - Math.pow(2, -10 * t) }, InOut: function (t) { return 0 === t ? 0 : 1 === t ? 1 : 1 > (t *= 2) ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1))) } }, Circular: { In: function (t) { return 1 - Math.sqrt(1 - t * t) }, Out: function (t) { return Math.sqrt(1 - --t * t) }, InOut: function (t) { return 1 > (t *= 2) ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1) } }, Elastic: { In: function (t) { return 0 === t ? 0 : 1 === t ? 1 : -Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) }, Out: function (t) { return 0 === t ? 0 : 1 === t ? 1 : Math.pow(2, -10 * t) * Math.sin(5 * (t - .1) * Math.PI) + 1 }, InOut: function (t) { return 0 === t ? 0 : 1 === t ? 1 : 1 > (t *= 2) ? -.5 * Math.pow(2, 10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) : .5 * Math.pow(2, -10 * (t - 1)) * Math.sin(5 * (t - 1.1) * Math.PI) + 1 } }, Back: { In: function (t) { return t * t * (2.70158 * t - 1.70158) }, Out: function (t) { return --t * t * (2.70158 * t + 1.70158) + 1 }, InOut: function (t) { return 1 > (t *= 2) ? .5 * t * t * (3.5949095 * t - 2.5949095) : .5 * ((t -= 2) * t * (3.5949095 * t + 2.5949095) + 2) } }, Bounce: { In: function (t) { return 1 - i.Easing.Bounce.Out(1 - t) }, Out: function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375 }, InOut: function (t) { return .5 > t ? .5 * i.Easing.Bounce.In(2 * t) : .5 * i.Easing.Bounce.Out(2 * t - 1) + .5 } } }, i.Interpolation = { Linear: function (t, e) { var n = t.length - 1, r = n * e, o = Math.floor(r), a = i.Interpolation.Utils.Linear; return 0 > e ? a(t[0], t[1], r) : 1 < e ? a(t[n], t[n - 1], n - r) : a(t[o], t[o + 1 > n ? n : o + 1], r - o) }, Bezier: function (t, e) { for (var n = 0, r = t.length - 1, o = Math.pow, a = i.Interpolation.Utils.Bernstein, s = 0; s <= r; s++)n += o(1 - e, r - s) * o(e, s) * t[s] * a(r, s); return n }, CatmullRom: function (t, e) { var n = t.length - 1, r = n * e, o = Math.floor(r), a = i.Interpolation.Utils.CatmullRom; return t[0] === t[n] ? (0 > e && (o = Math.floor(r = n * (1 + e))), a(t[(o - 1 + n) % n], t[o], t[(o + 1) % n], t[(o + 2) % n], r - o)) : 0 > e ? t[0] - (a(t[0], t[0], t[1], t[1], -r) - t[0]) : 1 < e ? t[n] - (a(t[n], t[n], t[n - 1], t[n - 1], r - n) - t[n]) : a(t[o ? o - 1 : 0], t[o], t[n < o + 1 ? n : o + 1], t[n < o + 2 ? n : o + 2], r - o) }, Utils: { Linear: function (t, e, i) { return (e - t) * i + t }, Bernstein: function (t, e) { var n = i.Interpolation.Utils.Factorial; return n(t) / n(e) / n(t - e) }, Factorial: function () { var t = [1]; return function (e) { var i = 1; if (t[e]) return t[e]; for (var n = e; 1 < n; n--)i *= n; return t[e] = i } }(), CatmullRom: function (t, e, i, n, r) { var o = r * r; return (2 * e - 2 * i + (t = .5 * (i - t)) + (n = .5 * (n - e))) * r * o + (-3 * e + 3 * i - 2 * t - n) * o + t * r + e } } }, t.exports = i }(I = { exports: {} }, I.exports), I.exports); o.prototype = Object.assign(Object.create(e.Sprite.prototype), { constructor: o, setContainer: function (t) { if (t instanceof HTMLElement) var e = t; else t && t.container && (e = t.container); e && this.element && e.appendChild(this.element), this.container = e }, getContainer: function () { return this.container }, onClick: function (t) { this.element && this.getContainer() && (this.onHoverStart(t), this.lockHoverElement()) }, onDismiss: function () { this.element && (this.unlockHoverElement(), this.onHoverEnd()) }, onHover: function () { }, onHoverStart: function (t) { if (this.getContainer()) { var e = this.cursorStyle || (this.mode === T.NORMAL ? "pointer" : "default"), i = this.scaleDownAnimation, n = this.scaleUpAnimation, r = this.element; this.isHovering = !0, this.container.style.cursor = e, this.animated && (i.stop(), n.start()), r && 0 <= t.mouseEvent.clientX && 0 <= t.mouseEvent.clientY && (t = r.left, e = r.right, i = r.style, this.mode === T.CARDBOARD || this.mode === T.STEREO ? (i.display = "none", t.style.display = "block", e.style.display = "block", r._width = t.clientWidth, r._height = t.clientHeight) : (i.display = "block", t && (t.style.display = "none"), e && (e.style.display = "none"), r._width = r.clientWidth, r._height = r.clientHeight)) } }, onHoverEnd: function () { if (this.getContainer()) { var t = this.scaleDownAnimation, e = this.scaleUpAnimation, i = this.element; this.isHovering = !1, this.container.style.cursor = "default", this.animated && (e.stop(), t.start()), i && !this.element.locked && (t = i.left, e = i.right, i.style.display = "none", t && (t.style.display = "none"), e && (e.style.display = "none"), this.unlockHoverElement()) } }, onDualEyeEffect: function (t) { if (this.getContainer()) { this.mode = t.mode, t = this.element; var e = this.container.clientWidth / 2, i = this.container.clientHeight / 2; t && (t.left || t.right || (t.left = t.cloneNode(!0), t.right = t.cloneNode(!0)), this.mode === T.CARDBOARD || this.mode === T.STEREO ? (t.left.style.display = t.style.display, t.right.style.display = t.style.display, t.style.display = "none") : (t.style.display = t.left.style.display, t.left.style.display = "none", t.right.style.display = "none"), this.translateElement(e, i), this.container.appendChild(t.left), this.container.appendChild(t.right)) } }, translateElement: function (t, e) { if (this.element._width && this.element._height && this.getContainer()) { var i = this.container, n = this.element, r = n._width / 2, o = n._height / 2, a = void 0 !== n.verticalDelta ? n.verticalDelta : 40, s = t - r, c = e - o - a; this.mode !== T.CARDBOARD && this.mode !== T.STEREO || !n.left || !n.right || t === i.clientWidth / 2 && e === i.clientHeight / 2 ? this.setElementStyle("transform", n, "translate(" + s + "px, " + c + "px)") : (s = i.clientWidth / 4 - r + (t - i.clientWidth / 2), c = i.clientHeight / 2 - o - a + (e - i.clientHeight / 2), this.setElementStyle("transform", n.left, "translate(" + s + "px, " + c + "px)"), s += i.clientWidth / 2, this.setElementStyle("transform", n.right, "translate(" + s + "px, " + c + "px)")) } }, setElementStyle: function (t, e, i) { e = e.style, "transform" === t && (e.webkitTransform = e.msTransform = e.transform = i) }, setText: function (t) { this.element && (this.element.textContent = t) }, setCursorHoverStyle: function (t) { this.cursorStyle = t }, addHoverText: function (t, e) { e = void 0 === e ? 40 : e, this.element || (this.element = document.createElement("div"), this.element.style.display = "none", this.element.style.color = "#fff", this.element.style.top = 0, this.element.style.maxWidth = "50%", this.element.style.maxHeight = "50%", this.element.style.textShadow = "0 0 3px #000000", this.element.style.fontFamily = '"Trebuchet MS", Helvetica, sans-serif', this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = e), this.setText(t) }, addHoverElement: function (t, e) { e = void 0 === e ? 40 : e, this.element || (this.element = t.cloneNode(!0), this.element.style.display = "none", this.element.style.top = 0, this.element.style.position = "absolute", this.element.classList.add("panolens-infospot"), this.element.verticalDelta = e) }, removeHoverElement: function () { this.element && (this.element.left && (this.container.removeChild(this.element.left), this.element.left = null), this.element.right && (this.container.removeChild(this.element.right), this.element.right = null), this.container.removeChild(this.element), this.element = null) }, lockHoverElement: function () { this.element && (this.element.locked = !0) }, unlockHoverElement: function () { this.element && (this.element.locked = !1) }, enableRaycast: function (t) { this.raycast = void 0 === t || t ? this.originalRaycast : function () { } }, show: function (t) { t = void 0 === t ? 0 : t; var e = this.hideAnimation, i = this.showAnimation, n = this.material; this.animated ? (e.stop(), i.delay(t).start()) : (this.enableRaycast(!0), n.opacity = 1) }, hide: function (t) { t = void 0 === t ? 0 : t; var e = this.hideAnimation, i = this.showAnimation, n = this.material; this.animated ? (i.stop(), e.delay(t).start()) : (this.enableRaycast(!1), n.opacity = 0) }, setFocusMethod: function (t) { t && (this.HANDLER_FOCUS = t.method) }, focus: function (t, e) { this.HANDLER_FOCUS && (this.HANDLER_FOCUS(this.position, t, e), this.onDismiss()) }, dispose: function () { var t = this.geometry, e = this.material, i = e.map; this.removeHoverElement(), this.parent && this.parent.remove(this), i && (i.dispose(), e.map = null), t && (t.dispose(), this.geometry = null), e && (e.dispose(), this.material = null) } }), a.prototype = Object.assign(Object.create(e.EventDispatcher.prototype), { constructor: a, addControlBar: function () { if (this.container) { var t = this, e = document.createElement("div"); e.style.width = "100%", e.style.height = "44px", e.style.float = "left", e.style.transform = e.style.webkitTransform = e.style.msTransform = "translateY(-100%)", e.style.background = "-webkit-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", e.style.background = "-moz-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", e.style.background = "-o-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", e.style.background = "-ms-linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", e.style.background = "linear-gradient(bottom, rgba(0,0,0,0.2), rgba(0,0,0,0))", e.style.transition = this.DEFAULT_TRANSITION, e.style.pointerEvents = "none", e.isHidden = !1, e.toggle = function () { e.isHidden = !e.isHidden; var t = e.isHidden ? 0 : 1; e.style.transform = e.style.webkitTransform = e.style.msTransform = e.isHidden ? "translateY(0)" : "translateY(-100%)", e.style.opacity = t }; var i = this.createDefaultMenu(); this.mainMenu = this.createMainMenu(i), e.appendChild(this.mainMenu), this.mask = i = this.createMask(), this.container.appendChild(i), e.dispose = function () { t.fullscreenElement && (e.removeChild(t.fullscreenElement), t.fullscreenElement.dispose(), t.fullscreenElement = null), t.settingElement && (e.removeChild(t.settingElement), t.settingElement.dispose(), t.settingElement = null), t.videoElement && (e.removeChild(t.videoElement), t.videoElement.dispose(), t.videoElement = null) }, this.container.appendChild(e), this.mask.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), this.mask.addEventListener(t.TOUCH_ENABLED ? "touchend" : "click", (function (e) { e.preventDefault(), e.stopPropagation(), t.mask.hide(), t.settingElement.deactivate() }), !1), this.addEventListener("control-bar-toggle", e.toggle), this.barElement = e } else console.warn("Widget container not set") }, createDefaultMenu: function () { var t = this, e = function (e, i) { return function () { t.dispatchEvent({ type: "panolens-viewer-handler", method: e, data: i }) } }; return [{ title: "Control", subMenu: [{ title: this.TOUCH_ENABLED ? "Touch" : "Mouse", handler: e("enableControl", A.ORBIT) }, { title: "Sensor", handler: e("enableControl", A.DEVICEORIENTATION) }] }, { title: "Mode", subMenu: [{ title: "Normal", handler: e("disableEffect") }, { title: "Cardboard", handler: e("enableEffect", T.CARDBOARD) }, { title: "Stereoscopic", handler: e("enableEffect", T.STEREO) }] }] }, addControlButton: function (t) { switch (t) { case "fullscreen": this.fullscreenElement = t = this.createFullscreenButton(); break; case "setting": this.settingElement = t = this.createSettingButton(); break; case "video": this.videoElement = t = this.createVideoControl(); break; default: return }t && this.barElement.appendChild(t) }, createMask: function () { var t = document.createElement("div"); return t.style.position = "absolute", t.style.top = 0, t.style.left = 0, t.style.width = "100%", t.style.height = "100%", t.style.background = "transparent", t.style.display = "none", t.show = function () { this.style.display = "block" }, t.hide = function () { this.style.display = "none" }, t }, createSettingButton: function () { var t = this, e = this.createCustomItem({ style: { backgroundImage: 'url("' + L.Setting + '")', webkitTransition: this.DEFAULT_TRANSITION, transition: this.DEFAULT_TRANSITION }, onTap: function (e) { e.preventDefault(), e.stopPropagation(), t.mainMenu.toggle(), this.activated ? this.deactivate() : this.activate() } }); return e.activate = function () { this.style.transform = "rotate3d(0,0,1,90deg)", this.activated = !0, t.mask.show() }, e.deactivate = function () { this.style.transform = "rotate3d(0,0,0,0)", this.activated = !1, t.mask.hide(), t.mainMenu && t.mainMenu.visible && t.mainMenu.hide(), t.activeSubMenu && t.activeSubMenu.visible && t.activeSubMenu.hide(), t.mainMenu && t.mainMenu._width && (t.mainMenu.changeSize(t.mainMenu._width), t.mainMenu.unslideAll()) }, e.activated = !1, e }, createFullscreenButton: function () { function t() { n && (i = !i, o.style.backgroundImage = i ? 'url("' + L.FullscreenLeave + '")' : 'url("' + L.FullscreenEnter + '")'), e.dispatchEvent({ type: "panolens-viewer-handler", method: "onWindowResize" }), n = !0 } var e = this, i = !1, n = !0, r = this.container; if (document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled) { document.addEventListener("fullscreenchange", t, !1), document.addEventListener("webkitfullscreenchange", t, !1), document.addEventListener("mozfullscreenchange", t, !1), document.addEventListener("MSFullscreenChange", t, !1); var o = this.createCustomItem({ style: { backgroundImage: 'url("' + L.FullscreenEnter + '")' }, onTap: function (t) { t.preventDefault(), t.stopPropagation(), n = !1, i ? (document.exitFullscreen && document.exitFullscreen(), document.msExitFullscreen && document.msExitFullscreen(), document.mozCancelFullScreen && document.mozCancelFullScreen(), document.webkitExitFullscreen && document.webkitExitFullscreen(), i = !1) : (r.requestFullscreen && r.requestFullscreen(), r.msRequestFullscreen && r.msRequestFullscreen(), r.mozRequestFullScreen && r.mozRequestFullScreen(), r.webkitRequestFullscreen && r.webkitRequestFullscreen(Element.ALLOW_KEYBOARD_INPUT), i = !0), this.style.backgroundImage = i ? 'url("' + L.FullscreenLeave + '")' : 'url("' + L.FullscreenEnter + '")' } }); if (!document.querySelector("panolens-style-addon")) { var a = document.createElement("style"); a.id = "panolens-style-addon", a.innerHTML = ":-webkit-full-screen { width: 100% !important; height: 100% !important }", document.body.appendChild(a) } return o } }, createVideoControl: function () { var t = document.createElement("span"); return t.style.display = "none", t.show = function () { t.style.display = "" }, t.hide = function () { t.style.display = "none", t.controlButton.paused = !0, t.controlButton.update() }, t.controlButton = this.createVideoControlButton(), t.seekBar = this.createVideoControlSeekbar(), t.appendChild(t.controlButton), t.appendChild(t.seekBar), t.dispose = function () { t.removeChild(t.controlButton), t.removeChild(t.seekBar), t.controlButton.dispose(), t.controlButton = null, t.seekBar.dispose(), t.seekBar = null }, this.addEventListener("video-control-show", t.show), this.addEventListener("video-control-hide", t.hide), t }, createVideoControlButton: function () { var t = this, e = this.createCustomItem({ style: { float: "left", backgroundImage: 'url("' + L.VideoPlay + '")' }, onTap: function (i) { i.preventDefault(), i.stopPropagation(), t.dispatchEvent({ type: "panolens-viewer-handler", method: "toggleVideoPlay", data: !this.paused }), this.paused = !this.paused, e.update() } }); return e.paused = !0, e.update = function (t) { this.paused = void 0 !== t ? t : this.paused, this.style.backgroundImage = 'url("' + (this.paused ? L.VideoPlay : L.VideoPause) + '")' }, e }, createVideoControlSeekbar: function () { function t(t) { t.stopPropagation(), c = !0, r = t.clientX || t.changedTouches && t.changedTouches[0].clientX, o = parseInt(h.style.width) / 100, s.container.addEventListener("mousemove", e, { passive: !0 }), s.container.addEventListener("mouseup", i, { passive: !0 }), s.container.addEventListener("touchmove", e, { passive: !0 }), s.container.addEventListener("touchend", i, { passive: !0 }) } function e(t) { c && (a = ((t.clientX || t.changedTouches && t.changedTouches[0].clientX) - r) / u.clientWidth, a = 1 < (a = o + a) ? 1 : 0 > a ? 0 : a, u.setProgress(a), s.dispatchEvent({ type: "panolens-viewer-handler", method: "setVideoCurrentTime", data: a })) } function i(t) { t.stopPropagation(), c = !1, n() } function n() { s.container.removeEventListener("mousemove", e, !1), s.container.removeEventListener("mouseup", i, !1), s.container.removeEventListener("touchmove", e, !1), s.container.removeEventListener("touchend", i, !1) } var r, o, a, s = this, c = !1, h = document.createElement("div"); h.style.width = "0%", h.style.height = "100%", h.style.backgroundColor = "#fff"; var l = document.createElement("div"); l.style.float = "right", l.style.width = "14px", l.style.height = "14px", l.style.transform = "translate(7px, -5px)", l.style.borderRadius = "50%", l.style.backgroundColor = "#ddd", l.addEventListener("mousedown", t, { passive: !0 }), l.addEventListener("touchstart", t, { passive: !0 }), h.appendChild(l); var u = this.createCustomItem({ style: { float: "left", width: "30%", height: "4px", marginTop: "20px", backgroundColor: "rgba(188,188,188,0.8)" }, onTap: function (t) { if (t.preventDefault(), t.stopPropagation(), t.target !== l) { var e = t.changedTouches && 0 < t.changedTouches.length ? (t.changedTouches[0].pageX - t.target.getBoundingClientRect().left) / this.clientWidth : t.offsetX / this.clientWidth; s.dispatchEvent({ type: "panolens-viewer-handler", method: "setVideoCurrentTime", data: e }), u.setProgress(t.offsetX / this.clientWidth) } }, onDispose: function () { n(), l = h = null } }); return u.appendChild(h), u.setProgress = function (t) { h.style.width = 100 * t + "%" }, this.addEventListener("video-update", (function (t) { u.setProgress(t.percentage) })), u.progressElement = h, u.progressElementControl = l, u }, createMenuItem: function (t) { var e = this, i = document.createElement("a"); return i.textContent = t, i.style.display = "block", i.style.padding = "10px", i.style.textDecoration = "none", i.style.cursor = "pointer", i.style.pointerEvents = "auto", i.style.transition = this.DEFAULT_TRANSITION, i.slide = function (t) { this.style.transform = "translateX(" + (t ? "" : "-") + "100%)" }, i.unslide = function () { this.style.transform = "translateX(0)" }, i.setIcon = function (t) { this.icon && (this.icon.style.backgroundImage = "url(" + t + ")") }, i.setSelectionTitle = function (t) { this.selection && (this.selection.textContent = t) }, i.addSelection = function (t) { var e = document.createElement("span"); return e.style.fontSize = "13px", e.style.fontWeight = "300", e.style.float = "right", this.selection = e, this.setSelectionTitle(t), this.appendChild(e), this }, i.addIcon = function (t, e, i) { t = void 0 === t ? L.ChevronRight : t, e = void 0 !== e && e, i = void 0 !== i && i; var n = document.createElement("span"); return n.style.float = e ? "left" : "right", n.style.width = "17px", n.style.height = "17px", n.style["margin" + (e ? "Right" : "Left")] = "12px", n.style.backgroundSize = "cover", i && (n.style.transform = "rotateZ(180deg)"), this.icon = n, this.setIcon(t), this.appendChild(n), this }, i.addSubMenu = function (t, i) { return this.subMenu = e.createSubMenu(t, i), this }, i.addEventListener("mouseenter", (function () { this.style.backgroundColor = "#e0e0e0" }), !1), i.addEventListener("mouseleave", (function () { this.style.backgroundColor = "#fafafa" }), !1), i }, createMenuItemHeader: function (t) { return (t = this.createMenuItem(t)).style.borderBottom = "1px solid #333", t.style.paddingBottom = "15px", t }, createMainMenu: function (t) { function e(t) { t.preventDefault(), t.stopPropagation(); var e = i.mainMenu, n = this.subMenu; e.hide(), e.slideAll(), e.parentElement.appendChild(n), i.activeMainItem = this, i.activeSubMenu = n, window.requestAnimationFrame((function () { e.changeSize(n.clientWidth), n.show(), n.unslideAll() })) } var i = this, n = this.createMenu(); n._width = 200, n.changeSize(n._width); for (var r = 0; r < t.length; r++) { var o = n.addItem(t[r].title); o.style.paddingLeft = "20px", o.addIcon().addEventListener(i.TOUCH_ENABLED ? "touchend" : "click", e, !1), t[r].subMenu && 0 < t[r].subMenu.length && o.addSelection(t[r].subMenu[0].title).addSubMenu(t[r].title, t[r].subMenu) } return n }, createSubMenu: function (t, e) { function i(t) { t.preventDefault(), t.stopPropagation(), (n = r.mainMenu).changeSize(n._width), n.unslideAll(), n.show(), o.slideAll(!0), o.hide(), "header" !== this.type && (o.setActiveItem(this), r.activeMainItem.setSelectionTitle(this.textContent), this.handler && this.handler()) } var n, r = this, o = this.createMenu(); for (o.items = e, o.activeItem = null, o.addHeader(t).addIcon(void 0, !0, !0).addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), t = 0; t < e.length; t++) { var a = o.addItem(e[t].title); a.style.fontWeight = 300, a.handler = e[t].handler, a.addIcon(" ", !0), a.addEventListener(r.TOUCH_ENABLED ? "touchend" : "click", i, !1), o.activeItem || o.setActiveItem(a) } return o.slideAll(!0), o }, createMenu: function () { var t = this, e = document.createElement("span"), i = e.style; return i.padding = "5px 0", i.position = "fixed", i.bottom = "100%", i.right = "14px", i.backgroundColor = "#fafafa", i.fontFamily = "Helvetica Neue", i.fontSize = "14px", i.visibility = "hidden", i.opacity = 0, i.boxShadow = "0 0 12pt rgba(0,0,0,0.25)", i.borderRadius = "2px", i.overflow = "hidden", i.willChange = "width, height, opacity", i.pointerEvents = "auto", i.transition = this.DEFAULT_TRANSITION, e.visible = !1, e.changeSize = function (t, e) { t && (this.style.width = t + "px"), e && (this.style.height = e + "px") }, e.show = function () { this.style.opacity = 1, this.style.visibility = "visible", this.visible = !0 }, e.hide = function () { this.style.opacity = 0, this.style.visibility = "hidden", this.visible = !1 }, e.toggle = function () { this.visible ? this.hide() : this.show() }, e.slideAll = function (t) { for (var i = 0; i < e.children.length; i++)e.children[i].slide && e.children[i].slide(t) }, e.unslideAll = function () { for (var t = 0; t < e.children.length; t++)e.children[t].unslide && e.children[t].unslide() }, e.addHeader = function (e) { return (e = t.createMenuItemHeader(e)).type = "header", this.appendChild(e), e }, e.addItem = function (e) { return (e = t.createMenuItem(e)).type = "item", this.appendChild(e), e }, e.setActiveItem = function (t) { this.activeItem && this.activeItem.setIcon(" "), t.setIcon(L.Check), this.activeItem = t }, e.addEventListener("mousemove", this.PREVENT_EVENT_HANDLER, !0), e.addEventListener("mouseup", this.PREVENT_EVENT_HANDLER, !0), e.addEventListener("mousedown", this.PREVENT_EVENT_HANDLER, !0), e }, createCustomItem: function (t) { var e = this, i = (t = void 0 === t ? {} : t).element || document.createElement("span"), n = t.onDispose; return i.style.cursor = "pointer", i.style.float = "right", i.style.width = "44px", i.style.height = "100%", i.style.backgroundSize = "60%", i.style.backgroundRepeat = "no-repeat", i.style.backgroundPosition = "center", i.style.webkitUserSelect = i.style.MozUserSelect = i.style.userSelect = "none", i.style.position = "relative", i.style.pointerEvents = "auto", i.addEventListener(e.TOUCH_ENABLED ? "touchstart" : "mouseenter", (function () { i.style.filter = i.style.webkitFilter = "drop-shadow(0 0 5px rgba(255,255,255,1))" }), { passive: !0 }), i.addEventListener(e.TOUCH_ENABLED ? "touchend" : "mouseleave", (function () { i.style.filter = i.style.webkitFilter = "" }), { passive: !0 }), this.mergeStyleOptions(i, t.style), t.onTap && i.addEventListener(e.TOUCH_ENABLED ? "touchend" : "click", t.onTap, !1), i.dispose = function () { i.removeEventListener(e.TOUCH_ENABLED ? "touchend" : "click", t.onTap, !1), n && t.onDispose() }, i }, mergeStyleOptions: function (t, e) { for (var i in e = void 0 === e ? {} : e) e.hasOwnProperty(i) && (t.style[i] = e[i]); return t }, dispose: function () { this.barElement && (this.container.removeChild(this.barElement), this.barElement.dispose(), this.barElement = null) } }); var D = { tEquirect: { value: new e.Texture }, repeat: { value: new e.Vector2(1, 1) }, offset: { value: new e.Vector2(0, 0) }, opacity: { value: 1 } }; s.prototype = Object.assign(Object.create(e.Mesh.prototype), { constructor: s, createGeometry: function (t) { return new e.BoxBufferGeometry(t, t, t) }, createMaterial: function (t, i) { t = void 0 === t ? new e.Vector2(1, 1) : t, i = void 0 === i ? new e.Vector2(0, 0) : i; var n = e.UniformsUtils.clone(D); return n.repeat.value.copy(t), n.offset.value.copy(i), n.opacity.value = 0, new e.ShaderMaterial({ fragmentShader: "\n        uniform sampler2D tEquirect;\n        uniform vec2 repeat;\n        uniform vec2 offset;\n        uniform float opacity;\n        varying vec3 vWorldDirection;\n        #include <common>\n        void main() {\n            vec3 direction = normalize( vWorldDirection );\n            vec2 sampleUV;\n            sampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n            sampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n            sampleUV *= repeat;\n            sampleUV += offset;\n            vec4 texColor = texture2D( tEquirect, sampleUV );\n            gl_FragColor = mapTexelToLinear( texColor );\n            gl_FragColor.a *= opacity;\n            #include <tonemapping_fragment>\n            #include <encodings_fragment>\n        }\n    ", vertexShader: "\n        varying vec3 vWorldDirection;\n        #include <common>\n        void main() {\n            vWorldDirection = transformDirection( position, modelMatrix );\n            #include <begin_vertex>\n            #include <project_vertex>\n        }\n    ", uniforms: n, side: e.BackSide, transparent: !0, opacity: 0 }) }, add: function (t) { if (1 < arguments.length) { for (var i = 0; i < arguments.length; i++)this.add(arguments[i]); return this } t instanceof o && ((i = this.container) && t.dispatchEvent({ type: "panolens-container", container: i }), t.dispatchEvent({ type: "panolens-infospot-focus", method: function (t, e, i) { this.dispatchEvent({ type: "panolens-viewer-handler", method: "tweenControlCenter", data: [t, e, i] }) }.bind(this) })), e.Object3D.prototype.add.call(this, t) }, getTexture: function () { return this.material.uniforms.tEquirect.value }, load: function () { this.onLoad() }, onClick: function (t) { t.intersects && 0 === t.intersects.length && this.traverse((function (t) { t.dispatchEvent({ type: "dismiss" }) })) }, setContainer: function (t) { if (t instanceof HTMLElement) var e = t; else t && t.container && (e = t.container); e && (this.children.forEach((function (t) { t instanceof o && t.dispatchEvent && t.dispatchEvent({ type: "panolens-container", container: e }) })), this.container = e) }, onLoad: function () { this.loaded = !0, this.dispatchEvent({ type: "load" }) }, onProgress: function (t) { this.dispatchEvent({ type: "progress", progress: t }) }, onError: function () { this.dispatchEvent({ type: "error" }) }, getZoomLevel: function () { return 800 >= window.innerWidth ? this.ImageQualityFair : 800 < window.innerWidth && 1280 >= window.innerWidth ? this.ImageQualityMedium : 1280 < window.innerWidth && 1920 >= window.innerWidth ? this.ImageQualityHigh : 1920 < window.innerWidth ? this.ImageQualitySuperHigh : this.ImageQualityLow }, updateTexture: function (t) { this.material.uniforms.tEquirect.value = t }, toggleInfospotVisibility: function (t, e) { e = void 0 !== e ? e : 0; var i = void 0 !== t ? t : !this.isInfospotVisible; this.traverse((function (t) { t instanceof o && (i ? t.show(e) : t.hide(e)) })), this.isInfospotVisible = i, this.infospotAnimation.onComplete(function () { this.dispatchEvent({ type: "infospot-animation-complete", visible: i }) }.bind(this)).delay(e).start() }, setLinkingImage: function (t, e) { this.linkingImageURL = t, this.linkingImageScale = e }, link: function (t, e, i, n) { this.visible = !0, e ? ((n = new o(i = void 0 !== i ? i : void 0 !== t.linkingImageScale ? t.linkingImageScale : 300, n = n || (t.linkingImageURL ? t.linkingImageURL : L.Arrow))).position.copy(e), n.toPanorama = t, n.addEventListener("click", function () { this.dispatchEvent({ type: "panolens-viewer-handler", method: "setPanorama", data: t }) }.bind(this)), this.linkedSpots.push(n), this.add(n), this.visible = !1) : console.warn("Please specify infospot position for linking") }, reset: function () { this.children.length = 0 }, setupTransitions: function () { this.fadeInAnimation = new O.Tween(this.material).easing(O.Easing.Quartic.Out).onStart(function () { this.visible = !0, this.dispatchEvent({ type: "enter-fade-start" }) }.bind(this)), this.fadeOutAnimation = new O.Tween(this.material).easing(O.Easing.Quartic.Out).onComplete(function () { this.visible = !1, this.dispatchEvent({ type: "leave-complete" }) }.bind(this)), this.enterTransition = new O.Tween(this).easing(O.Easing.Quartic.Out).onComplete(function () { this.dispatchEvent({ type: "enter-complete" }) }.bind(this)).start(), this.leaveTransition = new O.Tween(this).easing(O.Easing.Quartic.Out) }, onFadeAnimationUpdate: function () { var t = this.material.opacity, e = this.material.uniforms; e && e.opacity && (e.opacity.value = t) }, fadeIn: function (t) { t = 0 <= t ? t : this.animationDuration, this.fadeOutAnimation.stop(), this.fadeInAnimation.to({ opacity: 1 }, t).onUpdate(this.onFadeAnimationUpdate.bind(this)).onComplete(function () { this.toggleInfospotVisibility(!0, t / 2), this.dispatchEvent({ type: "enter-fade-complete" }) }.bind(this)).start() }, fadeOut: function (t) { t = 0 <= t ? t : this.animationDuration, this.fadeInAnimation.stop(), this.fadeOutAnimation.to({ opacity: 0 }, t).onUpdate(this.onFadeAnimationUpdate.bind(this)).start() }, onEnter: function () { var t = this.animationDuration; this.dispatchEvent({ type: "enter" }), this.leaveTransition.stop(), this.enterTransition.to({}, t).onStart(function () { this.dispatchEvent({ type: "enter-start" }), this.loaded ? this.fadeIn(t) : this.load() }.bind(this)).start(), this.children.forEach((function (t) { t.dispatchEvent({ type: "panorama-enter" }) })), this.active = !0 }, onLeave: function () { const t = this.animationDuration; this.enterTransition.stop(), this.leaveTransition.to({}, t).onStart(function () { this.dispatchEvent({ type: "leave-start" }), this.fadeOut(100), this.toggleInfospotVisibility(!1) }.bind(this)).start(); var e = this.material; e && e.uniforms && e.uniforms.tEquirect && e.uniforms.tEquirect.value.dispose(), this.infospotAnimation.stop(), this.fadeInAnimation.stop(), this.fadeOutAnimation.stop(), this.enterTransition.stop(), this.leaveTransition.stop(), this.dispatchEvent({ type: "panolens-viewer-handler", method: "onPanoramaDispose", data: this }), function t(e) { for (var i = e.geometry, n = e.material, r = e.children.length - 1; 0 <= r; r--)t(e.children[r]), e.remove(e.children[r]); e instanceof o && e.dispose(), i && (i.dispose(), e.geometry = null), n && (n.dispose(), e.material = null) }(this), this.parent && this.parent.remove(this) } }), c.prototype = Object.assign(Object.create(s.prototype), { constructor: c, load: function (t) { (t = t || this.src) ? "string" == typeof t ? R.load(t, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this)) : t instanceof HTMLImageElement && this.onLoad(new e.Texture(t)) : console.warn("Image source undefined") }, onLoad: function (t) { t.minFilter = t.magFilter = e.LinearFilter, t.needsUpdate = !0, this.updateTexture(t), window.requestAnimationFrame(s.prototype.onLoad.bind(this)) }, reset: function () { s.prototype.reset.call(this) }, dispose: function () { e.Cache.remove(this.src), s.prototype.dispose.call(this) } }), h.prototype = Object.assign(Object.create(s.prototype), { constructor: h, createGeometry: function () { var t = new e.BufferGeometry; return t.addAttribute("position", new e.BufferAttribute(new Float32Array, 1)), t }, createMaterial: function () { new e.MeshBasicMaterial({ color: 0, opacity: 0, transparent: !0 }) }, getTexture: function () { return null } }), l.prototype = Object.assign(Object.create(s.prototype), { constructor: l, createMaterial: function () { var t = e.ShaderLib.cube, i = t.fragmentShader, n = t.vertexShader; return (t = e.UniformsUtils.clone(t.uniforms)).opacity.value = 0, new e.ShaderMaterial({ fragmentShader: i, vertexShader: n, uniforms: t, side: e.BackSide, transparent: !0, opacity: 0 }) }, load: function () { P.load(this.images, this.onLoad.bind(this), this.onProgress.bind(this), this.onError.bind(this)) }, onLoad: function (t) { this.material.uniforms.tCube.value = t, s.prototype.onLoad.call(this) }, getTexture: function () { return this.material.uniforms.tCube.value }, dispose: function () { var t = this.material.uniforms.tCube.value; this.images.forEach((function (t) { e.Cache.remove(t) })), t instanceof e.CubeTexture && t.dispose(), s.prototype.dispose.call(this) } }), u.prototype = Object.assign(Object.create(l.prototype), { constructor: u }), d.prototype = Object.assign(Object.create(s.prototype), { constructor: d, isMobile: function () { var t = !1, e = window.navigator.userAgent || window.navigator.vendor || window.opera; return (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0, 4))) && (t = !0), t }, load: function () { var t = this.options, e = t.muted, i = t.loop, n = t.autoplay, r = t.playsinline; t = t.crossOrigin; var o = this.videoElement, a = this.onProgress.bind(this), s = this.onLoad.bind(this); o.loop = i, o.autoplay = n, o.playsinline = r, o.crossOrigin = t, o.muted = e, r && (o.setAttribute("playsinline", ""), o.setAttribute("webkit-playsinline", "")), r = function () { var t = this.setVideoTexture(o); n && this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: !1 }), this.isMobile() && (o.pause(), n && e ? this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: !1 }) : this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: !0 })), window.requestAnimationFrame((function () { a({ loaded: 1, total: 1 }), s(t) })) }, 2 < o.readyState ? r.call(this) : (0 === o.querySelectorAll("source").length && ((t = document.createElement("source")).src = this.src, o.appendChild(t)), o.load()), o.addEventListener("loadeddata", r.bind(this)), o.addEventListener("timeupdate", function () { this.videoProgress = 0 <= o.duration ? o.currentTime / o.duration : 0, this.dispatchEvent({ type: "panolens-viewer-handler", method: "onVideoUpdate", data: this.videoProgress }) }.bind(this)), o.addEventListener("ended", function () { i || (this.resetVideo(), this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: !0 })) }.bind(this), !1) }, onLoad: function () { s.prototype.onLoad.call(this) }, setVideoTexture: function (t) { if (t) return (t = new e.VideoTexture(t)).minFilter = e.LinearFilter, t.magFilter = e.LinearFilter, t.format = e.RGBFormat, this.updateTexture(t), t }, reset: function () { this.videoElement = void 0, s.prototype.reset.call(this) }, isVideoPaused: function () { return this.videoElement.paused }, toggleVideo: function () { var t = this.videoElement; t && t[t.paused ? "play" : "pause"]() }, setVideoCurrentTime: function (t) { t = t.percentage; var e = this.videoElement; e && !Number.isNaN(t) && 1 !== t && (e.currentTime = e.duration * t, this.dispatchEvent({ type: "panolens-viewer-handler", method: "onVideoUpdate", data: t })) }, playVideo: function () { var t = this.videoElement, e = this.playVideo.bind(this), i = this.dispatchEvent.bind(this); t && t.paused && t.play().then((function () { i({ type: "play" }) })).catch((function (t) { window.requestAnimationFrame(e), i({ type: "play-error", error: t }) })) }, pauseVideo: function () { var t = this.videoElement; t && !t.paused && t.pause(), this.dispatchEvent({ type: "pause" }) }, resumeVideoProgress: function () { var t = this.videoElement; 4 <= t.readyState && t.autoplay && !this.isMobile() ? (this.playVideo(), this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: !1 })) : (this.pauseVideo(), this.dispatchEvent({ type: "panolens-viewer-handler", method: "updateVideoPlayButton", data: !0 })), this.setVideoCurrentTime({ percentage: this.videoProgress }) }, resetVideo: function () { this.videoElement && this.setVideoCurrentTime({ percentage: 0 }) }, isVideoMuted: function () { return this.videoElement.muted }, muteVideo: function () { var t = this.videoElement; t && !t.muted && (t.muted = !0), this.dispatchEvent({ type: "volumechange" }) }, unmuteVideo: function () { var t = this.videoElement; t && this.isVideoMuted() && (t.muted = !1), this.dispatchEvent({ type: "volumechange" }) }, getVideoElement: function () { return this.videoElement }, dispose: function () { this.pauseVideo(), this.removeEventListener("leave", this.pauseVideo.bind(this)), this.removeEventListener("enter-fade-start", this.resumeVideoProgress.bind(this)), this.removeEventListener("video-toggle", this.toggleVideo.bind(this)), this.removeEventListener("video-time", this.setVideoCurrentTime.bind(this)), s.prototype.dispose.call(this) } }), Object.assign(p.prototype, { constructor: p, setProgress: function (t, e) { this.onProgress && this.onProgress({ loaded: t, total: e }) }, adaptTextureToZoom: function () { var t = this.widths[this._zoom], e = this.heights[this._zoom], i = this.maxW, n = this.maxH; this._wc = Math.ceil(t / i), this._hc = Math.ceil(e / n); for (var r = 0; r < this._hc; r++)for (var o = 0; o < this._wc; o++) { var a = document.createElement("canvas"); a.width = o < this._wc - 1 ? i : t - i * o, a.height = r < this._hc - 1 ? n : e - n * r, this._canvas.push(a), this._ctx.push(a.getContext("2d")) } }, composeFromTile: function (t, e, i) { var n = this.maxW, r = this.maxH; t *= 512, e *= 512; var o = Math.floor(t / n), a = Math.floor(e / r); this._ctx[a * this._wc + o].drawImage(i, 0, 0, i.width, i.height, t - o * n, e - a * r, 512, 512), this.progress() }, progress: function () { this._count++, this.setProgress(this._count, this._total), this._count === this._total && (this.canvas = this._canvas, this.panoId = this._panoId, this.zoom = this._zoom, this.onPanoramaLoad) && this.onPanoramaLoad(this._canvas[0]) }, composePanorama: function () { this.setProgress(0, 1); var t = this.levelsW[this._zoom], e = this.levelsH[this._zoom], i = this; this._count = 0, this._total = t * e; for (var n = this._parameters.useWebGL, r = 0; r < e; r++)for (var o = {}, a = 0; a < t; o = { $jscomp$loop$prop$url$2: o.$jscomp$loop$prop$url$2 }, a++)o.$jscomp$loop$prop$url$2 = "https://geo0.ggpht.com/cbk?cb_client=maps_sv.tactile&authuser=0&hl=en&output=tile&zoom=" + this._zoom + "&x=" + a + "&y=" + r + "&panoid=" + this._panoId + "&nbt&fover=2", function (t) { return function (e, r) { if (n) var o = R.load(t.$jscomp$loop$prop$url$2, null, (function () { i.composeFromTile(e, r, o) })); else { var a = new Image; a.addEventListener("load", (function () { i.composeFromTile(e, r, this) })), a.crossOrigin = "", a.src = t.$jscomp$loop$prop$url$2 } } }(o)(a, r) }, load: function (t) { this.loadPano(t) }, loadPano: function (t) { var e = this; this._panoClient.getPanoramaById(t, (function (t, i) { i === google.maps.StreetViewStatus.OK && (e.result = t, e.copyright = t.copyright, e._panoId = t.location.pano, e.composePanorama()) })) }, setZoom: function (t) { this._zoom = t, this.adaptTextureToZoom() } }), f.prototype = Object.assign(Object.create(c.prototype), { constructor: f, load: function (t) { this.loadRequested = !0, t = t || this.panoId || {}, this.gsvLoader && this.loadGSVLoader(t) }, setupGoogleMapAPI: function (t) { var e = document.createElement("script"); e.src = "https://maps.googleapis.com/maps/api/js?", e.src += t ? "key=" + t : "", e.onreadystatechange = this.setGSVLoader.bind(this), e.onload = this.setGSVLoader.bind(this), document.querySelector("head").appendChild(e) }, setGSVLoader: function () { this.gsvLoader = new p, this.loadRequested && this.load() }, getGSVLoader: function () { return this.gsvLoader }, loadGSVLoader: function (t) { this.loadRequested = !1, this.gsvLoader.onProgress = this.onProgress.bind(this), this.gsvLoader.onPanoramaLoad = this.onLoad.bind(this), this.gsvLoader.setZoom(this.getZoomLevel()), this.gsvLoader.load(t), this.gsvLoader.loaded = !0 }, onLoad: function (t) { c.prototype.onLoad.call(this, new e.Texture(t)) }, reset: function () { this.gsvLoader = void 0, c.prototype.reset.call(this) } }); var N = { tDiffuse: { value: new e.Texture }, resolution: { value: 1 }, transform: { value: new e.Matrix4 }, zoom: { value: 1 }, opacity: { value: 1 } }; m.prototype = Object.assign(Object.create(c.prototype), { constructor: m, add: function (t) { if (1 < arguments.length) { for (var e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } t instanceof o && (t.material.depthTest = !1), c.prototype.add.call(this, t) }, createGeometry: function (t) { return new e.PlaneBufferGeometry(t, .5 * t) }, createMaterial: function (t) { t = void 0 === t ? this.edgeLength : t; var i = e.UniformsUtils.clone(N); return i.zoom.value = t, i.opacity.value = 0, new e.ShaderMaterial({ vertexShader: "\n\n        varying vec2 vUv;\n\n        void main() {\n\n            vUv = uv;\n            gl_Position = vec4( position, 1.0 );\n\n        }\n\n    ", fragmentShader: "\n\n        uniform sampler2D tDiffuse;\n        uniform float resolution;\n        uniform mat4 transform;\n        uniform float zoom;\n        uniform float opacity;\n\n        varying vec2 vUv;\n\n        const float PI = 3.141592653589793;\n\n        void main(){\n\n            vec2 position = -1.0 +  2.0 * vUv;\n\n            position *= vec2( zoom * resolution, zoom * 0.5 );\n\n            float x2y2 = position.x * position.x + position.y * position.y;\n            vec3 sphere_pnt = vec3( 2. * position, x2y2 - 1. ) / ( x2y2 + 1. );\n\n            sphere_pnt = vec3( transform * vec4( sphere_pnt, 1.0 ) );\n\n            vec2 sampleUV = vec2(\n                (atan(sphere_pnt.y, sphere_pnt.x) / PI + 1.0) * 0.5,\n                (asin(sphere_pnt.z) / PI + 0.5)\n            );\n\n            gl_FragColor = texture2D( tDiffuse, sampleUV );\n            gl_FragColor.a *= opacity;\n\n        }\n    ", uniforms: i, transparent: !0, opacity: 0 }) }, registerMouseEvents: function () { this.container.addEventListener("mousedown", this.onMouseDown.bind(this), { passive: !0 }), this.container.addEventListener("mousemove", this.onMouseMove.bind(this), { passive: !0 }), this.container.addEventListener("mouseup", this.onMouseUp.bind(this), { passive: !0 }), this.container.addEventListener("touchstart", this.onMouseDown.bind(this), { passive: !0 }), this.container.addEventListener("touchmove", this.onMouseMove.bind(this), { passive: !0 }), this.container.addEventListener("touchend", this.onMouseUp.bind(this), { passive: !0 }), this.container.addEventListener("mousewheel", this.onMouseWheel.bind(this), { passive: !1 }), this.container.addEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), { passive: !1 }), this.container.addEventListener("contextmenu", this.onContextMenu.bind(this), { passive: !0 }) }, unregisterMouseEvents: function () { this.container.removeEventListener("mousedown", this.onMouseDown.bind(this), !1), this.container.removeEventListener("mousemove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("mouseup", this.onMouseUp.bind(this), !1), this.container.removeEventListener("touchstart", this.onMouseDown.bind(this), !1), this.container.removeEventListener("touchmove", this.onMouseMove.bind(this), !1), this.container.removeEventListener("touchend", this.onMouseUp.bind(this), !1), this.container.removeEventListener("mousewheel", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("DOMMouseScroll", this.onMouseWheel.bind(this), !1), this.container.removeEventListener("contextmenu", this.onContextMenu.bind(this), !1) }, onMouseDown: function (t) { switch (t.touches && t.touches.length || 1) { case 1: var e = 0 <= t.clientX ? t.clientX : t.touches[0].clientX; t = 0 <= t.clientY ? t.clientY : t.touches[0].clientY, this.dragging = !0, this.userMouse.set(e, t); break; case 2: e = t.touches[0].pageX - t.touches[1].pageX, t = t.touches[0].pageY - t.touches[1].pageY, this.userMouse.pinchDistance = Math.sqrt(e * e + t * t) }this.onUpdateCallback() }, onMouseMove: function (t) { switch (t.touches && t.touches.length || 1) { case 1: var i = 0 <= t.clientX ? t.clientX : t.touches[0].clientX; t = 0 <= t.clientY ? t.clientY : t.touches[0].clientY; var n = .4 * e.Math.degToRad(i - this.userMouse.x), r = .4 * e.Math.degToRad(t - this.userMouse.y); this.dragging && (this.quatA.setFromAxisAngle(this.vectorY, n), this.quatB.setFromAxisAngle(this.vectorX, r), this.quatCur.multiply(this.quatA).multiply(this.quatB), this.userMouse.set(i, t)); break; case 2: i = t.touches[0].pageX - t.touches[1].pageX, t = t.touches[0].pageY - t.touches[1].pageY, this.addZoomDelta(this.userMouse.pinchDistance - Math.sqrt(i * i + t * t)) } }, onMouseUp: function () { this.dragging = !1 }, onMouseWheel: function (t) { t.preventDefault(), t.stopPropagation(); var e = 0; void 0 !== t.wheelDelta ? e = t.wheelDelta : void 0 !== t.detail && (e = -t.detail), this.addZoomDelta(e), this.onUpdateCallback() }, addZoomDelta: function (t) { var e = this.material.uniforms, i = .1 * this.size, n = 10 * this.size; e.zoom.value += t, e.zoom.value <= i ? e.zoom.value = i : e.zoom.value >= n && (e.zoom.value = n) }, onUpdateCallback: function () { this.frameId = window.requestAnimationFrame(this.onUpdateCallback.bind(this)), this.quatSlerp.slerp(this.quatCur, .1), this.material && this.material.uniforms.transform.value.makeRotationFromQuaternion(this.quatSlerp), !this.dragging && 1 - this.quatSlerp.clone().dot(this.quatCur) < this.EPS && window.cancelAnimationFrame(this.frameId) }, reset: function () { this.quatCur.set(0, 0, 0, 1), this.quatSlerp.set(0, 0, 0, 1), this.onUpdateCallback() }, updateTexture: function (t) { this.material.uniforms.tDiffuse.value = t }, getTexture: function () { return this.material.uniforms.tDiffuse.value }, onLoad: function (t) { this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight, this.registerMouseEvents(), this.onUpdateCallback(), this.dispatchEvent({ type: "panolens-viewer-handler", method: "disableControl" }), c.prototype.onLoad.call(this, t) }, onLeave: function () { this.unregisterMouseEvents(), this.dispatchEvent({ type: "panolens-viewer-handler", method: "enableControl", data: A.ORBIT }), window.cancelAnimationFrame(this.frameId), c.prototype.onLeave.call(this) }, onWindowResize: function () { this.material.uniforms.resolution.value = this.container.clientWidth / this.container.clientHeight }, onContextMenu: function () { this.dragging = !1 }, dispose: function () { this.unregisterMouseEvents(), c.prototype.dispose.call(this) } }), g.prototype = Object.assign(Object.create(m.prototype), { constructor: g, onLoad: function (t) { this.updateTexture(t), m.prototype.onLoad.call(this, t) }, updateTexture: function (t) { t.minFilter = t.magFilter = e.LinearFilter, this.material.uniforms.tDiffuse.value = t }, dispose: function () { var t = this.material.uniforms.tDiffuse; t && t.value && t.value.dispose(), m.prototype.dispose.call(this) } }), v.prototype = Object.assign(Object.create(s.prototype), { constructor: v, onPanolensContainer: function (t) { this.media.setContainer(t.container) }, onPanolensScene: function (t) { this.media.setScene(t.scene) }, start: function () { return this.media.start() }, stop: function () { this.media.stop() } }), y.prototype = Object.assign(Object.create(c.prototype), { constructor: y, onLoad: function (t) { var e = t.image; this.stereo.updateUniformByFormat(4 == e.width / e.height ? S.SBS : S.TAB, this.material.uniforms), this.material.uniforms.tEquirect.value = t, c.prototype.onLoad.call(this, t) }, updateTextureToLeft: function () { this.stereo.updateTextureToLeft(this.material.uniforms.offset.value) }, updateTextureToRight: function () { this.stereo.updateTextureToRight(this.material.uniforms.offset.value) }, dispose: function () { var t = this.material.uniforms.tEquirect.value; t instanceof e.Texture && t.dispose(), c.prototype.dispose.call(this) } }), x.prototype = Object.assign(Object.create(d.prototype), { constructor: x, onLoad: function (t) { var e = t.image; this.stereo.updateUniformByFormat(4 == e.videoWidth / e.videoHeight ? S.SBS : S.TAB, this.material.uniforms), this.material.uniforms.tEquirect.value = t, d.prototype.onLoad.call(this) }, updateTextureToLeft: function () { this.stereo.updateTextureToLeft(this.material.uniforms.offset.value) }, updateTextureToRight: function () { this.stereo.updateTextureToRight(this.material.uniforms.offset.value) }, dispose: function () { var t = this.material.uniforms.tEquirect.value; t instanceof e.Texture && t.dispose(), d.prototype.dispose.call(this) } }), b.prototype = Object.assign(Object.create(e.EventDispatcher.prototype), { constructor: b }), w.prototype = Object.assign(Object.create(e.EventDispatcher.prototype), { constructor: w }); var B = function (t) { var i = new e.StereoCamera; i.aspect = .5; var n = new e.Vector2; this.setEyeSeparation = function (t) { i.eyeSep = t }, this.setSize = function (e, i) { t.setSize(e, i) }, this.render = function (e, r, o) { var a = o instanceof y || o instanceof x; e.updateMatrixWorld(), null === r.parent && r.updateMatrixWorld(), a && this.setEyeSeparation(o.stereo.eyeSep), i.update(r), t.getSize(n), t.autoClear && t.clear(), t.setScissorTest(!0), a && o.updateTextureToLeft(), t.setScissor(0, 0, n.width / 2, n.height), t.setViewport(0, 0, n.width / 2, n.height), t.render(e, i.cameraL), a && o.updateTextureToRight(), t.setScissor(n.width / 2, 0, n.width / 2, n.height), t.setViewport(n.width / 2, 0, n.width / 2, n.height), t.render(e, i.cameraR), t.setScissorTest(!1), a && o.updateTextureToLeft() } }; _.prototype = Object.assign(Object.create(e.EventDispatcher.prototype), { constructor: _, setupScene: function (t) { return void 0 === t ? new e.Scene : t }, setupCamera: function (t, i, n) { return void 0 === n ? new e.PerspectiveCamera(t, i, 1, 1e4) : n }, setupRenderer: function (t, i) { t = void 0 === t ? new e.WebGLRenderer({ alpha: !0, antialias: !1 }) : t; var n = i.clientWidth, r = i.clientHeight; return t.setPixelRatio(window.devicePixelRatio), t.setSize(n, r), t.setClearColor(0, 0), t.autoClear = !1, t.domElement.classList.add("panolens-canvas"), t.domElement.style.display = "block", i.style.backgroundColor = "#000", i.appendChild(t.domElement), t }, setupControls: function (t, e) { var i = this.options, n = i.autoRotate, r = i.autoRotateSpeed, o = i.horizontalView; return (i = new b(t, e)).id = "orbit", i.index = A.ORBIT, i.minDistance = 1, i.noPan = !0, i.autoRotate = n, i.autoRotateSpeed = r, o && (i.minPolarAngle = Math.PI / 2, i.maxPolarAngle = Math.PI / 2), (t = new w(t, e)).id = "device-orientation", t.index = A.DEVICEORIENTATION, t.enabled = !1, this.controls = [i, t], this.OrbitControls = i, this.DeviceOrientationControls = t, i }, setupEffects: function (t, e) { var i = e.clientWidth; e = e.clientHeight; var n = new M(t); return n.setSize(i, e), (t = new B(t)).setSize(i, e), this.CardboardEffect = n, this.StereoEffect = t, n }, setupContainer: function (t) { return t ? (t._width = t.clientWidth, t._height = t.clientHeight, t) : ((t = document.createElement("div")).classList.add("panolens-container"), t.style.width = "100%", t.style.height = "100%", document.body.appendChild(t), t) }, add: function (t) { if (1 < arguments.length) { for (var e = 0; e < arguments.length; e++)this.add(arguments[e]); return this } this.scene.add(t), t.addEventListener && t.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), t instanceof s && t.dispatchEvent && t.dispatchEvent({ type: "panolens-container", container: this.container }), t instanceof v && t.dispatchEvent({ type: "panolens-scene", scene: this.scene }), t instanceof s && (this.addPanoramaEventListener(t), this.panorama || (e = this.options.initialLookAt, this.setPanorama(t), this.setControlCenter(e))) }, remove: function (t) { t.removeEventListener && t.removeEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), this.scene.remove(t) }, addDefaultControlBar: function (t) { if (this.widget) console.warn("Default control bar exists"); else { var e = new a(this.container); e.addEventListener("panolens-viewer-handler", this.eventHandler.bind(this)), e.addControlBar(), t.forEach((function (t) { e.addControlButton(t) })), this.widget = e } }, setPanorama: function (t) { var e = this.panorama; if (t instanceof s && e !== t) { this.hideInfospot(); var i = function () { e && e.onLeave(), t.removeEventListener("enter-fade-start", i) }; t.addEventListener("enter-fade-start", i), (this.panorama = t).onEnter() } }, eventHandler: function (t) { t.method && this[t.method] && this[t.method](t.data) }, dispatchEventToChildren: function (t) { this.scene.traverse((function (e) { e.dispatchEvent && e.dispatchEvent(t) })) }, activateWidgetItem: function (t, e) { var i = this.widget.mainMenu, n = i.children[0]; if (i = i.children[1], void 0 !== t) { switch (t) { case 0: default: t = n.subMenu.children[1]; break; case 1: t = n.subMenu.children[2] }n.subMenu.setActiveItem(t), n.setSelectionTitle(t.textContent) } if (void 0 !== e) { switch (e) { case T.CARDBOARD: t = i.subMenu.children[2]; break; case T.STEREO: t = i.subMenu.children[3]; break; default: t = i.subMenu.children[1] }i.subMenu.setActiveItem(t), i.setSelectionTitle(t.textContent) } }, enableEffect: function (t) { if (this.mode !== t) if (t === T.NORMAL) this.disableEffect(); else { this.mode = t; var e = this.camera.fov; switch (t) { case T.CARDBOARD: this.effect = this.CardboardEffect, this.enableReticleControl(); break; case T.STEREO: this.effect = this.StereoEffect, this.enableReticleControl(); break; default: this.effect = null, this.disableReticleControl() }this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({ type: "panolens-dual-eye-effect", mode: this.mode }), this.camera.fov = e + .01, this.effect.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.camera.fov = e, this.dispatchEvent({ type: "mode-change", mode: this.mode }) } }, disableEffect: function () { this.mode !== T.NORMAL && (this.mode = T.NORMAL, this.disableReticleControl(), this.activateWidgetItem(void 0, this.mode), this.dispatchEventToChildren({ type: "panolens-dual-eye-effect", mode: this.mode }), this.renderer.setSize(this.container.clientWidth, this.container.clientHeight), this.render(), this.dispatchEvent({ type: "mode-change", mode: this.mode })) }, enableReticleControl: function () { this.reticle.visible || (this.tempEnableReticle = !0, this.unregisterMouseAndTouchEvents(), this.reticle.show(), this.registerReticleEvent(), this.updateReticleEvent()) }, disableReticleControl: function () { this.tempEnableReticle = !1, this.options.enableReticle ? this.updateReticleEvent() : (this.reticle.hide(), this.unregisterReticleEvent(), this.registerMouseAndTouchEvents()) }, enableAutoRate: function () { this.options.autoRotate = !0, this.OrbitControls.autoRotate = !0 }, disableAutoRate: function () { clearTimeout(this.autoRotateRequestId), this.options.autoRotate = !1, this.OrbitControls.autoRotate = !1 }, toggleVideoPlay: function (t) { this.panorama instanceof d && this.panorama.dispatchEvent({ type: "video-toggle", pause: t }) }, setVideoCurrentTime: function (t) { this.panorama instanceof d && this.panorama.dispatchEvent({ type: "video-time", percentage: t }) }, onVideoUpdate: function (t) { var e = this.widget; e && e.dispatchEvent({ type: "video-update", percentage: t }) }, addUpdateCallback: function (t) { t && this.updateCallbacks.push(t) }, removeUpdateCallback: function (t) { var e = this.updateCallbacks.indexOf(t); t && 0 <= e && this.updateCallbacks.splice(e, 1) }, showVideoWidget: function () { var t = this.widget; t && t.dispatchEvent({ type: "video-control-show" }) }, hideVideoWidget: function () { var t = this.widget; t && t.dispatchEvent({ type: "video-control-hide" }) }, updateVideoPlayButton: function (t) { var e = this.widget; e && e.videoElement && e.videoElement.controlButton && e.videoElement.controlButton.update(t) }, addPanoramaEventListener: function (t) { t.addEventListener("enter", this.setCameraControl.bind(this)), t instanceof d && (t.addEventListener("enter-fade-start", this.showVideoWidget.bind(this)), t.addEventListener("leave", function () { this.panorama instanceof d || this.hideVideoWidget.call(this) }.bind(this))) }, setCameraControl: function () { this.OrbitControls.target.copy(this.panorama.position) }, getControl: function () { return this.control }, getScene: function () { return this.scene }, getCamera: function () { return this.camera }, getRenderer: function () { return this.renderer }, getContainer: function () { return this.container }, getControlId: function () { return this.control.id }, getNextControlId: function () { return this.controls[this.getNextControlIndex()].id }, getNextControlIndex: function () { var t = this.controls, e = t.indexOf(this.control) + 1; return e >= t.length ? 0 : e }, setCameraFov: function (t) { this.camera.fov = t, this.camera.updateProjectionMatrix() }, getRaycastViewCenter: function () { var t = new e.Raycaster; return t.setFromCamera(new e.Vector2(0, 0), this.camera), 0 < (t = t.intersectObject(this.panorama)).length ? t[0].point : new e.Vector3(0, 0, -1) }, enableControl: function (t) { t = 0 <= t && t < this.controls.length ? t : 0, this.control.enabled = !1, this.control = this.controls[t], this.control.enabled = !0, this.control.update(), this.setControlCenter(this.getRaycastViewCenter()), this.activateWidgetItem(t, void 0), this.onChange() }, disableControl: function () { this.control.enabled = !1 }, toggleNextControl: function () { this.enableControl(this.getNextControlIndex()) }, getScreenVector: function (t) { t = t.clone(); var e = this.container.clientWidth / 2, i = this.container.clientHeight / 2; return t.project(this.camera), t.x = t.x * e + e, t.y = -t.y * i + i, t.z = 0, t }, checkSpriteInViewport: function (t) { return this.camera.matrixWorldInverse.getInverse(this.camera.matrixWorld), this.cameraViewProjectionMatrix.multiplyMatrices(this.camera.projectionMatrix, this.camera.matrixWorldInverse), this.cameraFrustum.setFromMatrix(this.cameraViewProjectionMatrix), t.visible && this.cameraFrustum.intersectsSprite(t) }, reverseDraggingDirection: function () { this.OrbitControls.rotateSpeed *= -1, this.OrbitControls.momentumScalingFactor *= -1 }, addReticle: function (t, e) { var i = new r(16777215, !0, this.options.dwellTime); return i.hide(), t.add(i), e.add(t), i }, rotateControlLeft: function (t) { this.control.rotateLeft(t) }, rotateControlUp: function (t) { this.control.rotateUp(t) }, rotateOrbitControl: function (t, e) { this.rotateControlLeft(t), this.rotateControlUp(e) }, calculateCameraDirectionDelta: function (t) { var i = this.camera.getWorldDirection(new e.Vector3), n = i.clone(), r = this.panorama.getWorldPosition(new e.Vector3).sub(this.camera.getWorldPosition(new e.Vector3)); (t = t.clone()).add(r).normalize(); var o = t.clone(); return i.y = 0, t.y = 0, r = (r = (r = Math.atan2(t.z, t.x) - Math.atan2(i.z, i.x)) > Math.PI ? r - 2 * Math.PI : r) < -Math.PI ? r + 2 * Math.PI : r, i = Math.abs(n.angleTo(i) + (0 >= n.y * o.y ? o.angleTo(t) : -o.angleTo(t))), { left: r, up: i *= o.y < n.y ? 1 : -1 } }, setControlCenter: function (t) { t = this.calculateCameraDirectionDelta(t), this.rotateOrbitControl(t.left, t.up) }, tweenControlCenter: function (t, e, i) { t instanceof Array && (e = (t = t[0])[1], i = t[2]), e = void 0 !== e ? e : 1e3, i = i || O.Easing.Exponential.Out; var n = this.calculateCameraDirectionDelta(t); t = n.left, n = n.up; var r = this.rotateControlLeft.bind(this), o = this.rotateControlUp.bind(this), a = { left: 0, up: 0 }, s = 0, c = 0; this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.tweenLeftAnimation = new O.Tween(a).to({ left: t }, e).easing(i).onUpdate((function (t) { r(t.left - s), s = t.left })).start(), this.tweenUpAnimation = new O.Tween(a).to({ up: n }, e).easing(i).onUpdate((function (t) { o(t.up - c), c = t.up })).start() }, tweenControlCenterByObject: function (t, i, n) { this.tweenControlCenter(t.getWorldPosition(new e.Vector3), i, n) }, onWindowResize: function (t, e) { var i = this.container.classList.contains("panolens-container") || this.container.isFullscreen; if (void 0 !== t && void 0 !== e) { var n = t, r = e; this.container._width = t, this.container._height = e } else t = (e = /(android)/i.test(window.navigator.userAgent)) ? Math.min(document.documentElement.clientWidth, window.innerWidth || 0) : Math.max(document.documentElement.clientWidth, window.innerWidth || 0), e = e ? Math.min(document.documentElement.clientHeight, window.innerHeight || 0) : Math.max(document.documentElement.clientHeight, window.innerHeight || 0), n = i ? t : this.container.clientWidth, r = i ? e : this.container.clientHeight, this.container._width = n, this.container._height = r; this.camera.aspect = n / r, this.camera.updateProjectionMatrix(), this.renderer.setSize(n, r), (this.options.enableReticle || this.tempEnableReticle) && this.updateReticleEvent(), this.dispatchEvent({ type: "window-resize", width: n, height: r }), this.scene.traverse((function (t) { t.dispatchEvent && t.dispatchEvent({ type: "window-resize", width: n, height: r }) })) }, addOutputElement: function () { var t = document.createElement("div"); t.style.position = "absolute", t.style.right = "10px", t.style.top = "10px", t.style.color = "#fff", this.container.appendChild(t), this.outputDivElement = t }, outputPosition: function () { var t = this.raycaster.intersectObject(this.panorama, !0); if (0 < t.length) { t = t[0].point.clone(); var i = this.panorama.getWorldPosition(new e.Vector3); if (t.sub(i), i = t.x.toFixed(2) + ", " + t.y.toFixed(2) + ", " + t.z.toFixed(2), 0 !== t.length()) switch (this.options.output) { case "console": console.info(i); break; case "overlay": this.outputDivElement.textContent = i } } }, onMouseDown: function (t) { t.preventDefault(), this.userMouse.x = 0 <= t.clientX ? t.clientX : t.touches[0].clientX, this.userMouse.y = 0 <= t.clientY ? t.clientY : t.touches[0].clientY, this.userMouse.type = "mousedown", this.onTap(t) }, onMouseMove: function (t) { t.preventDefault(), this.userMouse.type = "mousemove", this.onTap(t) }, onMouseUp: function (t) { this.userMouse.type = "mouseup"; var e = this.userMouse.x >= t.clientX - this.options.clickTolerance && this.userMouse.x <= t.clientX + this.options.clickTolerance && this.userMouse.y >= t.clientY - this.options.clickTolerance && this.userMouse.y <= t.clientY + this.options.clickTolerance || t.changedTouches && this.userMouse.x >= t.changedTouches[0].clientX - this.options.clickTolerance && this.userMouse.x <= t.changedTouches[0].clientX + this.options.clickTolerance && this.userMouse.y >= t.changedTouches[0].clientY - this.options.clickTolerance && this.userMouse.y <= t.changedTouches[0].clientY + this.options.clickTolerance ? "click" : void 0; if ((!t || !t.target || t.target.classList.contains("panolens-canvas")) && (t.preventDefault(), t = t.changedTouches && 1 === t.changedTouches.length ? this.onTap({ clientX: t.changedTouches[0].clientX, clientY: t.changedTouches[0].clientY }, e) : this.onTap(t, e), this.userMouse.type = "none", !t && "click" === e)) { t = (e = this.options).autoHideControlBar; var i = this.panorama, n = this.toggleControlBar; e.autoHideInfospot && i && i.toggleInfospotVisibility(), t && n() } }, onTap: function (t, e) { var i = this.container.getBoundingClientRect(), n = i.top, r = this.container, a = r.clientHeight; if (this.raycasterPoint.x = (t.clientX - i.left) / r.clientWidth * 2 - 1, this.raycasterPoint.y = -(t.clientY - n) / a * 2 + 1, this.raycaster.setFromCamera(this.raycasterPoint, this.camera), this.panorama) { if (("mousedown" !== t.type && this.touchSupported || this.outputEnabled) && this.outputPosition(), i = this.raycaster.intersectObjects(this.panorama.children, !0), n = this.getConvertedIntersect(i), r = 0 < i.length ? i[0].object : void 0, "mouseup" === this.userMouse.type && (n && this.pressEntityObject === n && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({ type: "pressstop-entity", mouseEvent: t }), this.pressEntityObject = void 0), "mouseup" === this.userMouse.type && (r && this.pressObject === r && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({ type: "pressstop", mouseEvent: t }), this.pressObject = void 0), "click" === e ? (this.panorama.dispatchEvent({ type: "click", intersects: i, mouseEvent: t }), n && n.dispatchEvent && n.dispatchEvent({ type: "click-entity", mouseEvent: t }), r && r.dispatchEvent && r.dispatchEvent({ type: "click", mouseEvent: t })) : (this.panorama.dispatchEvent({ type: "hover", intersects: i, mouseEvent: t }), (this.hoverObject && 0 < i.length && this.hoverObject !== n || this.hoverObject && 0 === i.length) && (this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({ type: "hoverleave", mouseEvent: t }), this.reticle.end()), this.hoverObject = void 0), n && 0 < i.length && (this.hoverObject !== n && (this.hoverObject = n, this.hoverObject.dispatchEvent && (this.hoverObject.dispatchEvent({ type: "hoverenter", mouseEvent: t }), (this.options.autoReticleSelect && this.options.enableReticle || this.tempEnableReticle) && this.reticle.start(this.onTap.bind(this, t, "click")))), "mousedown" === this.userMouse.type && this.pressEntityObject != n && (this.pressEntityObject = n, this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({ type: "pressstart-entity", mouseEvent: t })), "mousedown" === this.userMouse.type && this.pressObject != r && (this.pressObject = r, this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({ type: "pressstart", mouseEvent: t })), "mousemove" === this.userMouse.type || this.options.enableReticle) && (r && r.dispatchEvent && r.dispatchEvent({ type: "hover", mouseEvent: t }), this.pressEntityObject && this.pressEntityObject.dispatchEvent && this.pressEntityObject.dispatchEvent({ type: "pressmove-entity", mouseEvent: t }), this.pressObject && this.pressObject.dispatchEvent && this.pressObject.dispatchEvent({ type: "pressmove", mouseEvent: t })), !n && this.pressEntityObject && this.pressEntityObject.dispatchEvent && (this.pressEntityObject.dispatchEvent({ type: "pressstop-entity", mouseEvent: t }), this.pressEntityObject = void 0), !r && this.pressObject && this.pressObject.dispatchEvent && (this.pressObject.dispatchEvent({ type: "pressstop", mouseEvent: t }), this.pressObject = void 0)), r && r instanceof o) { if (this.infospot = r, "click" === e) return !0 } else this.infospot && this.hideInfospot(); this.options.autoRotate && "mousemove" !== this.userMouse.type && (clearTimeout(this.autoRotateRequestId), this.control === this.OrbitControls && (this.OrbitControls.autoRotate = !1, this.autoRotateRequestId = window.setTimeout(this.enableAutoRate.bind(this), this.options.autoRotateActivationDuration))) } }, getConvertedIntersect: function (t) { for (var e, i = 0; i < t.length; i++)if (0 <= t[i].distance && t[i].object && !t[i].object.passThrough && (!t[i].object.entity || !t[i].object.entity.passThrough)) { e = t[i].object.entity && !t[i].object.entity.passThrough ? t[i].object.entity : t[i].object; break } return e }, hideInfospot: function () { this.infospot && (this.infospot.onHoverEnd(), this.infospot = void 0) }, toggleControlBar: function () { var t = this.widget; t && t.dispatchEvent({ type: "control-bar-toggle" }) }, onKeyDown: function (t) { this.options.output && "none" !== this.options.output && "Control" === t.key && (this.outputEnabled = !0) }, onKeyUp: function () { this.outputEnabled = !1 }, update: function () { O.update(), this.updateCallbacks.forEach((function (t) { t() })), this.control.update(), this.scene.traverse(function (t) { if (t instanceof o && t.element && (this.hoverObject === t || "none" !== t.element.style.display || t.element.left && "none" !== t.element.left.style.display || t.element.right && "none" !== t.element.right.style.display)) if (this.checkSpriteInViewport(t)) { var i = this.getScreenVector(t.getWorldPosition(new e.Vector3)); t.translateElement(i.x, i.y) } else t.onDismiss() }.bind(this)) }, render: function () { this.mode === T.CARDBOARD || this.mode === T.STEREO ? (this.renderer.clear(), this.effect.render(this.scene, this.camera, this.panorama), this.effect.render(this.sceneReticle, this.camera)) : (this.renderer.clear(), this.renderer.render(this.scene, this.camera), this.renderer.clearDepth(), this.renderer.render(this.sceneReticle, this.camera)) }, animate: function () { this.requestAnimationId = window.requestAnimationFrame(this.animate.bind(this)), this.onChange() }, onChange: function () { this.update(), this.render() }, registerMouseAndTouchEvents: function () { var t = { passive: !1 }; this.container.addEventListener("mousedown", this.handlerMouseDown, t), this.container.addEventListener("mousemove", this.handlerMouseMove, t), this.container.addEventListener("mouseup", this.handlerMouseUp, t), this.container.addEventListener("touchstart", this.handlerMouseDown, t), this.container.addEventListener("touchend", this.handlerMouseUp, t) }, unregisterMouseAndTouchEvents: function () { this.container.removeEventListener("mousedown", this.handlerMouseDown, !1), this.container.removeEventListener("mousemove", this.handlerMouseMove, !1), this.container.removeEventListener("mouseup", this.handlerMouseUp, !1), this.container.removeEventListener("touchstart", this.handlerMouseDown, !1), this.container.removeEventListener("touchend", this.handlerMouseUp, !1) }, registerReticleEvent: function () { this.addUpdateCallback(this.handlerTap) }, unregisterReticleEvent: function () { this.removeUpdateCallback(this.handlerTap) }, updateReticleEvent: function () { var t = this.container.clientWidth / 2 + this.container.offsetLeft, e = this.container.clientHeight / 2; this.removeUpdateCallback(this.handlerTap), this.handlerTap = this.onTap.bind(this, { clientX: t, clientY: e }), this.addUpdateCallback(this.handlerTap) }, registerEventListeners: function () { window.addEventListener("resize", this.handlerWindowResize, !0), window.addEventListener("keydown", this.handlerKeyDown, !0), window.addEventListener("keyup", this.handlerKeyUp, !0) }, unregisterEventListeners: function () { window.removeEventListener("resize", this.handlerWindowResize, !0), window.removeEventListener("keydown", this.handlerKeyDown, !0), window.removeEventListener("keyup", this.handlerKeyUp, !0) }, dispose: function () { this.disableAutoRate(), this.tweenLeftAnimation.stop(), this.tweenUpAnimation.stop(), this.unregisterEventListeners(), function t(e) { for (var i = e.children.length - 1; 0 <= i; i--)t(e.children[i]), e.remove(e.children[i]); e instanceof s || e instanceof o ? e.dispose() : e.dispatchEvent && e.dispatchEvent("dispose") }(this.scene), this.widget && (this.widget.dispose(), this.widget = null), e.Cache && e.Cache.enabled && e.Cache.clear() }, destroy: function () { this.dispose(), this.render(), window.cancelAnimationFrame(this.requestAnimationId) }, onPanoramaDispose: function (t) { t instanceof d && this.hideVideoWidget(), t === this.panorama && (this.panorama = null) }, loadAsyncRequest: function (t, e) { e = void 0 === e ? function () { } : e; var i = new window.XMLHttpRequest; i.onloadend = function (t) { e(t) }, i.open("GET", t, !0), i.send(null) }, addViewIndicator: function () { var t = this; this.loadAsyncRequest(L.ViewIndicator, (function (i) { if (0 !== i.loaded) { (i = i.target.responseXML.documentElement).style.width = t.viewIndicatorSize + "px", i.style.height = t.viewIndicatorSize + "px", i.style.position = "absolute", i.style.top = "10px", i.style.left = "10px", i.style.opacity = "0.5", i.style.cursor = "pointer", i.id = "panolens-view-indicator-container", t.container.appendChild(i); var n = i.querySelector("#indicator"); t.addUpdateCallback((function () { t.radius = .225 * t.viewIndicatorSize, t.currentPanoAngle = t.camera.rotation.y - e.Math.degToRad(90), t.fovAngle = e.Math.degToRad(t.camera.fov), t.leftAngle = -t.currentPanoAngle - t.fovAngle / 2, t.rightAngle = -t.currentPanoAngle + t.fovAngle / 2, t.leftX = t.radius * Math.cos(t.leftAngle), t.leftY = t.radius * Math.sin(t.leftAngle), t.rightX = t.radius * Math.cos(t.rightAngle), t.rightY = t.radius * Math.sin(t.rightAngle), t.indicatorD = "M " + t.leftX + " " + t.leftY + " A " + t.radius + " " + t.radius + " 0 0 1 " + t.rightX + " " + t.rightY, t.leftX && t.leftY && t.rightX && t.rightY && t.radius && n.setAttribute("d", t.indicatorD) })), i.addEventListener("mouseenter", (function () { this.style.opacity = "1" })), i.addEventListener("mouseleave", (function () { this.style.opacity = "0.5" })) } })) }, appendControlItem: function (t) { var e = this.widget.createCustomItem(t); return "video" === t.group ? this.widget.videoElement.appendChild(e) : this.widget.barElement.appendChild(e), e }, clearAllCache: function () { e.Cache.clear() } }), "105" != e.REVISION && console.warn("three.js version is not matched. Please consider use the target revision 105"), window.TWEEN = O, t.BasicPanorama = u, t.CONTROLS = A, t.CameraPanorama = v, t.CubePanorama = l, t.CubeTextureLoader = P, t.DataImage = L, t.EmptyPanorama = h, t.GoogleStreetviewPanorama = f, t.ImageLittlePlanet = g, t.ImageLoader = C, t.ImagePanorama = c, t.Infospot = o, t.LittlePlanet = m, t.MODES = T, t.Media = i, t.Panorama = s, t.REVISION = "11", t.Reticle = r, t.STEREOFORMAT = S, t.Stereo = n, t.StereoImagePanorama = y, t.StereoVideoPanorama = x, t.THREE_REVISION = "105", t.THREE_VERSION = E, t.TextureLoader = R, t.VERSION = "0.11.0", t.VideoPanorama = d, t.Viewer = _, t.Widget = a, Object.defineProperty(t, "__esModule", { value: !0 }) }));